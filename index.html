<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Computer Organization & Architecture Course</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.8.1/font/bootstrap-icons.css">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f8f9fa;
        }
        .slide {
            display: none;
            padding: 30px;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
            min-height: 400px;
        }
        .slide.active {
            display: block;
        }
        .slide-content {
            margin-top: 20px;
        }
        .slide-title {
            color: #0d6efd;
            margin-bottom: 20px;
            border-bottom: 2px solid #0d6efd;
            padding-bottom: 10px;
        }
        .navigation {
            display: flex;
            justify-content: space-between;
            margin-top: 20px;
        }
        .sidebar {
            background-color: #343a40;
            color: white;
            padding: 20px;
            border-radius: 10px;
            height: 100%;
        }
        .sidebar-title {
            font-size: 1.2rem;
            font-weight: bold;
            margin-bottom: 15px;
            color: #0d6efd;
        }
        .unit-title {
            cursor: pointer;
            margin-bottom: 10px;
            font-weight: bold;
            color: #adb5bd;
            transition: color 0.3s;
        }
        .unit-title:hover {
            color: white;
        }
        .unit-title.active {
            color: white;
        }
        .slide-list {
            list-style-type: none;
            padding-left: 15px;
            display: none;
        }
        .slide-list.show {
            display: block;
        }
        .slide-item {
            cursor: pointer;
            margin: 5px 0;
            color: #adb5bd;
            font-size: 0.9rem;
            transition: color 0.3s;
        }
        .slide-item:hover {
            color: white;
        }
        .slide-item.active {
            color: #0d6efd;
        }
        .lecturer-info {
            margin-top: 20px;
            font-style: italic;
            text-align: right;
        }
        .info-box {
            background-color: #e9ecef;
            border-left: 4px solid #0d6efd;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        .diagram {
            width: 100%;
            max-width: 600px;
            margin: 20px auto;
            display: block;
        }
        table {
            width: 100%;
            margin: 15px 0;
        }
        .code-block {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            overflow-x: auto;
        }
        .interactive-element {
            margin: 20px 0;
            padding: 15px;
            background-color: #f0f8ff;
            border-radius: 5px;
            border: 1px solid #0d6efd;
        }
        .svg-placeholder-text {
            fill: #dee2e6;
            font-weight: bold;
            font-size: 1.2rem;
            font-family: sans-serif;
            text-anchor: middle;
            dominant-baseline: middle;
        }
        .svg-placeholder-rect {
             fill: #868e96;
        }
        .gate-diagram {
            width: 100px;
            height: 80px;
            margin: 10px;
        }
        .karnaugh-map {
            width: 200px;
            height: 200px;
            margin: 20px auto;
            border-collapse: collapse;
        }
        .karnaugh-map td {
            width: 50px;
            height: 50px;
            border: 1px solid #000;
            text-align: center;
            vertical-align: middle;
        }
        .karnaugh-map th {
            padding: 5px;
        }
        .flip-flop-diagram {
            width: 150px;
            height: 100px;
            margin: 10px;
        }
        .counter-diagram {
            width: 100%;
            max-width: 500px;
            margin: 20px auto;
        }
    </style>
</head>
<body>
    <div class="container-fluid py-4">
        <div class="row">
            <div class="col-md-3">
                <div class="sidebar">
                    <div class="sidebar-title">Computer Organization & Architecture</div>
                    
                    <div class="unit-container">
                        <div class="unit-title" data-unit="1">Unit 1: Fundamentals of Digital Logic</div>
                        <ul class="slide-list" id="unit1-slides">
                            <li class="slide-item" data-slide="1.1">Boolean Algebra</li>
                            <li class="slide-item" data-slide="1.2">Logic Gates</li>
                            <li class="slide-item" data-slide="1.3">Algebraic Simplification</li>
                            <li class="slide-item" data-slide="1.4">Karnaugh Maps</li>
                            <li class="slide-item" data-slide="1.5">Combinational Circuits</li>
                            <li class="slide-item" data-slide="1.6">Adders, Mux, De-Mux</li>
                            <li class="slide-item" data-slide="1.7">Sequential Circuits</li>
                            <li class="slide-item" data-slide="1.8">Flip-Flops (SR, JK & D)</li>
                            <li class="slide-item" data-slide="1.9">Counters</li>
                        </ul>
                    </div>
                    
                    <div class="unit-container">
                        <div class="unit-title" data-unit="2">Unit 2: Computer System</div>
                        <ul class="slide-list" id="unit2-slides">
                            <li class="slide-item" data-slide="2.1">Computer Organization vs Architecture</li>
                            <li class="slide-item" data-slide="2.2">Computer Components and Functions</li>
                            <li class="slide-item" data-slide="2.3">Interconnection Structures</li>
                            <li class="slide-item" data-slide="2.4">Bus Interconnections</li>
                            <li class="slide-item" data-slide="2.5">I/O Module</li>
                            <li class="slide-item" data-slide="2.6">Programmed I/O</li>
                            <li class="slide-item" data-slide="2.7">Interrupt Driven I/O</li>
                            <li class="slide-item" data-slide="2.8">Direct Memory Access</li>
                        </ul>
                    </div>
                    
                    <div class="unit-container">
                        <div class="unit-title" data-unit="3">Unit 3: Memory System Organization</div>
                        <ul class="slide-list" id="unit3-slides">
                            <li class="slide-item" data-slide="3.1">Memory Classification & Parameters</li>
                            <li class="slide-item" data-slide="3.2">Memory Hierarchy</li>
                            <li class="slide-item" data-slide="3.3">RAM, SRAM and DRAM</li>
                            <li class="slide-item" data-slide="3.4">Interleaved and Associative Memory</li>
                            <li class="slide-item" data-slide="3.5">Cache Memory Principles</li>
                            <li class="slide-item" data-slide="3.6">Memory Mappings</li>
                            <li class="slide-item" data-slide="3.7">Cache Performance</li>
                            <li class="slide-item" data-slide="3.8">Virtual Memory</li>
                            <li class="slide-item" data-slide="3.9">External Memory</li>
                            <li class="slide-item" data-slide="3.10">RAID Levels</li>
                        </ul>
                    </div>
                    
                    <div class="unit-container">
                        <div class="unit-title" data-unit="4">Unit 4: Processor Organization</div>
                        <ul class="slide-list" id="unit4-slides">
                            <li class="slide-item" data-slide="4.1">Instruction Formats</li>
                            <li class="slide-item" data-slide="4.2">Instruction Sets</li>
                            <li class="slide-item" data-slide="4.3">Addressing Modes</li>
                            <li class="slide-item" data-slide="4.4">Assembly Language Examples</li>
                            <li class="slide-item" data-slide="4.5">Processor Organization</li>
                            <li class="slide-item" data-slide="4.6">Register Organization</li>
                            <li class="slide-item" data-slide="4.7">Instruction Cycle</li>
                            <li class="slide-item" data-slide="4.8">Instruction Pipelining</li>
                            <li class="slide-item" data-slide="4.9">RISC vs CISC</li>
                            <li class="slide-item" data-slide="4.10">Superscalar Processors</li>
                        </ul>
                    </div>
                    
                    <div class="unit-container">
                        <div class="unit-title" data-unit="5">Unit 5: Control Unit</div>
                        <ul class="slide-list" id="unit5-slides">
                            <li class="slide-item" data-slide="5.1">Micro-Operations</li>
                            <li class="slide-item" data-slide="5.2">Functional Requirements</li>
                            <li class="slide-item" data-slide="5.3">Processor Control</li>
                            <li class="slide-item" data-slide="5.4">Hardwired Implementation</li>
                            <li class="slide-item" data-slide="5.5">Micro-programmed Control</li>
                        </ul>
                    </div>
                    
                    <div class="unit-container">
                        <div class="unit-title" data-unit="6">Unit 6: Advanced Computer Architecture</div>
                        <ul class="slide-list" id="unit6-slides">
                            <li class="slide-item" data-slide="6.1">Classification of Parallel Systems</li>
                            <li class="slide-item" data-slide="6.2">Flynn's Taxonomy</li>
                            <li class="slide-item" data-slide="6.3">Array Processors</li>
                            <li class="slide-item" data-slide="6.4">Clusters and NUMA Computers</li>
                            <li class="slide-item" data-slide="6.5">Multiprocessor Systems</li>
                            <li class="slide-item" data-slide="6.6">Interconnection Networks</li>
                            <li class="slide-item" data-slide="6.7">Multi-Core Computers</li>
                            <li class="slide-item" data-slide="6.8">Performance Considerations</li>
                        </ul>
                    </div>
                    
                    <div class="mt-4">
                        <div class="card">
                            <div class="card-header bg-primary text-white">
                                <h5 class="mb-0">Course Information</h5>
                            </div>
                            <div class="card-body text-dark">
                                <div class="row">
                                    <div class="col-md-4 fw-bold">By</div>
                                    <div class="col-md-8">Rishabh Gupta</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="col-md-9">
                <div class="slide-container">
                    <!-- Unit 1 Slides -->
                    <div class="slide active" id="slide-1.1">
                        <h2 class="slide-title">Boolean Algebra</h2>
                        <div class="slide-content">
                            <h4>The Foundation of Digital Computing</h4>
                            <p>Boolean algebra, developed by George Boole in 1854, is the mathematical basis for all digital circuits and computer operations. It deals with variables that have only two possible values: <strong>true (1)</strong> or <strong>false (0)</strong>.</p>
                            
                            <div class="info-box">
                                <h5>Modern Application Example: Smart Home System</h5>
                                <p>Consider a smart home security system that activates an alarm when:</p>
                                <p><strong>Alarm = (MotionDetected AND Armed) OR (WindowBroken AND Armed)</strong></p>
                                <p>This Boolean expression determines when the alarm sounds based on sensor inputs.</p>
                            </div>
                            
                            <h4>Core Boolean Operations</h4>
                            <div class="row">
                                <div class="col-md-4">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">
                                            AND (·)
                                        </div>
                                        <div class="card-body">
                                            <p>Output is true only if all inputs are true.</p>
                                            <p><strong>Example:</strong> A car starts only if <em>Key is inserted</em> AND <em>Brake is pressed</em>.</p>
                                            <table class="table table-sm table-bordered">
                                                <tr><th>A</th><th>B</th><th>A·B</th></tr>
                                                <tr><td>0</td><td>0</td><td>0</td></tr>
                                                <tr><td>0</td><td>1</td><td>0</td></tr>
                                                <tr><td>1</td><td>0</td><td>0</td></tr>
                                                <tr><td>1</td><td>1</td><td>1</td></tr>
                                            </table>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">
                                            OR (+)
                                        </div>
                                        <div class="card-body">
                                            <p>Output is true if any input is true.</p>
                                            <p><strong>Example:</strong> A phone rings when <em>Call comes in</em> OR <em>Alarm goes off</em>.</p>
                                            <table class="table table-sm table-bordered">
                                                <tr><th>A</th><th>B</th><th>A+B</th></tr>
                                                <tr><td>0</td><td>0</td><td>0</td></tr>
                                                <tr><td>0</td><td>1</td><td>1</td></tr>
                                                <tr><td>1</td><td>0</td><td>1</td></tr>
                                                <tr><td>1</td><td>1</td><td>1</td></tr>
                                            </table>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">
                                            NOT (¬ or ')
                                        </div>
                                        <div class="card-body">
                                            <p>Output is the inverse of the input.</p>
                                            <p><strong>Example:</strong> A "Do Not Disturb" mode inverts notification settings.</p>
                                            <table class="table table-sm table-bordered">
                                                <tr><th>A</th><th>¬A</th></tr>
                                                <tr><td>0</td><td>1</td></tr>
                                                <tr><td>1</td><td>0</td></tr>
                                            </table>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <h4 class="mt-4">Boolean Algebra Laws</h4>
                            <div class="table-responsive">
                                <table class="table table-bordered">
                                    <thead class="table-primary">
                                        <tr>
                                            <th>Law</th>
                                            <th>AND Form</th>
                                            <th>OR Form</th>
                                            <th>Real-world Analogy</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <tr>
                                            <td>Identity</td>
                                            <td>1·A = A</td>
                                            <td>0 + A = A</td>
                                            <td>Multiplying by 1 or adding 0 doesn't change value</td>
                                        </tr>
                                        <tr>
                                            <td>Domination</td>
                                            <td>0·A = 0</td>
                                            <td>1 + A = 1</td>
                                            <td>False AND anything is false; True OR anything is true</td>
                                        </tr>
                                        <tr>
                                            <td>Idempotent</td>
                                            <td>A·A = A</td>
                                            <td>A + A = A</td>
                                            <td>Repeating the same input doesn't change output</td>
                                        </tr>
                                        <tr>
                                            <td>Complement</td>
                                            <td>A·A' = 0</td>
                                            <td>A + A' = 1</td>
                                            <td>A condition and its opposite can't be true together</td>
                                        </tr>
                                        <tr>
                                            <td>De Morgan's</td>
                                            <td>(A·B)' = A' + B'</td>
                                            <td>(A + B)' = A'·B'</td>
                                            <td>Negation of AND is OR of negations, and vice versa</td>
                                        </tr>
                                    </tbody>
                                </table>
                            </div>
                            
                            <div class="interactive-element mt-4">
                                <h5>Practice: Simplify Boolean Expressions</h5>
                                <div class="mb-3">
                                    <label class="form-label">Simplify: A·(B + A·C) + A'·B</label>
                                    <div class="input-group">
                                        <input type="text" class="form-control" id="booleanExpression" placeholder="Your simplified expression">
                                        <button class="btn btn-primary" onclick="checkBooleanSolution()">Check</button>
                                    </div>
                                </div>
                                <div id="booleanFeedback" class="alert" style="display: none;"></div>
                                <button class="btn btn-outline-secondary" onclick="showBooleanSolution()">Show Solution</button>
                                <div id="booleanSolution" class="mt-3 p-3 bg-light rounded" style="display: none;">
                                    <p><strong>Step-by-Step Solution:</strong></p>
                                    <p>1. A·(B + A·C) + A'·B</p>
                                    <p>2. A·B + A·A·C + A'·B (Distributive Law)</p>
                                    <p>3. A·B + A·C + A'·B (Idempotent Law: A·A = A)</p>
                                    <p>4. (A + A')·B + A·C (Distributive Law)</p>
                                    <p>5. 1·B + A·C (Complement Law: A + A' = 1)</p>
                                    <p>6. B + A·C (Identity Law)</p>
                                    <p><strong>Final Answer: B + A·C</strong></p>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" disabled>Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('1.2')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 1.2: Logic Gates -->
                    <div class="slide" id="slide-1.2">
                        <h2 class="slide-title">Logic Gates</h2>
                        <div class="slide-content">
                            <h4>The Building Blocks of Digital Circuits</h4>
                            <p>Logic gates are physical implementations of Boolean operations. Modern processors contain billions of these gates working together to perform computations.</p>
                            
                            <div class="info-box">
                                <h5>Modern Example: Smartphone Touchscreen</h5>
                                <p>A touchscreen uses logic gates to:</p>
                                <ul>
                                    <li>Detect finger presence (AND of multiple sensor signals)</li>
                                    <li>Ignore accidental touches (combination of timing and threshold logic)</li>
                                    <li>Determine swipe direction (sequence of coordinate comparisons)</li>
                                </ul>
                            </div>
                            
                            <h4>Basic Logic Gates</h4>
                            <div class="row">
                                <div class="col-md-4 text-center">
                                    <svg class="gate-diagram">
                                        <rect x="10" y="20" width="80" height="40" rx="5" fill="#e9ecef" stroke="#000"/>
                                        <text x="50" y="40" font-weight="bold">AND</text>
                                        <line x1="0" y1="30" x2="10" y2="30" stroke="#000" stroke-width="2"/>
                                        <line x1="0" y1="50" x2="10" y2="50" stroke="#000" stroke-width="2"/>
                                        <line x1="90" y1="40" x2="100" y2="40" stroke="#000" stroke-width="2"/>
                                    </svg>
                                    <p><strong>AND Gate</strong></p>
                                    <p>Outputs 1 only if all inputs are 1</p>
                                    <p><em>Example:</em> Seatbelt warning: EngineOn AND SeatbeltOff → Warning</p>
                                </div>
                                <div class="col-md-4 text-center">
                                    <svg class="gate-diagram">
                                        <rect x="10" y="20" width="80" height="40" rx="5" fill="#e9ecef" stroke="#000"/>
                                        <text x="50" y="40" font-weight="bold">OR</text>
                                        <line x1="0" y1="30" x2="10" y2="30" stroke="#000" stroke-width="2"/>
                                        <line x1="0" y1="50" x2="10" y2="50" stroke="#000" stroke-width="2"/>
                                        <line x1="90" y1="40" x2="100" y2="40" stroke="#000" stroke-width="2"/>
                                    </svg>
                                    <p><strong>OR Gate</strong></p>
                                    <p>Outputs 1 if any input is 1</p>
                                    <p><em>Example:</em> Doorbell: FrontDoor OR BackDoor → Ring</p>
                                </div>
                                <div class="col-md-4 text-center">
                                    <svg class="gate-diagram">
                                        <rect x="10" y="20" width="80" height="40" rx="5" fill="#e9ecef" stroke="#000"/>
                                        <text x="50" y="40" font-weight="bold">NOT</text>
                                        <line x1="0" y1="40" x2="10" y2="40" stroke="#000" stroke-width="2"/>
                                        <line x1="90" y1="40" x2="100" y2="40" stroke="#000" stroke-width="2"/>
                                        <circle cx="20" cy="40" r="5" fill="none" stroke="#000" stroke-width="2"/>
                                    </svg>
                                    <p><strong>NOT Gate</strong></p>
                                    <p>Inverts the input</p>
                                    <p><em>Example:</em> Dark mode toggle: Light → Dark, Dark → Light</p>
                                </div>
                            </div>
                            
                            <h4 class="mt-4">Universal Gates</h4>
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card mb-4">
                                        <div class="card-header bg-primary text-white">
                                            NAND Gate (NOT-AND)
                                        </div>
                                        <div class="card-body text-center">
                                            <svg class="gate-diagram">
                                                <rect x="10" y="20" width="80" height="40" rx="5" fill="#e9ecef" stroke="#000"/>
                                                <text x="50" y="40" font-weight="bold">NAND</text>
                                                <line x1="0" y1="30" x2="10" y2="30" stroke="#000" stroke-width="2"/>
                                                <line x1="0" y1="50" x2="10" y2="50" stroke="#000" stroke-width="2"/>
                                                <line x1="90" y1="40" x2="100" y2="40" stroke="#000" stroke-width="2"/>
                                                <circle cx="85" cy="40" r="5" fill="none" stroke="#000" stroke-width="2"/>
                                            </svg>
                                            <p>Can implement any Boolean function alone</p>
                                            <p><strong>Truth Table:</strong></p>
                                            <table class="table table-sm table-bordered">
                                                <tr><th>A</th><th>B</th><th>A NAND B</th></tr>
                                                <tr><td>0</td><td>0</td><td>1</td></tr>
                                                <tr><td>0</td><td>1</td><td>1</td></tr>
                                                <tr><td>1</td><td>0</td><td>1</td></tr>
                                                <tr><td>1</td><td>1</td><td>0</td></tr>
                                            </table>
                                            <p><em>Modern Use:</em> Flash memory uses NAND gates for storage cells</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="card mb-4">
                                        <div class="card-header bg-primary text-white">
                                            NOR Gate (NOT-OR)
                                        </div>
                                        <div class="card-body text-center">
                                            <svg class="gate-diagram">
                                                <rect x="10" y="20" width="80" height="40" rx="5" fill="#e9ecef" stroke="#000"/>
                                                <text x="50" y="40" font-weight="bold">NOR</text>
                                                <line x1="0" y1="30" x2="10" y2="30" stroke="#000" stroke-width="2"/>
                                                <line x1="0" y1="50" x2="10" y2="50" stroke="#000" stroke-width="2"/>
                                                <line x1="90" y1="40" x2="100" y2="40" stroke="#000" stroke-width="2"/>
                                                <circle cx="85" cy="40" r="5" fill="none" stroke="#000" stroke-width="2"/>
                                            </svg>
                                            <p>Also a universal gate</p>
                                            <p><strong>Truth Table:</strong></p>
                                            <table class="table table-sm table-bordered">
                                                <tr><th>A</th><th>B</th><th>A NOR B</th></tr>
                                                <tr><td>0</td><td>0</td><td>1</td></tr>
                                                <tr><td>0</td><td>1</td><td>0</td></tr>
                                                <tr><td>1</td><td>0</td><td>0</td></tr>
                                                <tr><td>1</td><td>1</td><td>0</td></tr>
                                            </table>
                                            <p><em>Modern Use:</em> Used in SRAM (Static RAM) cells</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <h4>Integrated Circuits (ICs)</h4>
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card">
                                        <div class="card-header bg-primary text-white">
                                            TTL (Transistor-Transistor Logic)
                                        </div>
                                        <div class="card-body">
                                            <ul>
                                                <li>Uses bipolar transistors</li>
                                                <li>Standard 5V operation</li>
                                                <li>Example: 7400 series (NAND gates)</li>
                                                <li>Used in legacy systems and education</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="card">
                                        <div class="card-header bg-primary text-white">
                                            CMOS (Complementary MOS)
                                        </div>
                                        <div class="card-body">
                                            <ul>
                                                <li>Uses MOSFET transistors</li>
                                                <li>Low power consumption</li>
                                                <li>Dominates modern electronics</li>
                                                <li>Example: 4000 series, modern CPUs</li>
                                                <li>Works with 3.3V or lower in modern chips</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="interactive-element mt-4">
                                <h5>Logic Gate Simulator</h5>
                                <div class="row">
                                    <div class="col-md-6">
                                        <div class="mb-3">
                                            <label class="form-label">Select Gate Type:</label>
                                            <select class="form-select" id="gateType">
                                                <option value="AND">AND</option>
                                                <option value="OR">OR</option>
                                                <option value="NAND">NAND</option>
                                                <option value="NOR">NOR</option>
                                                <option value="XOR">XOR</option>
                                                <option value="XNOR">XNOR</option>
                                            </select>
                                        </div>
                                        <div class="mb-3">
                                            <label class="form-label">Input A:</label>
                                            <select class="form-select" id="inputA">
                                                <option value="0">0 (False)</option>
                                                <option value="1">1 (True)</option>
                                            </select>
                                        </div>
                                        <div class="mb-3">
                                            <label class="form-label">Input B:</label>
                                            <select class="form-select" id="inputB">
                                                <option value="0">0 (False)</option>
                                                <option value="1">1 (True)</option>
                                            </select>
                                        </div>
                                        <button class="btn btn-primary" onclick="simulateGate()">Simulate</button>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="card">
                                            <div class="card-header bg-success text-white">
                                                Simulation Result
                                            </div>
                                            <div class="card-body text-center">
                                                <svg width="150" height="100" id="gateSimulation" class="mb-3"></svg>
                                                <h4 id="gateResult">Output: </h4>
                                                <p id="gateExplanation" class="text-muted"></p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('1.1')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('1.3')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 1.3: Algebraic Simplification -->
                    <div class="slide" id="slide-1.3">
                        <h2 class="slide-title">Algebraic Simplification</h2>
                        <div class="slide-content">
                            <h4>Optimizing Digital Circuits</h4>
                            <p>Boolean algebra simplification reduces the complexity of digital circuits, leading to:</p>
                            <ul>
                                <li>Fewer gates → Lower cost</li>
                                <li>Less power consumption</li>
                                <li>Higher speed (reduced propagation delay)</li>
                                <li>Increased reliability (fewer components to fail)</li>
                            </ul>
                            
                            <div class="info-box">
                                <h5>Modern Application: Processor Design</h5>
                                <p>Modern CPUs like Apple's M1 or Intel's Core i9 use Boolean optimization to:</p>
                                <ul>
                                    <li>Minimize transistor count in arithmetic logic units (ALUs)</li>
                                    <li>Optimize instruction decoding logic</li>
                                    <li>Reduce power consumption in cache memory addressing</li>
                                </ul>
                            </div>
                            
                            <h4>Simplification Techniques</h4>
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">
                                            Basic Laws
                                        </div>
                                        <div class="card-body">
                                            <p><strong>Identity Laws:</strong></p>
                                            <p>A + 0 = A<br>A · 1 = A</p>
                                            
                                            <p><strong>Domination Laws:</strong></p>
                                            <p>A + 1 = 1<br>A · 0 = 0</p>
                                            
                                            <p><strong>Idempotent Laws:</strong></p>
                                            <p>A + A = A<br>A · A = A</p>
                                            
                                            <p><strong>Complement Laws:</strong></p>
                                            <p>A + A' = 1<br>A · A' = 0</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">
                                            Advanced Laws
                                        </div>
                                        <div class="card-body">
                                            <p><strong>Commutative Laws:</strong></p>
                                            <p>A + B = B + A<br>A · B = B · A</p>
                                            
                                            <p><strong>Associative Laws:</strong></p>
                                            <p>(A + B) + C = A + (B + C)<br>(A · B) · C = A · (B · C)</p>
                                            
                                            <p><strong>Distributive Laws:</strong></p>
                                            <p>A · (B + C) = A·B + A·C<br>A + B·C = (A + B)·(A + C)</p>
                                            
                                            <p><strong>De Morgan's Laws:</strong></p>
                                            <p>(A + B)' = A' · B'<br>(A · B)' = A' + B'</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <h4 class="mt-4">Step-by-Step Simplification Example</h4>
                            <div class="card">
                                <div class="card-header bg-primary text-white">
                                    Simplify: F = A'B'C + A'BC + AB'C + ABC'
                                </div>
                                <div class="card-body">
                                    <p><strong>Step 1:</strong> Group terms with common factors</p>
                                    <p>F = A'B'C + A'BC + AB'C + ABC'</p>
                                    <p>F = A'C(B' + B) + AB'C + ABC'</p>
                                    
                                    <p><strong>Step 2:</strong> Apply complement law (B' + B = 1)</p>
                                    <p>F = A'C(1) + AB'C + ABC'</p>
                                    <p>F = A'C + AB'C + ABC'</p>
                                    
                                    <p><strong>Step 3:</strong> Factor out C from first two terms</p>
                                    <p>F = C(A' + AB') + ABC'</p>
                                    
                                    <p><strong>Step 4:</strong> Apply distributive law (A' + AB' = A' + B')</p>
                                    <p>F = C(A' + B') + ABC'</p>
                                    
                                    <p><strong>Final Simplified Form:</strong></p>
                                    <p>F = A'C + B'C + ABC'</p>
                                </div>
                            </div>
                            
                            <h4 class="mt-4">Real-world Impact</h4>
                            <div class="row">
                                <div class="col-md-4">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">
                                            Power Efficiency
                                        </div>
                                        <div class="card-body">
                                            <p>Each eliminated gate saves:</p>
                                            <ul>
                                                <li>~1-10 μW in modern CMOS</li>
                                                <li>Multiplied by billions of gates in a CPU</li>
                                                <li>Results in significant battery life extension</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">
                                            Performance
                                        </div>
                                        <div class="card-body">
                                            <p>Reduced gate count means:</p>
                                            <ul>
                                                <li>Shorter critical paths</li>
                                                <li>Higher clock speeds possible</li>
                                                <li>Example: From 3GHz to 3.5GHz with optimization</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">
                                            Cost Reduction
                                        </div>
                                        <div class="card-body">
                                            <p>Fewer transistors:</p>
                                            <ul>
                                                <li>Smaller die size</li>
                                                <li>More chips per wafer</li>
                                                <li>Example: 5% size reduction → 10% cost saving</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="interactive-element mt-4">
                                <h5>Practice: Simplify These Expressions</h5>
                                <div class="row">
                                    <div class="col-md-6">
                                        <div class="card mb-3">
                                            <div class="card-header">
                                                1. A'B' + AB' + AB
                                            </div>
                                            <div class="card-body">
                                                <input type="text" class="form-control mb-2" placeholder="Your answer">
                                                <button class="btn btn-sm btn-outline-primary" onclick="showAnswer(1)">Show Answer</button>
                                                <div id="answer1" class="mt-2" style="display: none;">
                                                    <p>Solution: A + B'</p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="card mb-3">
                                            <div class="card-header">
                                                2. (A + B)(A + B')(A' + B)
                                            </div>
                                            <div class="card-body">
                                                <input type="text" class="form-control mb-2" placeholder="Your answer">
                                                <button class="btn btn-sm btn-outline-primary" onclick="showAnswer(2)">Show Answer</button>
                                                <div id="answer2" class="mt-2" style="display: none;">
                                                    <p>Solution: AB</p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('1.2')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('1.4')">Next</button>
                        </div>
                    </div>
                    <!-- Slide 1.4: Karnaugh Maps -->
                    <div class="slide" id="slide-1.4">
                        <h2 class="slide-title">Karnaugh Maps</h2>
                        <div class="slide-content">
                            <h4>Visual Boolean Simplification</h4>
                            <p>Karnaugh Maps (K-maps) provide a systematic method for simplifying Boolean expressions with 2-6 variables. They are particularly useful for minimizing the number of gates in digital circuits.</p>
                            
                            <div class="info-box">
                                <h5>Modern Application: Industrial Control Systems</h5>
                                <p>K-maps are used to design:</p>
                                <ul>
                                    <li>Elevator control logic (floor selection optimization)</li>
                                    <li>Traffic light controllers (state minimization)</li>
                                    <li>PLC (Programmable Logic Controller) programming</li>
                                </ul>
                            </div>
                            
                            <h4>2-Variable K-map</h4>
                            <div class="row">
                                <div class="col-md-6">
                                    <table class="karnaugh-map">
                                        <tr>
                                            <th></th>
                                            <th>B=0</th>
                                            <th>B=1</th>
                                        </tr>
                                        <tr>
                                            <th>A=0</th>
                                            <td>0</td>
                                            <td>1</td>
                                        </tr>
                                        <tr>
                                            <th>A=1</th>
                                            <td>1</td>
                                            <td>1</td>
                                        </tr>
                                    </table>
                                </div>
                                <div class="col-md-6">
                                    <p><strong>Example:</strong> F(A,B) = Σ(1,2,3)</p>
                                    <p>Group adjacent 1s:</p>
                                    <ul>
                                        <li>Red group: A'B (top-right cell)</li>
                                        <li>Blue group: A (bottom row)</li>
                                    </ul>
                                    <p><strong>Simplified expression:</strong> F = A + B</p>
                                    <p>Original gates: 3 ANDs + 1 OR → Simplified: 1 OR</p>
                                </div>
                            </div>
                            
                            <h4 class="mt-4">3-Variable K-map</h4>
                            <div class="row">
                                <div class="col-md-6">
                                    <table class="karnaugh-map">
                                        <tr>
                                            <th>AB\C</th>
                                            <th>0</th>
                                            <th>1</th>
                                        </tr>
                                        <tr>
                                            <th>00</th>
                                            <td>1</td>
                                            <td>0</td>
                                        </tr>
                                        <tr>
                                            <th>01</th>
                                            <td>0</td>
                                            <td>1</td>
                                        </tr>
                                        <tr>
                                            <th>11</th>
                                            <td>1</td>
                                            <td>1</td>
                                        </tr>
                                        <tr>
                                            <th>10</th>
                                            <td>0</td>
                                            <td>1</td>
                                        </tr>
                                    </table>
                                </div>
                                <div class="col-md-6">
                                    <p><strong>Example:</strong> F(A,B,C) = Σ(0,3,5,6,7)</p>
                                    <p>Grouping rules:</p>
                                    <ol>
                                        <li>Groups must contain 1,2,4,8... cells</li>
                                        <li>Groups must be rectangular</li>
                                        <li>Groups can wrap around edges</li>
                                        <li>Each group should be as large as possible</li>
                                    </ol>
                                    <p><strong>Simplified expression:</strong></p>
                                    <p>F = AB + A'B'C' + BC</p>
                                </div>
                            </div>
                            
                            <h4 class="mt-4">4-Variable K-map</h4>
                            <div class="row">
                                <div class="col-md-8">
                                    <table class="karnaugh-map">
                                        <tr>
                                            <th>AB\CD</th>
                                            <th>00</th>
                                            <th>01</th>
                                            <th>11</th>
                                            <th>10</th>
                                        </tr>
                                        <tr>
                                            <th>00</th>
                                            <td>1</td>
                                            <td>0</td>
                                            <td>0</td>
                                            <td>1</td>
                                        </tr>
                                        <tr>
                                            <th>01</th>
                                            <td>0</td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>0</td>
                                        </tr>
                                        <tr>
                                            <th>11</th>
                                            <td>0</td>
                                            <td>1</td>
                                            <td>1</td>
                                            <td>0</td>
                                        </tr>
                                        <tr>
                                            <th>10</th>
                                            <td>1</td>
                                            <td>0</td>
                                            <td>0</td>
                                            <td>1</td>
                                        </tr>
                                    </table>
                                </div>
                                <div class="col-md-4">
                                    <p><strong>Example:</strong> F(A,B,C,D) with don't cares</p>
                                    <p>Key concepts:</p>
                                    <ul>
                                        <li>Don't cares (X) can be treated as 0 or 1</li>
                                        <li>Groups can span all four corners</li>
                                        <li>Essential prime implicants must be covered</li>
                                    </ul>
                                </div>
                            </div>
                            
                            <h4 class="mt-4">K-map vs Algebraic Simplification</h4>
                            <table class="table table-bordered">
                                <thead class="table-primary">
                                    <tr>
                                        <th>Method</th>
                                        <th>Advantages</th>
                                        <th>Disadvantages</th>
                                        <th>Best For</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td>Algebraic</td>
                                        <td>Works for any number of variables, precise</td>
                                        <td>Easy to make mistakes, not visual</td>
                                        <td>Automated tools, theoretical proofs</td>
                                    </tr>
                                    <tr>
                                        <td>K-maps</td>
                                        <td>Visual, intuitive, minimizes human error</td>
                                        <td>Limited to 6 variables, manual process</td>
                                        <td>Small circuits, educational purposes</td>
                                    </tr>
                                </tbody>
                            </table>
                            
                            <div class="interactive-element mt-4">
                                <h5>Interactive K-map Solver</h5>
                                <div class="row">
                                    <div class="col-md-6">
                                        <div class="mb-3">
                                            <label class="form-label">Number of Variables:</label>
                                            <select class="form-select" id="kmapVars">
                                                <option value="2">2 Variables (A,B)</option>
                                                <option value="3">3 Variables (A,B,C)</option>
                                                <option value="4">4 Variables (A,B,C,D)</option>
                                            </select>
                                        </div>
                                        <div id="kmapGrid" class="mb-3">
                                            <!-- K-map grid will be generated here by JavaScript -->
                                        </div>
                                        <button class="btn btn-primary" onclick="solveKmap()">Simplify</button>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="card">
                                            <div class="card-header bg-success text-white">
                                                Solution
                                            </div>
                                            <div class="card-body">
                                                <h5>Groups:</h5>
                                                <div id="kmapGroups"></div>
                                                <h5 class="mt-3">Simplified Expression:</h5>
                                                <div id="kmapSolution" class="alert alert-info"></div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('1.3')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('1.5')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 1.5: Combinational Circuits -->
                    <div class="slide" id="slide-1.5">
                        <h2 class="slide-title">Combinational Circuits</h2>
                        <div class="slide-content">
                            <h4>Definition and Characteristics</h4>
                            <p>Combinational circuits are digital circuits where the output depends only on the current inputs (no memory). They perform specific processing functions.</p>
                            
                            <div class="info-box">
                                <h5>Modern Example: Smartphone Display</h5>
                                <p>Combinational circuits in displays:</p>
                                <ul>
                                    <li>RGB color mixing logic</li>
                                    <li>Touch coordinate calculation</li>
                                    <li>Brightness control circuits</li>
                                    <li>Pixel addressing logic</li>
                                </ul>
                            </div>
                            
                            <h4>Design Procedure</h4>
                            <ol>
                                <li><strong>Problem Definition:</strong> Determine inputs/outputs</li>
                                <li><strong>Truth Table:</strong> Enumerate all input combinations</li>
                                <li><strong>Boolean Expression:</strong> Derive from truth table</li>
                                <li><strong>Simplification:</strong> Use K-maps or algebra</li>
                                <li><strong>Implementation:</strong> Draw logic diagram</li>
                                <li><strong>Verification:</strong> Test with all input cases</li>
                            </ol>
                            
                            <h4>Common Combinational Circuits</h4>
                            <div class="row">
                                <div class="col-md-4">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">
                                            Adders
                                        </div>
                                        <div class="card-body">
                                            <p><strong>Half Adder:</strong></p>
                                            <p>Adds two 1-bit numbers</p>
                                            <p>Outputs: Sum and Carry</p>
                                            <p>S = A ⊕ B</p>
                                            <p>C = A·B</p>
                                            
                                            <p class="mt-3"><strong>Full Adder:</strong></p>
                                            <p>Adds three 1-bit numbers (includes carry-in)</p>
                                            <p>Used in multi-bit adders</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">
                                            Multiplexers (MUX)
                                        </div>
                                        <div class="card-body">
                                            <p>Selects one of many inputs to output</p>
                                            <p><strong>2<sup>n</sup>-to-1 MUX:</strong></p>
                                            <p>n select lines</p>
                                            <p>2<sup>n</sup> input lines</p>
                                            <p>1 output</p>
                                            
                                            <p class="mt-3"><strong>Applications:</strong></p>
                                            <ul>
                                                <li>Data routing</li>
                                                <li>Function generation</li>
                                                <li>Parallel-to-serial conversion</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">
                                            Decoders
                                        </div>
                                        <div class="card-body">
                                            <p>Converts binary code to output lines</p>
                                            <p><strong>n-to-2<sup>n</sup> decoder:</strong></p>
                                            <p>n input lines</p>
                                            <p>2<sup>n</sup> output lines</p>
                                            
                                            <p class="mt-3"><strong>Applications:</strong></p>
                                            <ul>
                                                <li>Memory address decoding</li>
                                                <li>Seven-segment displays</li>
                                                <li>Control logic</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <h4 class="mt-4">Real-world Implementation</h4>
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card">
                                        <div class="card-header bg-success text-white">
                                            Arithmetic Logic Unit (ALU)
                                        </div>
                                        <div class="card-body">
                                            <p>The ALU in processors is built from combinational circuits:</p>
                                            <ul>
                                                <li>Adders (for arithmetic operations)</li>
                                                <li>Multiplexers (to select operations)</li>
                                                <li>Logic gates (for AND, OR, XOR operations)</li>
                                                <li>Comparators (for relational operations)</li>
                                            </ul>
                                            <p><strong>Modern Example:</strong> Apple M1 ALU uses optimized combinational circuits for energy efficiency</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="card">
                                        <div class="card-header bg-success text-white">
                                            Memory Address Decoding
                                        </div>
                                        <div class="card-body">
                                            <p>Combinational circuits map memory addresses to physical locations:</p>
                                            <ul>
                                                <li>Row/column decoders in RAM</li>
                                                <li>Bank selection in multi-bank memory</li>
                                                <li>Cache tag comparison</li>
                                            </ul>
                                            <p><strong>Modern Example:</strong> DDR5 RAM uses sophisticated decoders for fast access</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="interactive-element mt-4">
                                <h5>Combinational Circuit Designer</h5>
                                <div class="row">
                                    <div class="col-md-6">
                                        <div class="mb-3">
                                            <label class="form-label">Select Circuit Type:</label>
                                            <select class="form-select" id="circuitType">
                                                <option value="adder">Adder</option>
                                                <option value="mux">Multiplexer</option>
                                                <option value="decoder">Decoder</option>
                                                <option value="encoder">Encoder</option>
                                            </select>
                                        </div>
                                        <div id="circuitParams"></div>
                                        <button class="btn btn-primary mt-2" onclick="designCircuit()">Design Circuit</button>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="card">
                                            <div class="card-header bg-info text-white">
                                                Circuit Diagram
                                            </div>
                                            <div class="card-body text-center" id="circuitDiagram">
                                                <p>Select a circuit type to begin</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('1.4')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('1.6')">Next</button>
                        </div>
                    </div>

                    <div class="slide" id="slide-1.6">
                        <h2 class="slide-title">Adders, Multiplexers, and Demultiplexers</h2>
                        <div class="slide-content">
                            <h4>Fundamental Building Blocks of Digital Systems</h4>
                            <p>These components form the foundation of digital arithmetic and data routing in modern processors. Understanding their operation is essential for computer architecture and digital design.</p>
                    
                            <div class="row">
                                <div class="col-md-4">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Half Adder</div>
                                        <div class="card-body">
                                            <div class="text-center">
                                                <img src="imgs/HA.png" alt="AMD Zen Architecture" class="img-fluid mb-2" />
                                            </div>
                                            <p><strong>Inputs:</strong> A, B (single-bit inputs)</p>
                                            <p><strong>Outputs:</strong> Sum (S), Carry (C)</p>
                                            <p><strong>Truth Table:</strong></p>
                                            <table class="table table-sm table-bordered">
                                                <tr><th>A</th><th>B</th><th>S</th><th>C</th></tr>
                                                <tr><td>0</td><td>0</td><td>0</td><td>0</td></tr>
                                                <tr><td>0</td><td>1</td><td>1</td><td>0</td></tr>
                                                <tr><td>1</td><td>0</td><td>1</td><td>0</td></tr>
                                                <tr><td>1</td><td>1</td><td>0</td><td>1</td></tr>
                                            </table>
                                            <p><strong>Boolean Equations:</strong></p>
                                            <p>S = A ⊕ B (XOR operation)</p>
                                            <p>C = A · B (AND operation)</p>
                                            <div class="info-box bg-light p-2 mt-2 border rounded">
                                                <strong>Modern Use:</strong> While rarely used alone in modern processors, the half adder concept is fundamental to understanding more complex adder designs. It's the building block for full adders and appears in ALU designs.
                                            </div>
                                        </div>
                                    </div>
                                </div>
                    
                                <div class="col-md-4">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Full Adder</div>
                                        <div class="card-body">
                                            <div class="text-center">
                                                <img src="imgs/FA.png" alt="AMD Zen Architecture" class="img-fluid mb-2" />
                                            </div>
                                            <p><strong>Inputs:</strong> A, B, Cin (carry-in from previous stage)</p>
                                            <p><strong>Outputs:</strong> Sum (S), Cout (carry-out)</p>
                                            <p><strong>Boolean Equations:</strong></p>
                                            <p>S = A ⊕ B ⊕ Cin (chained XOR operations)</p>
                                            <p>Cout = (A·B) + (Cin·(A⊕B))</p>
                                            <div class="info-box bg-light p-2 mt-2 border rounded">
                                                <strong>Application:</strong> Full adders are chained together to create adders of any width (8-bit, 16-bit, 32-bit, etc.). Modern processors use optimized versions like carry-lookahead adders for better performance in critical paths.
                                            </div>
                                        </div>
                                    </div>
                                </div>
                    
                                <div class="col-md-4">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">4-bit Ripple Carry Adder</div>
                                        <div class="card-body">
                                            <div class="text-center">
                                                <img src="imgs/4BRA.png" alt="AMD Zen Architecture" class="img-fluid mb-2" />
                                            </div>
                                            <p>Cascaded full adders for multi-bit addition where the carry-out of each stage feeds into the carry-in of the next stage. This creates a "ripple" effect for the carry signal.</p>
                                            <ul>
                                                <li><strong>Advantage:</strong> Simple design, minimal hardware</li>
                                                <li><strong>Disadvantage:</strong> Slow for wide adders (32-bit, 64-bit) due to carry propagation delay (O(n) time complexity)</li>
                                                <li><strong>Critical Path:</strong> The carry must propagate through all stages from LSB to MSB</li>
                                            </ul>
                                            <div class="info-box bg-light p-2 mt-2 border rounded">
                                                <strong>Modern Enhancement:</strong> Carry Look-ahead adders predict carry signals in parallel for faster operation (O(log n) time). Modern processors use more advanced techniques like Kogge-Stone or Brent-Kung adders for critical paths.
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <h4 class="mt-4">Multiplexers (MUX)</h4>
                            <p>Multiplexers are digital switches that select one of many input lines and route it to a single output line based on select signals. They are fundamental in:</p>
                            <ul>
                                <li>Data path design</li>
                                <li>Register file implementation</li>
                                <li>ALU operations</li>
                                <li>Memory addressing</li>
                                <li>Bus routing and selection</li>
                            </ul>
                            
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">2-to-1 Multiplexer</div>
                                        <div class="card-body">
                                            <div class="text-center">
                                                <img src="imgs/21M.png" alt="AMD Zen Architecture" class="img-fluid mb-2" />
                                            </div>
                                            <table class="table table-sm table-bordered">
                                                <tr>
                                                    <th>Select (S)</th>
                                                    <th>Output (Y)</th>
                                                </tr>
                                                <tr>
                                                    <td>0</td>
                                                    <td>Input 0 (I0)</td>
                                                </tr>
                                                <tr>
                                                    <td>1</td>
                                                    <td>Input 1 (I1)</td>
                                                </tr>
                                            </table>
                                            <p><strong>Boolean Equation:</strong> Y = (I0·¬S) + (I1·S)</p>
                                            <p><strong>Gate Implementation:</strong> Can be built with two AND gates and one OR gate, or more efficiently with transmission gates in CMOS technology.</p>
                                            <div class="info-box bg-light p-2 mt-2 border rounded">
                                                <strong>Implementation:</strong> In modern processors, multiplexers are often implemented with transmission gates for better performance and smaller area. A 2:1 MUX requires just 6 transistors in CMOS technology.
                                            </div>
                                        </div>
                                    </div>
                                </div>
                    
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">4-to-1 Multiplexer</div>
                                        <div class="card-body">
                                            <div class="text-center">
                                                <img src="imgs/41M.png" alt="AMD Zen Architecture" class="img-fluid mb-2" />
                                            </div>
                                            <p>Uses 2 select lines (S0, S1) to choose from 4 inputs (I0-I3). The select lines form a binary number that determines which input is routed to the output.</p>
                                            <table class="table table-sm table-bordered">
                                                <tr><th>S1</th><th>S0</th><th>Output (Y)</th></tr>
                                                <tr><td>0</td><td>0</td><td>I0</td></tr>
                                                <tr><td>0</td><td>1</td><td>I1</td></tr>
                                                <tr><td>1</td><td>0</td><td>I2</td></tr>
                                                <tr><td>1</td><td>1</td><td>I3</td></tr>
                                            </table>
                                            <p><strong>Implementation:</strong> Can be built using:</p>
                                            <ul>
                                                <li>AND-OR logic (4 AND gates + 1 OR gate)</li>
                                                <li>Hierarchical 2:1 MUXes (three 2:1 MUXes)</li>
                                                <li>Transmission gate logic (most efficient in CMOS)</li>
                                            </ul>
                                            <div class="info-box bg-light p-2 mt-2 border rounded">
                                                <strong>Modern Use:</strong> Cache line selection in processors, register file read ports, and data path routing. Modern CPUs use hierarchical MUX designs to manage wide datapaths (64-bit, 128-bit) efficiently.
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <h4 class="mt-4">Demultiplexers (DEMUX)</h4>
                            <p>Demultiplexers perform the opposite function of multiplexers - they route a single input to one of many outputs based on select signals. Essential in:</p>
                            <ul>
                                <li>Memory systems (address decoding)</li>
                                <li>Peripheral addressing</li>
                                <li>Bus routing</li>
                                <li>Instruction decoding</li>
                                <li>Display drivers</li>
                            </ul>
                            
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">1-to-2 Demultiplexer</div>
                                        <div class="card-body">
                                            <div class="text-center">
                                                <img src="imgs/21DM.png" alt="AMD Zen Architecture" class="img-fluid mb-2" />
                                            </div>
                                            <p>Routes single input to one of two outputs based on the select line. When S=0, input is routed to Y0; when S=1, input is routed to Y1.</p>
                                            <table class="table table-sm table-bordered">
                                                <tr><th>Select (S)</th><th>Y0</th><th>Y1</th></tr>
                                                <tr><td>0</td><td>Input (D)</td><td>0</td></tr>
                                                <tr><td>1</td><td>0</td><td>Input (D)</td></tr>
                                            </table>
                                            <p><strong>Boolean Equations:</strong></p>
                                            <p>Y0 = D · ¬S</p>
                                            <p>Y1 = D · S</p>
                                            <div class="info-box bg-light p-2 mt-2 border rounded">
                                                <strong>Implementation:</strong> Typically built using AND gates with complemented select signals. In CMOS, can be implemented with transmission gates controlled by the select signals.
                                            </div>
                                        </div>
                                    </div>
                                </div>
                    
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">1-to-4 Demultiplexer</div>
                                        <div class="card-body">
                                            <div class="text-center">
                                                <img src="imgs/41DM.png" alt="AMD Zen Architecture" class="img-fluid mb-2" />
                                            </div>
                                            <p>Uses 2 select lines (S0, S1) to route input to one of 4 outputs (Y0-Y3). The non-selected outputs remain inactive (typically 0).</p>
                                            <table class="table table-sm table-bordered">
                                                <tr><th>S1</th><th>S0</th><th>Active Output</th></tr>
                                                <tr><td>0</td><td>0</td><td>Y0 = D</td></tr>
                                                <tr><td>0</td><td>1</td><td>Y1 = D</td></tr>
                                                <tr><td>1</td><td>0</td><td>Y2 = D</td></tr>
                                                <tr><td>1</td><td>1</td><td>Y3 = D</td></tr>
                                            </table>
                                            <p><strong>Implementation:</strong> Essentially a 2-to-4 decoder with an enable input (the data input D). Each output is gated with one minterm of the select lines.</p>
                                            <div class="info-box bg-light p-2 mt-2 border rounded">
                                                <strong>Application:</strong> Memory address decoding where a single enable signal needs to select one of multiple memory chips or banks. Also used in peripheral selection in microcontroller systems and display drivers for multiplexed displays.
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <div class="interactive-element mt-4">
                                <h5>Interactive Learning Activities</h5>
                                <div class="alert alert-info">
                                    <p>To reinforce these concepts, consider these exercises:</p>
                                    <ol>
                                        <li>Design an 8-bit adder using full adders and calculate its worst-case propagation delay</li>
                                        <li>Implement a 4:1 MUX using only 2:1 MUXes</li>
                                        <li>Show how a DEMUX can function as a decoder</li>
                                        <li>Compare the transistor count for different MUX implementations</li>
                                        <li>Design a carry-lookahead adder block diagram</li>
                                    </ol>
                                </div>
                                <div class="row">
                                    <div class="col-md-6">
                                        <div class="card">
                                            <div class="card-header bg-info text-white">Real-world Applications</div>
                                            <div class="card-body">
                                                <ul>
                                                    <li><strong>Adders:</strong> Used in ALUs, address calculation, and performance counters</li>
                                                    <li><strong>MUXes:</strong> Register file read ports, instruction selection, cache way selection</li>
                                                    <li><strong>DEMUXes:</strong> Memory bank selection, peripheral addressing, instruction decoding</li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="card">
                                            <div class="card-header bg-info text-white">Performance Considerations</div>
                                            <div class="card-body">
                                                <ul>
                                                    <li>Adders: Tradeoffs between speed (carry-lookahead) and area (ripple carry)</li>
                                                    <li>MUXes: Transmission gates vs. logic gate implementations</li>
                                                    <li>DEMUXes: Decoder-based vs. tree-structured designs</li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation mt-3">
                            <button class="btn btn-secondary" onclick="navigateToSlide('1.5')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('1.7')">Next</button>
                        </div>
                    </div>
                    <div class="slide" id="slide-1.7">
                        <h2 class="slide-title">Sequential Circuits</h2>
                        <div class="slide-content">
                            <h4>Memory Elements in Digital Design</h4>
                            <p>Unlike combinational circuits, sequential circuits have memory - their outputs depend on both current inputs and previous states. This enables the creation of finite state machines, registers, and memory systems that form the backbone of modern computing.</p>
                    
                            <div class="info-bo">
                                <h5>Modern Applications</h5>
                                <div class="row">
                                    <div class="col-md-6">
                                        <ul>
                                            <li><strong>CPU Registers</strong> in Apple M1/M2 chips (over 300 registers per core)</li>
                                            <li><strong>DDR5 RAM</strong> timing control (precharge, activate, refresh cycles)</li>
                                        </ul>
                                    </div>
                                    <div class="col-md-6">
                                        <ul>
                                            <li><strong>SSD Controllers</strong> (wear leveling, garbage collection state machines)</li>
                                            <li><strong>USB Protocol</strong> sequencing (packet framing, error recovery)</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                    
                            <div class="row mt-3">
                                <div class="col-md-6">
                                    <div class="card mb-3">
                                        <div class="card-header bg-primary text-white">
                                            Key Characteristics
                                        </div>
                                        <div class="card-body">
                                            <ul>
                                                <li><strong>Clock Signal:</strong> Synchronizes operations with precise timing (GHz in modern CPUs)</li>
                                                <li><strong>State Elements:</strong> Stores circuit history (typically D flip-flops)</li>
                                                <li><strong>Feedback Paths:</strong> Output affects future behavior (enables state machines)</li>
                                                <li><strong>Memory:</strong> Retains information between clock cycles (nanoseconds to years)</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="card mb-3">
                                        <div class="card-header bg-primary text-white">
                                            Basic Building Blocks
                                        </div>
                                        <div class="card-body">
                                            <div class="text-center">
                                                <svg width="100%" height="120" viewBox="0 0 300 120">
                                                    <!-- Latch -->
                                                    <rect x="10" y="20" width="60" height="30" fill="none" stroke="black"/>
                                                    <text x="40" y="40" font-size="12">Latch</text>
                                                    <line x1="0" y1="35" x2="10" y2="35" stroke="black"/>
                                                    <line x1="70" y1="35" x2="80" y2="35" stroke="black"/>
                                                    
                                                    <!-- Flip-flop -->
                                                    <rect x="100" y="20" width="60" height="30" fill="none" stroke="black"/>
                                                    <text x="130" y="40" font-size="12">FF</text>
                                                    <line x1="90" y1="35" x2="100" y2="35" stroke="black"/>
                                                    <line x1="160" y1="35" x2="170" y2="35" stroke="black"/>
                                                    <line x1="130" y1="10" x2="130" y2="20" stroke="black"/>
                                                    <text x="125" y="5" font-size="10">CLK</text>
                                                    
                                                    <!-- Register -->
                                                    <rect x="190" y="20" width="80" height="30" fill="none" stroke="black"/>
                                                    <text x="230" y="40" font-size="12">Register</text>
                                                    <line x1="180" y1="35" x2="190" y2="35" stroke="black"/>
                                                    <line x1="270" y1="35" x2="280" y2="35" stroke="black"/>
                                                    <line x1="230" y1="10" x2="230" y2="20" stroke="black"/>
                                                    
                                                    <!-- Counter -->
                                                    <rect x="100" y="70" width="80" height="30" fill="none" stroke="black"/>
                                                    <text x="140" y="90" font-size="12">Counter</text>
                                                    <line x1="90" y1="85" x2="100" y2="85" stroke="black"/>
                                                    <line x1="180" y1="85" x2="190" y2="85" stroke="black"/>
                                                    <line x1="140" y1="60" x2="140" y2="70" stroke="black"/>
                                                </svg>
                                            </div>
                                            <ul class="mt-2">
                                                <li><strong>Latches:</strong> Level-sensitive memory (transparent when enabled)</li>
                                                <li><strong>Flip-Flops:</strong> Edge-triggered storage (changes on clock edge)</li>
                                                <li><strong>Registers:</strong> Multiple flip-flops (32/64-bit in processors)</li>
                                                <li><strong>Counters:</strong> State machines with cyclic patterns</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <h4 class="mt-4">State Diagram Example: 3-State Controller</h4>
                            <div class="text-center">
                                <svg width="400" height="250" viewBox="0 0 400 250">
                                    <!-- States -->
                                    <circle cx="100" cy="100" r="30" fill="white" stroke="blue" stroke-width="2"/>
                                    <text x="100" y="105" text-anchor="middle" font-size="14">Idle</text>
                                    
                                    <circle cx="200" cy="100" r="30" fill="white" stroke="blue" stroke-width="2"/>
                                    <text x="200" y="105" text-anchor="middle" font-size="14">Active</text>
                                    
                                    <circle cx="300" cy="100" r="30" fill="white" stroke="blue" stroke-width="2"/>
                                    <text x="300" y="105" text-anchor="middle" font-size="14">Done</text>
                                    
                                    <!-- Transitions -->
                                    <path d="M85,70 Q150,40 215,70" fill="none" stroke="black" marker-end="url(#arrowhead)"/>
                                    <text x="150" y="50" font-size="12">start</text>
                                    
                                    <path d="M230,100 L270,100" fill="none" stroke="black" marker-end="url(#arrowhead)"/>
                                    <text x="250" y="90" font-size="12">complete</text>
                                    
                                    <path d="M300,130 Q250,180 100,130" fill="none" stroke="black" marker-end="url(#arrowhead)"/>
                                    <text x="200" y="170" font-size="12">reset</text>
                                    
                                    <path d="M130,100 L170,100" fill="none" stroke="black" marker-end="url(#arrowhead)"/>
                                    <text x="150" y="90" font-size="12">data_rdy</text>
                                    
                                    <!-- Self transitions -->
                                    <path d="M100,130 Q70,150 70,100 Q70,50 100,70" fill="none" stroke="black" marker-end="url(#arrowhead)"/>
                                    <text x="50" y="100" font-size="12">timeout</text>
                                    
                                    <defs>
                                        <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                                            <polygon points="0 0, 10 3.5, 0 7" fill="black"/>
                                        </marker>
                                    </defs>
                                </svg>
                            </div>
                            <div class="alert alert-info mt-2">
                                <p><strong>State Machine Operation:</strong> This represents a simple controller with idle, active, and done states. State transitions occur on clock edges when conditions are met (start, complete, reset). Modern processors contain thousands of such state machines for pipeline control, cache management, and power sequencing.</p>
                            </div>
                    
                            <div class="interactive-element mt-4">
                                <h5>Sequential Circuit Simulator</h5>
                                <div class="row">
                                    <div class="col-md-6">
                                        <div class="card">
                                            <div class="card-body">
                                                <div class="form-group">
                                                    <label><strong>Clock Signal:</strong></label>
                                                    <div class="btn-group w-100" role="group">
                                                        <button type="button" class="btn btn-outline-primary active">Low (0)</button>
                                                        <button type="button" class="btn btn-outline-primary">High (1)</button>
                                                        <button type="button" class="btn btn-success">Pulse</button>
                                                    </div>
                                                </div>
                                                <div class="form-group mt-2">
                                                    <label><strong>Inputs:</strong></label>
                                                    <div class="btn-group w-100" role="group">
                                                        <button type="button" class="btn btn-outline-secondary">D=0</button>
                                                        <button type="button" class="btn btn-outline-secondary">D=1</button>
                                                    </div>
                                                </div>
                                                <button class="btn btn-primary mt-2 w-100" onclick="simulateSequential()">Step Circuit</button>
                                                <button class="btn btn-warning mt-2 w-100" onclick="resetSequential()">Reset</button>
                                            </div>
                                        </div>
                                    </div>
                                    <div class="col-md-6">
                                        <div class="card h-100">
                                            <div class="card-body" id="sequentialOutput">
                                                <h5 class="text-center">Circuit State</h5>
                                                <div class="text-center">
                                                    <svg width="100%" height="120" viewBox="0 0 200 120">
                                                        <rect x="20" y="20" width="160" height="80" fill="#f8f9fa" stroke="#6c757d"/>
                                                        <circle cx="50" cy="60" r="15" fill="white" stroke="#007bff" stroke-width="2"/>
                                                        <text x="50" y="65" text-anchor="middle" font-size="12">D</text>
                                                        <line x1="65" y1="60" x2="85" y2="60" stroke="black"/>
                                                        <rect x="85" y="40" width="40" height="40" fill="white" stroke="#28a745"/>
                                                        <text x="105" y="65" text-anchor="middle" font-size="12">FF</text>
                                                        <line x1="125" y1="60" x2="145" y2="60" stroke="black"/>
                                                        <circle cx="145" cy="60" r="15" fill="white" stroke="#dc3545" stroke-width="2"/>
                                                        <text x="145" y="65" text-anchor="middle" font-size="12">Q</text>
                                                        <line x1="105" y1="20" x2="105" y2="40" stroke="black"/>
                                                        <text x="105" y="15" text-anchor="middle" font-size="10">CLK</text>
                                                    </svg>
                                                </div>
                                                <div class="text-center mt-2">
                                                    <p><strong>Current State:</strong> <span id="currentState">Q=0</span></p>
                                                    <p><strong>Next State:</strong> <span id="nextState">D=0</span></p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('1.6')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('1.8')">Next</button>
                        </div>
                    </div>

                    <div class="slide" id="slide-1.8">
                        <h2 class="slide-title">Flip-Flops (SR, JK & D)</h2>
                        <div class="slide-content">
                          <h4>Edge-Triggered Memory Elements</h4>
                          <p>Flip-flops are fundamental sequential logic elements used to store binary data. They capture and hold a single bit of information based on a triggering clock edge (rising or falling). Unlike combinational circuits, flip-flops maintain state across clock cycles, making them essential for memory, control, and timing applications. 
                            A flip-flop state repeatedly changes at an active state of the clock pulses. They remain unaffected even when the clock pulse does not stay active. The clocked flip-flops particularly act as the memory elements of the synchronous sequential circuit- while the un-clocked ones (latches) function as the memory elements of asynchronous sequential circuits (latches are level-triggered, changing state continuously while the input signal is active).
                          </p>
                      
                          <div class="info-box">
                            <h5>Modern Usage Example: Apple M1 Pro Chip</h5>
                            <div class="row">
                              <div class="col-md-6">
                                <ul>
                                  <li><strong>Register Files:</strong> Hundreds of physical registers per core used for renaming and instruction execution</li>
                                  <li><strong>Pipeline Latches:</strong> Flip-flops used to isolate pipeline stages (e.g., fetch → decode)</li>
                                </ul>
                              </div>
                              <div class="col-md-6">
                                <ul>
                                  <li><strong>Clock Domain Crossing:</strong> Synchronizer flip-flops handle safe data transfer across different clock speeds</li>
                                  <li><strong>Memory Tags:</strong> Flip-flops form part of the tag arrays in caches (SRAM-style)</li>
                                </ul>
                              </div>
                            </div>
                          </div>
                      
                          <div class="row mt-4">
                            <div class="col-md-4">
                              <div class="card h-100">
                                <div class="card-header bg-primary text-white">SR Flip-Flop</div>
                                <div class="card-body">
                                  <p><strong>Set-Reset (SR) Flip-Flop:</strong> The SR flip-flop, also known as a SR Latch, can be considered as one of the most basic sequential logic circuit possible. This simple flip-flop is basically a one-bit memory bistable device that has two inputs, one which will “SET” the device (meaning the output = “1”), and is labelled S and one which will “RESET” the device (meaning the output = “0”), labelled R. On the clock edge:</p>
                                  <ul>
                                    <li><strong>S = 1, R = 0:</strong> Set output Q to 1</li>
                                    <li><strong>S = 0, R = 1:</strong> Reset output Q to 0</li>
                                    <li><strong>S = 0, R = 0:</strong> Maintain previous value (Hold)</li>
                                    <li><strong>S = 1, R = 1:</strong> Invalid state (not allowed)</li>
                                  </ul>
                                  <div class="alert alert-warning mt-3">
                                    <strong>Design Note:</strong> Due to its undefined behavior for S=R=1, SR flip-flops are mostly avoided in modern designs and replaced with safer alternatives like D flip-flops.
                                  </div>
                                </div>
                              </div>
                            </div>
                            <div class="col-md-4">
                              <div class="card h-100">
                                <div class="card-header bg-primary text-white">JK Flip-Flop</div>
                                <div class="card-body">
                                  <p><strong>JK Flip-Flop:</strong> A refinement of the SR flip-flop. The JK flip flop is basically a gated SR flip-flop with the addition of a clock input circuitry that prevents the illegal or invalid output condition that can occur when both inputs S and R are equal to logic level “1”. Due to this additional clocked input, a JK flip-flop has four possible input combinations, “logic 1”, “logic 0”, “no change” and “toggle”:</p>
                                  <ul>
                                    <li><strong>J = 1, K = 0:</strong> Set Q = 1</li>
                                    <li><strong>J = 0, K = 1:</strong> Reset Q = 0</li>
                                    <li><strong>J = 0, K = 0:</strong> Hold previous state</li>
                                    <li><strong>J = 1, K = 1:</strong> Toggle output (Q = Q')</li>
                                  </ul>
                                  <div class="alert alert-info mt-3">
                                    <strong>Usage:</strong> Suitable for counters and toggle logic. Less used in modern high-speed designs due to complex timing analysis.
                                  </div>
                                </div>
                              </div>
                            </div>
                            <div class="col-md-4">
                              <div class="card h-100">
                                <div class="card-header bg-primary text-white">D Flip-Flop</div>
                                <div class="card-body">
                                  <p><strong>Data (D) Flip-Flop:</strong> The most commonly used flip-flop in digital systems. It captures the input value (D) on a clock edge and stores it until the next clock event.</p>
                                  <ul>
                                    <li><strong>CLK ↑, D = 1:</strong> Q = 1</li>
                                    <li><strong>CLK ↑, D = 0:</strong> Q = 0</li>
                                    <li><strong>CLK ↓ or No edge:</strong> Q holds previous state</li>
                                  </ul>
                                  <p><strong>Timing Parameters:</strong></p>
                                  <ul class="small">
                                    <li><strong>Setup time (t<sub>su</sub>):</strong> Time before clock when D must be stable</li>
                                    <li><strong>Hold time (t<sub>h</sub>):</strong> Time after clock when D must remain stable</li>
                                    <li><strong>Clock-to-Q delay (t<sub>cq</sub>):</strong> Time from clock edge to output change</li>
                                  </ul>
                                  <div class="alert alert-success mt-3">
                                    <strong>Dominant Design:</strong> Over 95% of flip-flops in CPUs, GPUs, and memory systems are D flip-flops due to their simplicity and reliability.
                                  </div>
                                </div>
                              </div>
                            </div>
                          </div>
                      
                          <div class="row mt-4">
                            <div class="col-md-12">
                              <div class="card">
                                <div class="card-header bg-info text-white">Additional Flip-Flop Types</div>
                                <div class="card-body">
                                  <ul>
                                    <li><strong>T Flip-Flop (Toggle):</strong> Toggles its output state on every clock edge when T=1. Often derived from JK flip-flop (with J=K=1). Useful in binary counters.</li>
                                    <li><strong>Master-Slave Flip-Flop:</strong> A two-stage structure combining two flip-flops to eliminate race conditions. Common in older sequential logic designs but less used in modern edge-triggered designs.</li>
                                    <li><strong>Edge-triggered Latches:</strong> While latches are level-sensitive, edge-triggered latches behave like flip-flops but with simpler internal logic. Mostly used in asynchronous logic designs.</li>
                                  </ul>
                                  <p class="text-muted mt-2"><strong>Note:</strong> While D, JK, and T flip-flops are edge-triggered, latches are level-triggered and may cause glitches if not carefully controlled.</p>
                                </div>
                              </div>
                            </div>
                          </div>
                      
                          <div class="alert alert-secondary mt-4">
                            <h5>Summary</h5>
                            <ul>
                              <li><strong>SR Flip-Flop:</strong> Basic design, rarely used due to invalid states.</li>
                              <li><strong>JK Flip-Flop:</strong> Versatile and toggle-friendly, mostly used in counters.</li>
                              <li><strong>D Flip-Flop:</strong> Most widely used; ideal for registers, pipelines, and memory.</li>
                              <li><strong>Other Types:</strong> T flip-flops for toggling; master-slave for controlled sequencing.</li>
                            </ul>
                          </div>
                        </div>
                        <div class="navigation">
                          <button class="btn btn-secondary" onclick="navigateToSlide('1.7')">Previous</button>
                          <button class="btn btn-primary" onclick="navigateToSlide('1.9')">Next</button>
                        </div>
                    </div>
                      
                    <div class="slide" id="slide-1.9">
                        <h2 class="slide-title">Counters</h2>
                        <div class="slide-content">
                            <h4>Types of Counters</h4>
                            <p>Counters are sequential circuits that count pulses and are fundamental components in digital systems. They can be classified based on their triggering mechanism (synchronous/asynchronous), counting sequence (up/down), and modulus (binary/decade).</p>
                    
                            <div class="info-box">
                                <h5>Modern Usage Example: M1 Pro Chip</h5>
                                <div class="row">
                                    <div class="col-md-6">
                                        <ul>
                                            <li><strong>Performance Counters:</strong> 30+ dedicated counters per core monitoring cache hits/misses, branch prediction accuracy, and pipeline stalls</li>
                                            <li><strong>Debugging:</strong> Hardware performance monitors with 64-bit precision counters</li>
                                            <li><strong>Power Management:</strong> Dynamic voltage/frequency scaling based on activity counters</li>
                                        </ul>
                                    </div>
                                    <div class="col-md-6">
                                        <ul>
                                            <li><strong>Clock Dividers:</strong> Generate derived clocks (1/N frequencies) for peripheral controllers</li>
                                            <li><strong>Frequency Synthesis:</strong> Digital PLLs using counters for fractional-N synthesis</li>
                                            <li><strong>Memory Refresh:</strong> Counters for DRAM refresh timing (32ms/64ms intervals)</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                    
                            <div class="row mt-3">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Synchronous Counter</div>
                                        <div class="card-body">
                                            <p><strong>Definition:</strong> A synchronous counter is a type of counter in which all flip-flops are triggered simultaneously by a common clock signal, ensuring coordinated and simultaneous state transitions.</p>
                                            <h5>Key Characteristics</h5>
                                            <ul>
                                                <li><strong>Clock:</strong> All flip-flops share the same clock signal</li>
                                                <li><strong>Timing:</strong> Simultaneous state transitions (no ripple delay)</li>
                                                <li><strong>Speed:</strong> Higher maximum operating frequency</li>
                                                <li><strong>Complexity:</strong> Requires more logic gates for next-state generation</li>
                                            </ul>
                                            
                                            <h5 class="mt-3">Advantages</h5>
                                            <ul>
                                                <li>Predictable timing behavior</li>
                                                <li>No glitches in output waveforms</li>
                                                <li>Easier to implement complex counting sequences</li>
                                                <li>Better suited for high-speed applications</li>
                                            </ul>
                                            
                                            <div class="alert alert-success mt-3 p-2">
                                                <strong>Modern Usage:</strong> Virtually all counters in CPU cores (program counters, performance monitors) are synchronous due to timing predictability.
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Asynchronous Counter</div>
                                        <div class="card-body">
                                            <p><strong>Definition:</strong> An asynchronous counter, also known as a ripple counter, is a type of counter in which each flip-flop is triggered by the output of the preceding flip-flop rather than a common clock, resulting in sequential (rippled) state changes.</p>
                                            <h5>Key Characteristics</h5>
                                            <ul>
                                                <li><strong>Clock:</strong> Each flip-flop triggered by previous stage's output</li>
                                                <li><strong>Timing:</strong> Propagation delay accumulates (ripple effect)</li>
                                                <li><strong>Speed:</strong> Limited by total propagation delay</li>
                                                <li><strong>Complexity:</strong> Simpler logic implementation</li>
                                            </ul>
                                            
                                            <h5 class="mt-3">Advantages</h5>
                                            <ul>
                                                <li>Lower power consumption (clock load reduced)</li>
                                                <li>Simpler design with fewer components</li>
                                                <li>Natural frequency division properties</li>
                                                <li>Useful for non-critical timing applications</li>
                                            </ul>
                                            
                                            <div class="alert alert-warning mt-3 p-2">
                                                <strong>Modern Usage:</strong> Primarily used in low-speed applications like clock dividers for peripherals or as prescalers in frequency synthesizers.
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <div class="row mt-3">
                                <div class="col-md-4">
                                    <div class="card h-100">
                                        <div class="card-header">Binary Counters</div>
                                        <div class="card-body">
                                            <p>Count through all possible binary combinations (2<sup>n</sup> states)</p>
                                            <ul>
                                                <li>4-bit: 0-15 (modulus-16)</li>
                                                <li>8-bit: 0-255 (modulus-256)</li>
                                                <li>Used in address generation and program counters</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="card h-100">
                                        <div class="card-header">Decade Counters</div>
                                        <div class="card-body">
                                            <p>Count through 10 states (0-9) then reset</p>
                                            <ul>
                                                <li>BCD (Binary Coded Decimal) output</li>
                                                <li>Used in digital clocks and displays</li>
                                                <li>Often implemented as synchronous counters</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="card h-100">
                                        <div class="card-header">Ring Counters</div>
                                        <div class="card-body">
                                            <p>Circulate a single '1' through flip-flops</p>
                                            <ul>
                                                <li>Used in control sequencing</li>
                                                <li>Self-decoding outputs</li>
                                                <li>Example: 1000 → 0100 → 0010 → 0001</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <div class="row mt-3">
                                <div class="col-md-6">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Counter Design Considerations</div>
                                        <div class="card-body">
                                            <ul>
                                                <li><strong>Counting Speed:</strong> Synchronous counters can operate at higher frequencies</li>
                                                <li><strong>Power Consumption:</strong> Asynchronous counters generally consume less power</li>
                                                <li><strong>Glitches:</strong> Asynchronous counters may produce transient states</li>
                                                <li><strong>Reset Logic:</strong> Synchronous vs. asynchronous reset implementations</li>
                                                <li><strong>Testability:</strong> Scan chains for manufacturing test</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-6">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Advanced Counter Features</div>
                                        <div class="card-body">
                                            <ul>
                                                <li><strong>Programmable Modulus:</strong> Configurable count limits</li>
                                                <li><strong>Bidirectional:</strong> Up/down counting capability</li>
                                                <li><strong>Parallel Load:</strong> Preset initial count value</li>
                                                <li><strong>Carry Lookahead:</strong> Faster terminal count detection</li>
                                                <li><strong>Gray Code:</strong> Single-bit changes between states</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <div class="alert alert-success mt-3">
                                <h5>Example: 4-bit Binary Counter Operation</h5>
                                <p>A 4-bit binary counter progresses through the sequence 0000, 0001, 0010, ..., 1111 (0-15 in decimal). Each clock pulse increments the count by 1. In modern processors:</p>
                                <ul>
                                    <li>Program counters are typically 32-bit or 64-bit versions</li>
                                    <li>Counters use synchronous design for precise timing</li>
                                    <li>Often include parallel load capability for branching</li>
                                    <li>May have increment-by-N capability for instruction prefetch</li>
                                </ul>
                            </div>
                    
                            <div class="alert alert-warning mt-2">
                                <p><strong>Design Note:</strong> Synchronous counters dominate modern IC designs (95%+ usage) due to their predictable timing characteristics. Asynchronous counters are reserved for non-critical applications where power savings outweigh performance requirements.</p>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('1.8')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('2.1')">Next</button>
                        </div>

                    </div>
                    
                    <!-- Slide 2.1: Introduction to Computer Architecture -->
                    <div class="slide" id="slide-2.1">
                        <h2 class="slide-title">Computer Organization vs Architecture</h2>
                        <div class="slide-content">
                          <h4>Understanding the Distinction</h4>
                          <p>Though often used interchangeably, <strong>computer architecture</strong> and <strong>computer organization</strong> refer to different aspects of computing systems. Grasping their differences is essential for system designers, computer engineers, and hardware developers.</p>
                      
                          <div class="row mt-3">
                            <div class="col-md-6">
                              <div class="card h-100">
                                <div class="card-header bg-primary text-white">Computer Architecture</div>
                                <div class="card-body">
                                  <p><strong>Definition:</strong> The conceptual design and fundamental operational structure of a computer system as seen by a programmer.</p>
                                  <ul>
                                    <li>Instruction Set Architecture (ISA)</li>
                                    <li>Registers, memory addressing modes</li>
                                    <li>Instruction formats, data types</li>
                                    <li>Supported operations (e.g., ALU instructions, I/O)</li>
                                  </ul>
                                  <div class="alert alert-info mt-3">
                                    <strong>Think of it as:</strong> What the CPU does and how it is programmed.
                                  </div>
                                  <p class="mt-2"><strong>Examples:</strong></p>
                                  <ul>
                                    <li>x86-64, ARMv8, RISC-V ISAs</li>
                                    <li>How instructions like ADD, SUB, LOAD, STORE behave</li>
                                  </ul>
                                </div>
                              </div>
                            </div>
                      
                            <div class="col-md-6">
                              <div class="card h-100">
                                <div class="card-header bg-dark text-white">Computer Organization</div>
                                <div class="card-body">
                                  <p><strong>Definition:</strong> The physical realization of a computer system, describing how features specified by the architecture are implemented in hardware.</p>
                                  <ul>
                                    <li>Control signals, buses, and clocking</li>
                                    <li>ALU design, data path width</li>
                                    <li>Pipelining, caching, memory hierarchy</li>
                                    <li>Branch prediction, speculative execution</li>
                                  </ul>
                                  <div class="alert alert-warning mt-3">
                                    <strong>Think of it as:</strong> How the CPU is built to do what it does.
                                  </div>
                                  <p class="mt-2"><strong>Examples:</strong></p>
                                  <ul>
                                    <li>5-stage pipeline in RISC processors</li>
                                    <li>Superscalar execution units in Intel Core series</li>
                                    <li>Cache coherence protocols</li>
                                  </ul>
                                </div>
                              </div>
                            </div>
                          </div>
                      
                          <div class="alert alert-success mt-4">
                            <h5>Real-World Application: Apple M-Series</h5>
                            <ul>
                              <li><strong>Architecture:</strong> ARMv8-A (ISA), defines how code is written and executed</li>
                              <li><strong>Organization:</strong> Custom high-performance cores (Firestorm/Icestorm), memory subsystems, multi-core fabric</li>
                            </ul>
                            <p class="mb-0">The M1/M2 chips adhere to the ARM ISA (architecture), but Apple implements them with proprietary microarchitecture and organization tailored for performance and efficiency.</p>
                          </div>
                      
                          <div class="alert alert-secondary mt-3">
                            <strong>Summary:</strong> 
                            <ul class="mb-0">
                              <li><strong>Architecture</strong> = What a system does (visible to software)</li>
                              <li><strong>Organization</strong> = How the system is built (invisible to most software)</li>
                            </ul>
                          </div>
                        </div>
                        <div class="navigation">
                          <button class="btn btn-secondary" onclick="navigateToSlide('1.9')">Previous</button>
                          <button class="btn btn-primary" onclick="navigateToSlide('2.2')">Next</button>
                        </div>
                    </div>
                      


                    <div class="slide" id="slide-2.2">
                        <h2 class="slide-title">Computer Components and Functions</h2>
                        <div class="slide-content">
                          <h4>Fundamental Building Blocks of a Computer System</h4>
                          <p>Every computer system consists of a set of core components, each responsible for specific tasks — from processing data to storing information, handling input/output, and controlling system operations. These components interact to execute programs and manage system resources efficiently.</p>
                      
                          <div class="row mt-3">
                            <!-- CPU -->
                            <div class="col-md-6">
                              <div class="card h-100">
                                <div class="card-header bg-primary text-white">1. Central Processing Unit (CPU)</div>
                                <div class="card-body">
                                  <p><strong>Function:</strong> Executes instructions, processes data, and controls overall system behavior.</p>
                                  <ul>
                                    <li><strong>ALU (Arithmetic Logic Unit):</strong> Performs arithmetic and logic operations</li>
                                    <li><strong>Control Unit:</strong> Directs operation of processor</li>
                                    <li><strong>Registers:</strong> Small, fast storage for immediate data</li>
                                  </ul>
                                  <p><strong>Examples:</strong></p>
                                  <ul>
                                    <li>Apple M3 CPU cores (Icestorm & Firestorm)</li>
                                    <li>Intel Core i9, AMD Ryzen CPUs</li>
                                    <li>RISC-V Open-source cores</li>
                                  </ul>
                                </div>
                              </div>
                            </div>
                      
                            <!-- Memory -->
                            <div class="col-md-6">
                              <div class="card h-100">
                                <div class="card-header bg-success text-white">2. Memory (Primary & Secondary)</div>
                                <div class="card-body">
                                  <p><strong>Function:</strong> Stores data and instructions for execution, both temporarily and permanently.</p>
                                  <ul>
                                    <li><strong>RAM:</strong> Volatile memory for active programs</li>
                                    <li><strong>ROM:</strong> Non-volatile memory for firmware</li>
                                    <li><strong>Cache:</strong> High-speed buffer between CPU and RAM</li>
                                    <li><strong>Storage Devices:</strong> HDDs, SSDs, NVMe for long-term data storage</li>
                                  </ul>
                                  <p><strong>Examples:</strong></p>
                                  <ul>
                                    <li>DDR5 SDRAM in gaming PCs</li>
                                    <li>NVMe Gen4 SSDs in laptops</li>
                                    <li>Apple's Unified Memory Architecture (UMA)</li>
                                  </ul>
                                </div>
                              </div>
                            </div>
                          </div>
                      
                          <div class="row mt-3">
                            <!-- Input/Output -->
                            <div class="col-md-6">
                              <div class="card h-100">
                                <div class="card-header bg-dark text-white">3. Input/Output Devices (I/O)</div>
                                <div class="card-body">
                                  <p><strong>Function:</strong> Facilitate interaction between the user and the computer system, and allow data exchange with external systems.</p>
                                  <ul>
                                    <li><strong>Input:</strong> Keyboard, Mouse, Touchscreen, Microphone</li>
                                    <li><strong>Output:</strong> Monitor, Speaker, Printer, VR Headsets</li>
                                    <li><strong>I/O Interfaces:</strong> USB, HDMI, Thunderbolt, PCIe</li>
                                  </ul>
                                  <p><strong>Examples:</strong></p>
                                  <ul>
                                    <li>Game controllers in consoles</li>
                                    <li>Webcams with AI preprocessing (MacBook Pro)</li>
                                    <li>VR tracking systems with I/O accelerators</li>
                                  </ul>
                                </div>
                              </div>
                            </div>
                      
                            <!-- System Bus -->
                            <div class="col-md-6">
                              <div class="card h-100">
                                <div class="card-header bg-info text-white">4. System Bus & Communication</div>
                                <div class="card-body">
                                  <p><strong>Function:</strong> Facilitates data transfer between components (CPU, memory, I/O).</p>
                                  <ul>
                                    <li><strong>Data Bus:</strong> Carries actual data</li>
                                    <li><strong>Address Bus:</strong> Carries memory addresses</li>
                                    <li><strong>Control Bus:</strong> Carries control signals</li>
                                  </ul>
                                  <p><strong>Examples:</strong></p>
                                  <ul>
                                    <li>Front-Side Bus in older Intel CPUs</li>
                                    <li>Infinity Fabric (AMD Ryzen)</li>
                                    <li>Apple T2 secure coprocessor interface</li>
                                  </ul>
                                </div>
                              </div>
                            </div>
                          </div>
                      
                          <div class="row mt-3">
                            <!-- Other Components -->
                            <div class="col-md-12">
                              <div class="card">
                                <div class="card-header bg-secondary text-white">5. Other Critical Components</div>
                                <div class="card-body">
                                  <div class="row">
                                    <div class="col-md-6">
                                      <ul>
                                        <li><strong>GPU (Graphics Processing Unit):</strong> Specialized for parallel image/video rendering</li>
                                        <li><strong>TPU (Tensor Processing Unit):</strong> Optimized for machine learning tasks</li>
                                        <li><strong>NIC (Network Interface Card):</strong> Enables wired/wireless network access</li>
                                      </ul>
                                    </div>
                                    <div class="col-md-6">
                                      <ul>
                                        <li><strong>Power Supply Unit (PSU):</strong> Converts AC to regulated DC power</li>
                                        <li><strong>Clock Generator:</strong> Provides timing signals (e.g., crystal oscillator)</li>
                                        <li><strong>Embedded Controllers:</strong> Manage peripherals, power states, thermal limits</li>
                                      </ul>
                                    </div>
                                  </div>
                                  <p class="mt-3"><strong>Example Use Case:</strong> A modern laptop includes CPU + integrated GPU (SoC), LPDDR5 RAM, SSD, Wi-Fi 6E module, Thunderbolt 4 ports, and power management ICs — all tightly integrated for performance and energy efficiency.</p>
                                </div>
                              </div>
                            </div>
                          </div>
                      
                          <div class="alert alert-success mt-4">
                            <h5>Key Insight:</h5>
                            <p>All components must work in harmony. Bottlenecks in memory speed, limited I/O bandwidth, or power inefficiency in components like GPUs can severely affect system performance.</p>
                          </div>
                      
                          <div class="alert alert-warning mt-3">
                            <strong>Design Consideration:</strong> In embedded systems and smartphones, many components are integrated on a single chip (SoC), enabling compact, low-power, high-performance designs.
                          </div>
                        </div>
                      
                        <div class="navigation">
                          <button class="btn btn-secondary" onclick="navigateToSlide('2.1')">Previous</button>
                          <button class="btn btn-primary" onclick="navigateToSlide('2.3')">Next</button>
                        </div>
                    </div>
                      

                    <!-- Slide 2.3: Interconnection Structures -->
                    <div class="slide" id="slide-2.3">
                        <h2 class="slide-title">Interconnection Structures</h2>
                        <div class="slide-content">
                          <h4>Connecting Components in a Computer System</h4>
                          <p>Interconnection structures define how major subsystems — the CPU, memory, and I/O devices — communicate and coordinate. These connections directly impact data transfer rates, latency, and system scalability.</p>
                      
                          <div class="row mt-3">
                            <!-- Bus-Based -->
                            <div class="col-md-6">
                              <div class="card h-100">
                                <div class="card-header bg-primary text-white">1. Bus-Based Interconnect</div>
                                <div class="card-body">
                                  <p><strong>Description:</strong> All components share a single communication pathway (bus). Uses control logic to manage access.</p>
                                  <ul>
                                    <li>Simple and cost-effective</li>
                                    <li>Only one component transmits at a time</li>
                                    <li>Shared bandwidth and potential bottlenecks</li>
                                  </ul>
                                  <p><strong>Examples:</strong></p>
                                  <ul>
                                    <li>Older desktop systems (single front-side bus)</li>
                                    <li>Microcontrollers using SPI/I<sup>2</sup>C buses</li>
                                    <li>Classic PCI/IDE systems</li>
                                  </ul>
                                  <div class="alert alert-warning mt-2 p-2">
                                    <small><strong>Limitation:</strong> Not scalable for multi-core or high-speed systems.</small>
                                  </div>
                                </div>
                              </div>
                            </div>
                      
                            <!-- Point-to-Point -->
                            <div class="col-md-6">
                              <div class="card h-100">
                                <div class="card-header bg-success text-white">2. Point-to-Point Interconnect</div>
                                <div class="card-body">
                                  <p><strong>Description:</strong> Dedicated communication lines between components. Eliminates bus contention and increases bandwidth.</p>
                                  <ul>
                                    <li>Highly scalable for multi-core architectures</li>
                                    <li>Low latency and high throughput</li>
                                    <li>More complex routing and control</li>
                                  </ul>
                                  <p><strong>Examples:</strong></p>
                                  <ul>
                                    <li>Intel QPI (QuickPath Interconnect)</li>
                                    <li>AMD Infinity Fabric</li>
                                    <li>PCI Express (PCIe) lanes</li>
                                  </ul>
                                  <div class="alert alert-success mt-2 p-2">
                                    <small><strong>Advantage:</strong> Ideal for modern high-performance computing and SoCs.</small>
                                  </div>
                                </div>
                              </div>
                            </div>
                          </div>
                      
                          <div class="row mt-3">
                            <!-- Crossbar Switch -->
                            <div class="col-md-6">
                              <div class="card h-100">
                                <div class="card-header bg-dark text-white">3. Crossbar Switch</div>
                                <div class="card-body">
                                  <p><strong>Description:</strong> A crossbar switch is a interconnection network where each input can be directly connected to any output, offering a non-blocking communication path./p>
                                  <ul>
                                    <li>Supports parallel memory accesses</li>
                                    <li>High performance but costly and complex</li>
                                    <li>Often used in multicore and GPU memory systems</li>
                                  </ul>
                                  <p><strong>Examples:</strong></p>
                                  <ul>
                                    <li>High-end routers and switches</li>
                                    <li>GPU memory access architectures (e.g., NVIDIA NVLink)</li>
                                  </ul>
                                  <div class="alert alert-info mt-2 p-2">
                                    <small><strong>Note:</strong> Crossbars are often limited by area and scalability beyond 8–16 nodes.</small>
                                  </div>
                                </div>
                              </div>
                            </div>
                      
                            <!-- Network-on-Chip -->
                            <div class="col-md-6">
                              <div class="card h-100">
                                <div class="card-header bg-info text-white">4. Network-on-Chip (NoC)</div>
                                <div class="card-body">
                                  <p><strong>Description:</strong> A Network-on-Chip (NoC) is a modern on-chip communication infrastructure that uses a network-based architecture, while a crossbar is an older technology that uses a matrix of wires for communication within a chip. NoCs offer advantages over crossbars in terms of scalability, bandwidth, and power efficiency, especially in complex Systems-on-Chip (SoCs). </p>
                                  <ul>
                                    <li>Mesh or torus topologies</li>
                                    <li>Built-in routers, buffers, and links</li>
                                    <li>Minimizes latency across large chips</li>
                                  </ul>
                                  <p><strong>Examples:</strong></p>
                                  <ul>
                                    <li>Apple M-series and AMD Ryzen SoCs</li>
                                    <li>Intel Tile-based architectures (e.g., Meteor Lake)</li>
                                    <li>AI accelerators and ML chips (e.g., Google's TPU)</li>
                                  </ul>
                                  <div class="alert alert-success mt-2 p-2">
                                    <small><strong>Future-Oriented:</strong> Enables modular, energy-efficient, high-bandwidth chip design.</small>
                                  </div>
                                </div>
                              </div>
                            </div>
                          </div>
                      
                          <div class="alert alert-secondary mt-4">
                            <h5>Comparison Summary</h5>
                            <table class="table table-bordered table-sm">
                              <thead class="table-light">
                                <tr>
                                  <th>Structure</th>
                                  <th>Scalability</th>
                                  <th>Performance</th>
                                  <th>Complexity</th>
                                  <th>Use Case</th>
                                </tr>
                              </thead>
                              <tbody>
                                <tr>
                                  <td>Bus</td>
                                  <td>Low</td>
                                  <td>Moderate</td>
                                  <td>Low</td>
                                  <td>Legacy systems, MCUs</td>
                                </tr>
                                <tr>
                                  <td>Point-to-Point</td>
                                  <td>High</td>
                                  <td>High</td>
                                  <td>Moderate</td>
                                  <td>Modern CPUs, GPUs</td>
                                </tr>
                                <tr>
                                  <td>Crossbar</td>
                                  <td>Moderate</td>
                                  <td>Very High</td>
                                  <td>High</td>
                                  <td>Memory controllers, switches</td>
                                </tr>
                                <tr>
                                  <td>NoC</td>
                                  <td>Very High</td>
                                  <td>High</td>
                                  <td>High</td>
                                  <td>Multicore SoCs, AI chips</td>
                                </tr>
                              </tbody>
                            </table>
                          </div>
                      
                          <div class="alert alert-warning mt-3">
                            <strong>Design Insight:</strong> Choosing the right interconnect is a trade-off between cost, performance, power, and scalability. In chip design, NoC is rapidly becoming the dominant choice due to its modular and distributed nature.
                          </div>
                        </div>
                      
                        <div class="navigation">
                          <button class="btn btn-secondary" onclick="navigateToSlide('2.2')">Previous</button>
                          <button class="btn btn-primary" onclick="navigateToSlide('2.4')">Next</button>
                        </div>
                    </div>
                      
                    <div class="slide" id="slide-2.4">
                        <h2 class="slide-title">Bus Interconnections</h2>
                        <div class="slide-content">
                            <h4>How Components Communicate Within a Computer System</h4>
                            <p>The bus is a critical pathway used to transfer data, addresses, and control signals among components. It forms the backbone of communication in most computer architectures, enabling the processor, memory, and I/O devices to exchange information efficiently. Modern systems employ sophisticated bus hierarchies to balance performance and cost.</p>
                        
                            <div class="row mt-3">
                                <!-- Bus Structure -->
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">1. Bus Structure</div>
                                        <div class="card-body">
                                            <p><strong>Description:</strong> A collection of parallel wires that carry different types of signals between subsystems. The bus architecture determines the system's maximum theoretical bandwidth and affects real-world performance.</p>
                                            <ul>
                                                <li><strong>Data Bus:</strong> Bi-directional pathways that transport actual data between components. Width determines how many bits can be transferred simultaneously (e.g., 64-bit data bus)</li>
                                                <li><strong>Address Bus:</strong> Uni-directional (typically from CPU) that carries memory locations being read or written. Width determines maximum addressable memory (e.g., 32-bit = 4GB)</li>
                                                <li><strong>Control Bus:</strong> Carries command and status signals like read/write, interrupts, bus requests, and clock synchronization</li>
                                            </ul>
                                            <div class="alert alert-secondary mt-2">
                                                <p><strong>Example:</strong> When a CPU reads from memory at address 0x1234, it places the address on the address bus, asserts the read control signal, then receives the data on the data bus after memory access time.</p>
                                            </div>
                                            <p><strong>Modern Implementation:</strong> Contemporary systems often use layered bus architectures with:</p>
                                            <ul>
                                                <li>Processor-local buses running at core clock speeds (e.g., Intel's Ring Bus)</li>
                                                <li>Memory buses optimized for DRAM access patterns</li>
                                                <li>I/O buses with packet-based protocols (PCIe)</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                        
                                <!-- Bus Timing -->
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">2. Bus Timing</div>
                                        <div class="card-body">
                                            <p><strong>Description:</strong> Defines how signals are coordinated over time to ensure data integrity. Timing methodology impacts maximum clock rate and system complexity.</p>
                                            <ul>
                                                <li><strong>Synchronous:</strong> Uses a shared clock signal for coordination. All operations occur on clock edges. Enables simpler design but limits maximum speed due to clock skew.</li>
                                                <li><strong>Asynchronous:</strong> Uses handshaking protocols (REQ/ACK signals) without a global clock. More complex but allows devices with different speeds to communicate efficiently.</li>
                                                <li><strong>Source-Synchronous:</strong> Clock travels with data (like DDR memory). Enables higher speeds by accounting for flight-time differences.</li>
                                            </ul>
                                            <div class="alert alert-secondary mt-2">
                                                <p><strong>Example:</strong> Modern CPUs use synchronous buses internally (e.g., for L1/L2 cache access) but may employ asynchronous protocols for external I/O connections where devices operate at different speeds.</p>
                                            </div>
                                            <p><strong>Timing Parameters:</strong></p>
                                            <ul>
                                                <li>Setup time: Minimum time data must be stable before clock edge</li>
                                                <li>Hold time: Minimum time data must remain stable after clock edge</li>
                                                <li>Clock-to-output delay: Time from clock edge until data appears</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="row mt-3">
                                <!-- Bus Arbitration -->
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-warning text-white">3. Bus Arbitration</div>
                                        <div class="card-body">
                                            <p><strong>Description:</strong> Mechanism that resolves which device gets access to the bus when multiple components request it simultaneously. Critical for system performance and fairness.</p>
                                            <ul>
                                                <li><strong>Centralized:</strong> A single bus controller (often part of chipset) grants access using priority schemes. Used in most consumer systems.</li>
                                                <li><strong>Distributed:</strong> Devices negotiate among themselves using protocols like token passing. Common in industrial control systems.</li>
                                                <li><strong>Priority-Based:</strong> Fixed or dynamic priorities determine access order. DMA controllers often get higher priority than regular I/O.</li>
                                                <li><strong>Time-Division:</strong> Slots are allocated in fixed time intervals. Used in real-time systems.</li>
                                            </ul>
                                            <div class="alert alert-secondary mt-2">
                                                <p><strong>Example:</strong> In a smartphone SoC, the GPU might get higher bus priority during gaming to ensure smooth frame rates, while background tasks get lower priority.</p>
                                            </div>
                                            <p><strong>Modern Approaches:</strong></p>
                                            <ul>
                                                <li>Quality-of-Service (QoS) parameters for different traffic types</li>
                                                <li>Bandwidth allocation based on application needs</li>
                                                <li>Cache-coherent protocols for multi-core systems</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                        
                                <!-- Bus Standards -->
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-dark text-white">4. Common Bus Standards</div>
                                        <div class="card-body">
                                            <p><strong>Description:</strong> Industry-standard buses provide compatibility and performance benchmarks. Modern systems use specialized buses for different purposes.</p>
                                            <ul>
                                                <li><strong>PCIe:</strong> High-speed, serial, point-to-point. Version 5.0 offers 32GT/s per lane. Uses packet-based protocol with traffic classes.</li>
                                                <li><strong>SATA:</strong> Serial ATA for storage devices. SATA III provides 6Gbps throughput with native command queuing.</li>
                                                <li><strong>USB:</strong> Universal Serial Bus supports multiple device classes. USB4 offers 40Gbps using Thunderbolt 3 technology.</li>
                                                <li><strong>AXI:</strong> ARM's Advanced eXtensible Interface used in SoCs. Supports multiple outstanding transactions and out-of-order completion.</li>
                                            </ul>
                                            <div class="alert alert-secondary mt-2">
                                                <p><strong>Example:</strong> A modern PC might use PCIe 4.0 for GPU (16 lanes = 32GB/s), PCIe 3.0 for NVMe SSD (4 lanes = 4GB/s), and USB 3.2 for peripherals.</p>
                                            </div>
                                            <p><strong>Emerging Technologies:</strong></p>
                                            <ul>
                                                <li>CXL (Compute Express Link) for cache-coherent memory expansion</li>
                                                <li>UCIe (Universal Chiplet Interconnect) for chiplet-based designs</li>
                                                <li>Optical interconnects for high-bandwidth, long-distance links</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="alert alert-info mt-4">
                                <h5>Key Insight:</h5>
                                <p>Bus performance directly affects system speed. Key metrics include:</p>
                                <ul>
                                    <li><strong>Bandwidth:</strong> Data transfer rate (e.g., GB/s)</li>
                                    <li><strong>Latency:</strong> Time from request to response</li>
                                    <li><strong>Efficiency:</strong> Useful data vs. overhead</li>
                                    <li><strong>Scalability:</strong> Ability to support more devices</li>
                                </ul>
                                <p>Modern designs use multiple specialized buses rather than a single shared bus to avoid bottlenecks. For example, Apple's M1 chip has separate buses for CPU-GPU communication, memory access, and I/O.</p>
                            </div>
                        
                            <div class="alert alert-warning mt-3">
                                <strong>Design Note:</strong> As systems scale, shared bus limitations (like contention) push designers toward:
                                <ul>
                                    <li>Point-to-point interconnects (e.g., PCIe, HyperTransport)</li>
                                    <li>Network-on-Chip (NoC) architectures for SoCs</li>
                                    <li>Layered protocols with quality-of-service guarantees</li>
                                    <li>Cache-coherent fabrics for multi-processor systems</li>
                                </ul>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('2.3')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('2.5')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 2.5: I/O Devices -->
                    
                    
                    <div class="slide" id="slide-2.5">
                        <h2 class="slide-title">I/O Modules</h2>
                        <div class="slide-content">
                            <h4>Interface Between External Devices and the Computer System</h4>
                            <p>I/O modules handle the complex translation between processor/memory and diverse peripheral devices. They serve as intelligent intermediaries that offload communication tasks from the CPU, enabling efficient system operation. Modern I/O subsystems account for significant silicon area in processors and chipsets.</p>
                        
                            <div class="row mt-3">
                                <!-- I/O Functions -->
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">1. I/O Module Functions</div>
                                        <div class="card-body">
                                            <p>I/O modules perform several critical functions that abstract device complexity from the CPU:</p>
                                            <ul>
                                                <li><strong>Control and Timing:</strong> Coordinates data transfer synchronization between the fast CPU and slower peripherals using handshaking protocols and buffer management</li>
                                                <li><strong>Data Buffering:</strong> Provides temporary storage to accommodate speed mismatches (e.g., keyboard input vs. CPU speed)</li>
                                                <li><strong>Error Handling:</strong> Implements CRC checks, parity verification, and retry mechanisms for reliable data transfer</li>
                                                <li><strong>Protocol Conversion:</strong> Translates between device-specific signaling (e.g., SATA, USB) and system bus protocols</li>
                                                <li><strong>Power Management:</strong> Handles device power states and wake-up events to conserve energy</li>
                                            </ul>
                                            <div class="alert alert-secondary mt-2">
                                                <p><strong>Example:</strong> A modern SSD controller implements wear leveling, bad block management, and NVMe protocol processing - all transparent to the CPU.</p>
                                            </div>
                                            <p><strong>Modern Features:</strong></p>
                                            <ul>
                                                <li>Scatter-gather DMA for efficient memory access</li>
                                                <li>Interrupt coalescing to reduce CPU overhead</li>
                                                <li>Hardware acceleration for encryption/compression</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                        
                                <!-- I/O Techniques -->
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">2. I/O Techniques</div>
                                        <div class="card-body">
                                            <p>Different approaches to manage I/O operations, each with tradeoffs between CPU utilization and system complexity:</p>
                                            <ul>
                                                <li><strong>Programmed I/O:</strong> CPU directly controls each data transfer (in/out instructions). Simple but inefficient - the CPU is tied up during entire transfers. Still used for simple embedded systems.</li>
                                                <li><strong>Interrupt-Driven I/O:</strong> Device interrupts CPU when ready. More efficient but can overwhelm CPU with many small devices. Common for keyboards, mice, and real-time systems.</li>
                                                <li><strong>Direct Memory Access (DMA):</strong> Specialized controller manages transfers without CPU involvement. Essential for high-bandwidth devices like storage and network interfaces.</li>
                                                <li><strong>Channel I/O:</strong> Dedicated processors handle I/O operations (mainframes, high-end servers). Provides the highest scalability.</li>
                                            </ul>
                                            <div class="alert alert-secondary mt-2">
                                                <p><strong>Example:</strong> A 4K video stream might use DMA to transfer frames directly to GPU memory, with interrupts only for major events like buffer switches.</p>
                                            </div>
                                            <p><strong>Performance Considerations:</strong></p>
                                            <ul>
                                                <li>Interrupt latency vs. throughput requirements</li>
                                                <li>Cache pollution from DMA operations</li>
                                                <li>Memory bandwidth contention</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="row mt-3">
                                <!-- I/O Addressing -->
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-dark text-white">3. Addressing & Mapping</div>
                                        <div class="card-body">
                                            <p>Methods for CPU to communicate with I/O devices, each with architectural implications:</p>
                                            <ul>
                                                <li><strong>Isolated I/O:</strong> Dedicated I/O address space and instructions (in/out). Used in x86 architecture. Provides clean separation but requires special instructions.</li>
                                                <li><strong>Memory-Mapped I/O:</strong> Devices appear as memory locations. Simplifies programming (load/store instructions) but consumes physical address space. Universal in ARM, RISC-V.</li>
                                                <li><strong>Hybrid:</strong> Some devices memory-mapped, others use ports (common in x86 PCs).</li>
                                                <li><strong>Port Addressing:</strong> Additional dimension beyond memory addresses (e.g., USB endpoints). Enables complex device hierarchies.</li>
                                            </ul>
                                            <div class="alert alert-secondary mt-2">
                                                <p><strong>Example:</strong> Apple's M1 chip uses memory-mapped I/O exclusively, with device registers mapped into the unified address space alongside DRAM.</p>
                                            </div>
                                            <p><strong>Modern Developments:</strong></p>
                                            <ul>
                                                <li>IOMMU (I/O Memory Management Unit) for device isolation and virtualization</li>
                                                <li>PCIe configuration space for dynamic device discovery</li>
                                                <li>ACPI for power management and resource allocation</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                        
                                <!-- Common I/O Devices -->
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-secondary text-white">4. Common I/O Devices</div>
                                        <div class="card-body">
                                            <p>Modern systems integrate diverse I/O devices with varying performance characteristics:</p>
                                            <ul>
                                                <li><strong>Storage:</strong> NVMe SSDs (PCIe), SATA HDDs, UFS (mobile). Latencies from microseconds (SSD) to milliseconds (HDD).</li>
                                                <li><strong>Networking:</strong> 10/100G Ethernet, Wi-Fi 6/6E, 5G modems. Throughput from Mbps to 100Gbps+.</li>
                                                <li><strong>Multimedia:</strong> Camera ISPs, GPU display controllers, audio DSPs. Real-time processing requirements.</li>
                                                <li><strong>User Input:</strong> Touchscreen controllers, haptic feedback, voice recognition. Low-latency response critical.</li>
                                                <li><strong>Sensors:</strong> Accelerometers, gyros, ambient light. Intermittent low-bandwidth data.</li>
                                            </ul>
                                            <div class="alert alert-secondary mt-2">
                                                <p><strong>Example:</strong> A smartphone SoC might integrate 50+ separate I/O controllers for various sensors, radios, and peripherals, all managed through a unified I/O fabric.</p>
                                            </div>
                                            <p><strong>Integration Trends:</strong></p>
                                            <ul>
                                                <li>Moving from discrete controllers to integrated IP blocks in SoCs</li>
                                                <li>Hardware acceleration for common I/O tasks (encryption, compression)</li>
                                                <li>Standardized interfaces like USB4 and PCIe for modularity</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        
                            <div class="alert alert-success mt-4">
                                <h5>System Insight:</h5>
                                <p>Efficient I/O design requires balancing multiple factors:</p>
                                <ul>
                                    <li><strong>Latency:</strong> Minimizing response time for interactive devices</li>
                                    <li><strong>Throughput:</strong> Maximizing data transfer rates for storage/network</li>
                                    <li><strong>CPU Overhead:</strong> Reducing interrupt load and context switches</li>
                                    <li><strong>Power Efficiency:</strong> Managing device power states appropriately</li>
                                </ul>
                                <p>Modern solutions include:</p>
                                <ul>
                                    <li>Multi-queue designs (like NVMe) for parallel access</li>
                                    <li>Interrupt moderation to reduce CPU load</li>
                                    <li>Hardware offload engines for protocol processing</li>
                                    <li>Smart buffering and prefetching strategies</li>
                                </ul>
                            </div>
                        
                            <div class="alert alert-warning mt-3">
                                <strong>Design Challenge:</strong> Contemporary systems must handle:
                                <ul>
                                    <li>Mixed workloads (real-time + throughput-sensitive)</li>
                                    <li>Security isolation between devices/processes</li>
                                    <li>Energy-efficient operation across power states</li>
                                    <li>Scalability from embedded to data center scales</li>
                                </ul>
                                <p>Emerging solutions include application-specific accelerators, cache-coherent interconnects, and hardware-software co-design.</p>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('2.4')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('2.6')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 2.6: Programmed I/O -->
                    <div class="slide" id="slide-2.6">
                        <h2 class="slide-title">Programmed I/O</h2>
                        <div class="slide-content">
                            <h4>CPU-Controlled Data Transfer Mechanism</h4>
                            <p>Programmed I/O (PIO) is the most basic I/O technique where the CPU directly manages every aspect of data transfer between memory and I/O devices. While simple to implement, it imposes significant CPU overhead and is primarily used in low-performance or legacy systems.</p>

                            <div class="row mt-3">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">1. Operation Mechanism</div>
                                        <div class="card-body">
                                            <p><strong>Data Transfer Process:</strong></p>
                                            <ol>
                                                <li>CPU executes I/O instruction (IN/OUT in x86)</li>
                                                <li>CPU waits for device readiness (status polling)</li>
                                                <li>CPU moves each data unit between device and memory</li>
                                                <li>CPU updates pointers and counters</li>
                                                <li>Process repeats until transfer completes</li>
                                            </ol>
                                            <div class="alert alert-secondary mt-2">
                                                <p><strong>Example:</strong> In early PCs, floppy disk transfers used PIO mode where the CPU would read each sector byte-by-byte through I/O ports.</p>
                                            </div>
                                            <p><strong>Technical Characteristics:</strong></p>
                                            <ul>
                                                <li>Uses dedicated I/O instructions (e.g., x86 IN/OUT)</li>
                                                <li>Requires explicit status checking (polling loops)</li>
                                                <li>CPU remains occupied throughout transfer</li>
                                                <li>Simple hardware requirements (no DMA controller needed)</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">2. Implementation Details</div>
                                        <div class="card-body">
                                            <p><strong>Hardware Requirements:</strong></p>
                                            <ul>
                                                <li>I/O ports mapped to device registers</li>
                                                <li>Status register for device readiness</li>
                                                <li>Data register for actual transfer</li>
                                                <li>Control register for command issuance</li>
                                            </ul>
                                            <p><strong>Software Flow:</strong></p>
                                            <pre class="bg-light p-2">
while (!(inb(status_port) & READY_BIT)) {
    // Wait for device
}
data = inb(data_port);  // Read byte
mem[destination++] = data;  // Store in memory</pre>
                                            <div class="alert alert-warning mt-2">
                                                <strong>Performance Impact:</strong> CPU utilization approaches 100% during transfers. For a 1MB/s device, CPU could spend >90% cycles just moving data.
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="row mt-3">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-warning text-white">3. Modern Applications</div>
                                        <div class="card-body">
                                            <p><strong>Where PIO Persists:</strong></p>
                                            <ul>
                                                <li>Embedded systems with simple I/O requirements</li>
                                                <li>Legacy device emulation (virtual machines)</li>
                                                <li>Bootloader code before DMA initialization</li>
                                                <li>Low-speed control interfaces (fan control, LEDs)</li>
                                                <li>Security-sensitive operations (TPM communication)</li>
                                            </ul>
                                            <div class="alert alert-info mt-2">
                                                <p><strong>Example:</strong> Modern UEFI firmware uses PIO for initial storage access before setting up DMA controllers during boot.</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-dark text-white">4. Advantages vs Limitations</div>
                                        <div class="card-body">
                                            <table class="table table-sm">
                                                <tr>
                                                    <th>Advantages</th>
                                                    <th>Limitations</th>
                                                </tr>
                                                <tr>
                                                    <td>Simple to implement</td>
                                                    <td>High CPU utilization</td>
                                                </tr>
                                                <tr>
                                                    <td>No additional hardware required</td>
                                                    <td>Poor scalability</td>
                                                </tr>
                                                <tr>
                                                    <td>Predictable timing</td>
                                                    <td>Low overall system throughput</td>
                                                </tr>
                                                <tr>
                                                    <td>Easy to debug</td>
                                                    <td>Wastes CPU cycles polling</td>
                                                </tr>
                                            </table>
                                            <div class="alert alert-danger mt-2">
                                                <strong>Modern Relevance:</strong> PIO is largely obsolete for bulk data transfer but remains useful for control operations where CPU involvement is necessary.
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="alert alert-success mt-4">
                                <h5>Evolutionary Perspective:</h5>
                                <p>While PIO was dominant in early computers (through IDE PIO modes 0-4), modern systems use it only for:</p>
                                <ul>
                                    <li>Initialization sequences before DMA setup</li>
                                    <li>Legacy device support</li>
                                    <li>Extremely low-speed control operations</li>
                                    <li>Fallback mode when DMA fails</li>
                                </ul>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('2.5')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('2.7')">Next</button>
                        </div>
                    </div>

                    <div class="slide" id="slide-2.7">
                        <h2 class="slide-title">Interrupt-Driven I/O</h2>
                        <div class="slide-content">
                            <h4>Event-Driven Data Transfer Mechanism</h4>
                            <p>Interrupt-Driven I/O improves upon Programmed I/O by allowing the CPU to perform other work while waiting for I/O operations to complete. Devices signal completion via hardware interrupts, reducing wasteful polling.</p>
                    
                            <div class="row mt-3">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">1. Operation Mechanism</div>
                                        <div class="card-body">
                                            <p><strong>Data Transfer Process:</strong></p>
                                            <ol>
                                                <li>CPU initiates I/O operation</li>
                                                <li>CPU continues executing other tasks</li>
                                                <li>Device generates interrupt when ready</li>
                                                <li>CPU suspends current task, services interrupt</li>
                                                <li>Interrupt handler processes data</li>
                                                <li>CPU resumes previous task</li>
                                            </ol>
                                            <div class="alert alert-secondary mt-2">
                                                <p><strong>Example:</strong> Keyboard input uses interrupt-driven I/O - the CPU is notified only when keys are pressed rather than constantly polling.</p>
                                            </div>
                                            <p><strong>Technical Characteristics:</strong></p>
                                            <ul>
                                                <li>Requires interrupt controller hardware (APIC, GIC)</li>
                                                <li>Uses interrupt vectors and service routines</li>
                                                <li>Supports prioritized interrupt handling</li>
                                                <li>Enables efficient CPU utilization</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                    
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">2. Implementation Details</div>
                                        <div class="card-body">
                                            <p><strong>Hardware Components:</strong></p>
                                            <ul>
                                                <li>Programmable Interrupt Controller (PIC/APIC)</li>
                                                <li>Interrupt request lines (IRQs)</li>
                                                <li>Interrupt vector table</li>
                                                <li>Device with interrupt capability</li>
                                            </ul>
                                            <p><strong>Software Flow:</strong></p>
                                            <pre class="bg-light p-2">
// Driver initialization
register_interrupt_handler(IRQ_KEYBOARD, keyboard_isr);

// ISR (Interrupt Service Routine)
void keyboard_isr() {
    uint8_t scancode = inb(KEYBOARD_PORT);
    process_keystroke(scancode);
    ack_interrupt();
}</pre>
                                            <div class="alert alert-warning mt-2">
                                                <strong>Latency Considerations:</strong> Interrupt response time must meet device requirements - from microseconds for storage to milliseconds for human input.
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <div class="row mt-3">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-warning text-white">3. Modern Applications</div>
                                        <div class="card-body">
                                            <p><strong>Common Use Cases:</strong></p>
                                            <ul>
                                                <li>Human interface devices (keyboards, mice)</li>
                                                <li>Network packet arrival notification</li>
                                                <li>Storage completion signaling</li>
                                                <li>Real-time event detection</li>
                                                <li>Hardware error reporting</li>
                                            </ul>
                                            <div class="alert alert-info mt-2">
                                                <p><strong>Example:</strong> NVMe SSDs use MSI-X interrupts to signal command completion while the CPU works on other tasks during data transfers.</p>
                                            </div>
                                            <p><strong>Advanced Techniques:</strong></p>
                                            <ul>
                                                <li>Interrupt coalescing (grouping multiple events)</li>
                                                <li>Message-Signaled Interrupts (MSI/MSI-X)</li>
                                                <li>Affinity masking (directing interrupts to specific cores)</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                    
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-dark text-white">4. Performance Considerations</div>
                                        <div class="card-body">
                                            <table class="table table-sm">
                                                <tr>
                                                    <th>Advantages</th>
                                                    <th>Challenges</th>
                                                </tr>
                                                <tr>
                                                    <td>Efficient CPU utilization</td>
                                                    <td>Interrupt overhead (context switches)</td>
                                                </tr>
                                                <tr>
                                                    <td>Low-latency response</td>
                                                    <td>Priority inversion risks</td>
                                                </tr>
                                                <tr>
                                                    <td>Scalable to many devices</td>
                                                    <td>Interrupt storms from faulty devices</td>
                                                </tr>
                                                <tr>
                                                    <td>Power efficient</td>
                                                    <td>Complex debugging</td>
                                                </tr>
                                            </table>
                                            <div class="alert alert-danger mt-2">
                                                <strong>Modern Optimization:</strong> Contemporary systems use hybrid approaches combining interrupts with DMA and polling to balance latency and throughput.
                                            </div>
                                            <p><strong>Performance Metrics:</strong></p>
                                            <ul>
                                                <li>Interrupt latency (μs to ms)</li>
                                                <li>Throughput (interrupts/second)</li>
                                                <li>CPU utilization percentage</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <div class="alert alert-success mt-4">
                                <h5>Evolutionary Perspective:</h5>
                                <p>Interrupt-driven I/O has evolved significantly:</p>
                                <ul>
                                    <li>From simple edge-triggered IRQs to MSI-X</li>
                                    <li>From global interrupt disable to fine-grained masking</li>
                                    <li>From single-core handling to multi-core affinity</li>
                                    <li>From fixed priorities to dynamic QoS management</li>
                                </ul>
                                <p>Modern implementations must balance real-time requirements with power efficiency and throughput.</p>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('2.6')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('2.8')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 2.8: Direct Memory Access -->
                    <div class="slide" id="slide-2.8">
                        <h2 class="slide-title">Direct Memory Access (DMA)</h2>
                        <div class="slide-content">
                            <h4>High-Performance Data Transfer Mechanism</h4>
                            <p>DMA enables devices to transfer data directly to/from memory without CPU intervention, providing the highest bandwidth and lowest CPU overhead for bulk data transfers. Essential for modern high-performance systems.</p>
                    
                            <div class="row mt-3">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">1. Operation Mechanism</div>
                                        <div class="card-body">
                                            <p><strong>Data Transfer Process:</strong></p>
                                            <ol>
                                                <li>CPU sets up DMA controller (source, destination, length)</li>
                                                <li>CPU continues other work</li>
                                                <li>DMA controller manages entire transfer</li>
                                                <li>DMA controller interrupts CPU when done</li>
                                                <li>CPU handles completion tasks</li>
                                            </ol>
                                            <div class="alert alert-secondary mt-2">
                                                <p><strong>Example:</strong> A 4K video frame (24MB) can be transferred by DMA in ~1ms (at 20GB/s) while the CPU renders the previous frame.</p>
                                            </div>
                                            <p><strong>Technical Characteristics:</strong></p>
                                            <ul>
                                                <li>Requires DMA controller (integrated in modern SoCs)</li>
                                                <li>Uses physical memory addresses</li>
                                                <li>Supports scatter-gather operations</li>
                                                <li>Can chain multiple transfers</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                    
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">2. Implementation Details</div>
                                        <div class="card-body">
                                            <p><strong>Hardware Components:</strong></p>
                                            <ul>
                                                <li>DMA controller with multiple channels</li>
                                                <li>System bus with DMA capability</li>
                                                <li>I/O devices with DMA support</li>
                                                <li>Memory controller coordination</li>
                                            </ul>
                                            <p><strong>Software Flow:</strong></p>
                                            <pre class="bg-light p-2">
// Setup DMA transfer
struct dma_descriptor desc = {
    .src = device_buffer_paddr,
    .dst = memory_buffer_paddr,
    .length = BUFFER_SIZE,
    .callback = dma_complete_handler
};
program_dma_controller(DMA_CHANNEL, &desc);

// Completion handler
void dma_complete_handler() {
    // Process transferred data
    process_buffer(memory_buffer);
}</pre>
                                            <div class="alert alert-warning mt-2">
                                                <strong>Cache Coherency:</strong> Modern systems use IOMMU/SMMU to maintain cache consistency during DMA operations.
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <div class="row mt-3">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-warning text-white">3. Modern Applications</div>
                                        <div class="card-body">
                                            <p><strong>Critical Use Cases:</strong></p>
                                            <ul>
                                                <li>High-speed storage (NVMe SSDs)</li>
                                                <li>Network interfaces (10/100G Ethernet)</li>
                                                <li>GPU memory transfers</li>
                                                <li>Audio/video streaming</li>
                                                <li>Inter-processor communication</li>
                                            </ul>
                                            <div class="alert alert-info mt-2">
                                                <p><strong>Example:</strong> A RAID controller might use DMA to simultaneously transfer data from multiple disks directly to application memory buffers.</p>
                                            </div>
                                            <p><strong>Advanced Features:</strong></p>
                                            <ul>
                                                <li>RDMA (Remote Direct Memory Access)</li>
                                                <li>Peer-to-Peer DMA between devices</li>
                                                <li>Scatter-gather lists for non-contiguous transfers</li>
                                                <li>Descriptor chaining for complex operations</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                    
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-dark text-white">4. Performance Optimization</div>
                                        <div class="card-body">
                                            <table class="table table-sm">
                                                <tr>
                                                    <th>Technique</th>
                                                    <th>Benefit</th>
                                                </tr>
                                                <tr>
                                                    <td>Descriptor chaining</td>
                                                    <td>Reduces setup overhead</td>
                                                </tr>
                                                <tr>
                                                    <td>Scatter-gather</td>
                                                    <td>Handles non-contiguous buffers</td>
                                                </tr>
                                                <tr>
                                                    <td>Double buffering</td>
                                                    <td>Overlaps transfer with processing</td>
                                                </tr>
                                                <tr>
                                                    <td>Cache prefetch hints</td>
                                                    <td>Improves memory access patterns</td>
                                                </tr>
                                            </table>
                                            <div class="alert alert-danger mt-2">
                                                <strong>Design Challenges:</strong> Modern systems must handle:
                                                <ul>
                                                    <li>Virtual to physical address translation</li>
                                                    <li>Cache coherency across multiple cores</li>
                                                    <li>Security isolation between processes</li>
                                                    <li>Quality-of-Service guarantees</li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <div class="alert alert-success mt-4">
                                <h5>Evolutionary Perspective:</h5>
                                <p>DMA has evolved from simple single-channel controllers to sophisticated implementations:</p>
                                <ul>
                                    <li>From dedicated DMA chips to integrated controllers</li>
                                    <li>From physical to virtual addressing (IOMMU)</li>
                                    <li>From single transfers to descriptor chains</li>
                                    <li>From local to remote DMA (RDMA over networks)</li>
                                </ul>
                                <p>Modern implementations can sustain transfer rates exceeding 100GB/s in HPC systems.</p>
                            </div>
                    
                            <div class="alert alert-info mt-3">
                                <h5>Comparative Analysis:</h5>
                                <table class="table table-sm">
                                    <tr>
                                        <th>Metric</th>
                                        <th>Programmed I/O</th>
                                        <th>Interrupt-Driven</th>
                                        <th>DMA</th>
                                    </tr>
                                    <tr>
                                        <td>CPU Utilization</td>
                                        <td>Very High</td>
                                        <td>Medium</td>
                                        <td>Very Low</td>
                                    </tr>
                                    <tr>
                                        <td>Transfer Rate</td>
                                        <td>Low (MB/s)</td>
                                        <td>Medium (100MB/s)</td>
                                        <td>High (GB/s+)</td>
                                    </tr>
                                    <tr>
                                        <td>Latency</td>
                                        <td>Predictable</td>
                                        <td>Variable</td>
                                        <td>Setup overhead</td>
                                    </tr>
                                    <tr>
                                        <td>Complexity</td>
                                        <td>Low</td>
                                        <td>Medium</td>
                                        <td>High</td>
                                    </tr>
                                </table>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('2.7')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('3.1')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 3.1: Memory Classification & Parameters -->
                    <div class="slide" id="slide-3.1">
                        <h2 class="slide-title">Memory Classification & Parameters</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Memory Classification</div>
                                        <div class="card-body">
                                            <h5>1. By Volatility:</h5>
                                            <div class="ms-3">
                                                <p><strong>Volatile Memory:</strong> Requires constant power to maintain stored data</p>
                                                <ul>
                                                    <li><u>SRAM</u> (Static RAM): 6T cell, used in CPU caches (L1-L3)</li>
                                                    <li><u>DRAM</u> (Dynamic RAM): 1T1C cell, requires refresh (DDR4/DDR5)</li>
                                                    <li><u>eDRAM</u>: Embedded DRAM (IBM Power processors)</li>
                                                    <li><u>T-RAM</u>/<u>Z-RAM</u>: Novel volatile memories</li>
                                                </ul>
                                                
                                                <p><strong>Non-Volatile Memory (NVM):</strong> Retains data without power</p>
                                                <ul>
                                                    <li><u>Flash</u>: NAND (SSDs), NOR (firmware)</li>
                                                    <li><u>ROM</u>: Mask ROM, PROM, EPROM, EEPROM</li>
                                                    <li><u>MRAM</u>: Magnetic RAM (Everspin)</li>
                                                    <li><u>FeRAM</u>: Ferroelectric RAM (Toshiba)</li>
                                                    <li><u>PCM</u>: Phase Change Memory (Intel Optane)</li>
                                                    <li><u>ReRAM</u>: Resistive RAM (Crossbar Inc.)</li>
                                                </ul>
                                            </div>
                    
                                            <h5 class="mt-4">2. By Access Method:</h5>
                                            <div class="ms-3">
                                                <p><strong>Random Access (RAM):</strong> Constant access time</p>
                                                <ul>
                                                    <li><u>SRAM/DRAM</u>: Byte-addressable</li>
                                                    <li><u>NVRAM</u>: Persistent memory modules</li>
                                                </ul>
                                                
                                                <p><strong>Sequential Access:</strong> Access time depends on location</p>
                                                <ul>
                                                    <li><u>Tape Drives</u>: LTO-9 (18TB capacity)</li>
                                                    <li><u>CCD</u>: Charge-coupled devices</li>
                                                </ul>
                                                
                                                <p><strong>Associative (CAM):</strong> Content-addressable</p>
                                                <ul>
                                                    <li><u>TCAM</u>: Ternary CAM (network routers)</li>
                                                    <li><u>BCAM</u>: Binary CAM (CPU TLBs)</li>
                                                    <li><u>ACAM</u>: Asynchronous CAM (used for pattern matching)</li>
                                                    <li><u>MCAM</u>: Multi-valued CAM (used in image processing)</li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Memory Parameters & Characteristics</div>
                                        <div class="card-body">
                                            <h5>Key Performance Metrics:</h5>
                                            <table class="table table-sm">
                                                <tr>
                                                    <th>Parameter</th>
                                                    <th>Definition</th>
                                                    <th>Measurement</th>
                                                </tr>
                                                <tr>
                                                    <td><strong>Access Time</strong></td>
                                                    <td>Request to data availability</td>
                                                    <td>ns (SRAM) to ms (HDD)</td>
                                                </tr>
                                                <tr>
                                                    <td><strong>Cycle Time</strong></td>
                                                    <td>Minimum between operations</td>
                                                    <td>Often > access time</td>
                                                </tr>
                                                <tr>
                                                    <td><strong>Bandwidth</strong></td>
                                                    <td>Sustained transfer rate</td>
                                                    <td>GB/s (DDR5: 51.2GB/s)</td>
                                                </tr>
                                                <tr>
                                                    <td><strong>Latency</strong></td>
                                                    <td>Total operation delay</td>
                                                    <td>Includes queuing time</td>
                                                </tr>
                                            </table>
                                            
                                            <h5 class="mt-4">Capacity & Cost Factors:</h5>
                                            <div class="row">
                                                <div class="col-md-6">
                                                    <ul>
                                                        <li><strong>Density:</strong> Bits/mm² (3D NAND: >1Tb/mm²)</li>
                                                        <li><strong>Endurance:</strong> Writes before failure
                                                            <ul>
                                                                <li>SLC NAND: 100K cycles</li>
                                                                <li>QLC NAND: 1K cycles</li>
                                                            </ul>
                                                        </li>
                                                    </ul>
                                                </div>
                                                <div class="col-md-6">
                                                    <ul>
                                                        <li><strong>Retention:</strong> Data persistence
                                                            <ul>
                                                                <li>DRAM: ~64ms</li>
                                                                <li>3D XPoint: 10+ years</li>
                                                            </ul>
                                                        </li>
                                                        <li><strong>Cost/bit:</strong> ¢/GB to $/GB</li>
                                                    </ul>
                                                </div>
                                            </div>
                                            
                                            <div class="alert alert-warning mt-3">
                                                <h5>Technology Tradeoffs:</h5>
                                                <p>The memory gap (processor vs. memory speed divergence) creates the need for:</p>
                                                <ul>
                                                    <li>Multi-level caches</li>
                                                    <li>Prefetch algorithms</li>
                                                    <li>Speculative execution</li>
                                                    <li>Non-uniform architectures</li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Memory Technology Deep Dive</div>
                                        <div class="card-body">
                                            <div class="row">
                                                <div class="col-md-4">
                                                    <h5>Volatile Technologies:</h5>
                                                    <ul>
                                                        <li><strong>SRAM</strong>
                                                            <ul>
                                                                <li>6 transistors/cell</li>
                                                                <li>No refresh needed</li>
                                                                <li>Used in CPU caches</li>
                                                                <li>Example: IBM z15 L4 cache (960MB)</li>
                                                            </ul>
                                                        </li>
                                                        <li><strong>DRAM</strong>
                                                            <ul>
                                                                <li>1T1C (transistor + capacitor)</li>
                                                                <li>DDR5: 4800MT/s</li>
                                                                <li>HBM2E: 3.6GB/s per pin</li>
                                                            </ul>
                                                        </li>
                                                    </ul>
                                                </div>
                                                <div class="col-md-4">
                                                    <h5>Non-Volatile Technologies:</h5>
                                                    <ul>
                                                        <li><strong>NAND Flash</strong>
                                                            <ul>
                                                                <li>Floating gate transistors</li>
                                                                <li>3D NAND: 176 layers (2022)</li>
                                                                <li>SLC/MLC/TLC/QLC variants</li>
                                                            </ul>
                                                        </li>
                                                        <li><strong>Emerging NVM</strong>
                                                            <ul>
                                                                <li>Intel Optane (PCM)</li>
                                                                <li>Everspin MRAM (40nm)</li>
                                                                <li>Ferroelectric FETs (FeFET)</li>
                                                            </ul>
                                                        </li>
                                                    </ul>
                                                </div>
                                                <div class="col-md-4">
                                                    <h5>Special Purpose Memories:</h5>
                                                    <ul>
                                                        <li><strong>CAM/TCAM</strong>
                                                            <ul>
                                                                <li>Network routing tables</li>
                                                                <li>10ns search latency</li>
                                                            </ul>
                                                        </li>
                                                        <li><strong>Scratchpad RAM</strong>
                                                            <ul>
                                                                <li>Software-managed cache</li>
                                                                <li>GPUs and DSPs</li>
                                                            </ul>
                                                        </li>
                                                        <li><strong>Shadow RAM</strong>
                                                            <ul>
                                                                <li>BIOS mirroring</li>
                                                                <li>Firmware updates</li>
                                                            </ul>
                                                        </li>
                                                    </ul>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="alert alert-secondary mt-3">
                                <h5>Real-World Examples:</h5>
                                <div class="row">
                                    <div class="col-md-4">
                                        <p><strong>Smartphones:</strong></p>
                                        <ul>
                                            <li>LPDDR5 DRAM (8-16GB)</li>
                                            <li>UFS 3.1 Flash (256GB-1TB)</li>
                                            <li>Always-on SRAM caches</li>
                                        </ul>
                                    </div>
                                    <div class="col-md-4">
                                        <p><strong>Data Centers:</strong></p>
                                        <ul>
                                            <li>Optane Persistent Memory</li>
                                            <li>NVMe SSD Arrays</li>
                                            <li>HBM2 in GPUs</li>
                                        </ul>
                                    </div>
                                    <div class="col-md-4">
                                        <p><strong>Embedded Systems:</strong></p>
                                        <ul>
                                            <li>NOR Flash for firmware</li>
                                            <li>FRAM for data logging</li>
                                            <li>MRAM in IoT devices</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('2.9')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('3.2')">Next</button>
                        </div>
                    </div>
                    

                    <!-- Slide 3.2: Memory Hierarchy -->
                    <div class="slide" id="slide-3.2">
                        <h2 class="slide-title">Memory Hierarchy</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-5">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Hierarchy Visualization</div>
                                        <div class="card-body text-center">
                                            <svg viewBox="0 0 500 480" xmlns="http://www.w3.org/2000/svg">
                                                <!-- Background gradient -->
                                                <defs>
                                                    <linearGradient id="bgGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                                        <stop offset="0%" style="stop-color:#f8f9fa;stop-opacity:1" />
                                                        <stop offset="100%" style="stop-color:#e9ecef;stop-opacity:1" />
                                                    </linearGradient>
                                                    <!-- Level gradients -->
                                                    <linearGradient id="registerGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                                        <stop offset="0%" style="stop-color:#66bb6a;stop-opacity:1" />
                                                        <stop offset="100%" style="stop-color:#43a047;stop-opacity:1" />
                                                    </linearGradient>
                                                    <linearGradient id="l1Gradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                                        <stop offset="0%" style="stop-color:#42a5f5;stop-opacity:1" />
                                                        <stop offset="100%" style="stop-color:#1e88e5;stop-opacity:1" />
                                                    </linearGradient>
                                                    <linearGradient id="l2Gradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                                        <stop offset="0%" style="stop-color:#7e57c2;stop-opacity:1" />
                                                        <stop offset="100%" style="stop-color:#5e35b1;stop-opacity:1" />
                                                    </linearGradient>
                                                    <linearGradient id="l3Gradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                                        <stop offset="0%" style="stop-color:#ab47bc;stop-opacity:1" />
                                                        <stop offset="100%" style="stop-color:#8e24aa;stop-opacity:1" />
                                                    </linearGradient>
                                                    <linearGradient id="dramGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                                        <stop offset="0%" style="stop-color:#ffa726;stop-opacity:1" />
                                                        <stop offset="100%" style="stop-color:#fb8c00;stop-opacity:1" />
                                                    </linearGradient>
                                                    <linearGradient id="storageGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                                        <stop offset="0%" style="stop-color:#ef5350;stop-opacity:1" />
                                                        <stop offset="100%" style="stop-color:#e53935;stop-opacity:1" />
                                                    </linearGradient>
                                                    <linearGradient id="archiveGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                                                        <stop offset="0%" style="stop-color:#78909c;stop-opacity:1" />
                                                        <stop offset="100%" style="stop-color:#546e7a;stop-opacity:1" />
                                                    </linearGradient>
                                                </defs>
                                                
                                                <!-- Background -->
                                                <rect x="0" y="0" width="500" height="480" fill="url(#bgGradient)" rx="10" ry="10"/>
                                                
                                                <!-- Title -->
                                                <text x="250" y="30" text-anchor="middle" font-family="Arial, sans-serif" font-size="18" font-weight="bold" fill="#333">Memory Hierarchy</text>
                                                
                                                <!-- Pyramid Structure with softer edges -->
                                                <path d="M250,60 L450,400 L50,400 Z" fill="none" stroke="#ccc" stroke-width="2" stroke-dasharray="5,5"/>
                                                
                                                <!-- Levels with rounded corners -->
                                                <g>
                                                    <!-- Registers -->
                                                    <rect x="220" y="70" width="60" height="36" rx="5" ry="5" fill="url(#registerGradient)" stroke="#2E7D32" stroke-width="1.5"/>
                                                    <text x="250" y="93" text-anchor="middle" fill="white" font-family="Arial, sans-serif" font-size="12" font-weight="bold">Registers</text>
                                                    <text x="420" y="93" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#333">~0.1-1 ns</text>
                                                    <text x="80" y="93" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#333">~1 KB</text>
                                                    
                                                    <!-- L1 Cache -->
                                                    <rect x="200" y="120" width="100" height="36" rx="5" ry="5" fill="url(#l1Gradient)" stroke="#0D47A1" stroke-width="1.5"/>
                                                    <text x="250" y="143" text-anchor="middle" fill="white" font-family="Arial, sans-serif" font-size="12" font-weight="bold">L1 Cache</text>
                                                    <text x="420" y="143" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#333">~1-3 ns</text>
                                                    <text x="80" y="143" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#333">~64-128 KB</text>
                                                    
                                                    <!-- L2 Cache -->
                                                    <rect x="180" y="170" width="140" height="36" rx="5" ry="5" fill="url(#l2Gradient)" stroke="#311B92" stroke-width="1.5"/>
                                                    <text x="250" y="193" text-anchor="middle" fill="white" font-family="Arial, sans-serif" font-size="12" font-weight="bold">L2 Cache</text>
                                                    <text x="420" y="193" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#333">~3-10 ns</text>
                                                    <text x="80" y="193" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#333">~256 KB-1 MB</text>
                                                    
                                                    <!-- L3 Cache -->
                                                    <rect x="160" y="220" width="180" height="36" rx="5" ry="5" fill="url(#l3Gradient)" stroke="#4A148C" stroke-width="1.5"/>
                                                    <text x="250" y="243" text-anchor="middle" fill="white" font-family="Arial, sans-serif" font-size="12" font-weight="bold">L3 Cache</text>
                                                    <text x="420" y="243" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#333">~10-20 ns</text>
                                                    <text x="80" y="243" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#333">~4-32 MB</text>
                                                    
                                                    <!-- Main Memory -->
                                                    <rect x="140" y="270" width="220" height="36" rx="5" ry="5" fill="url(#dramGradient)" stroke="#E65100" stroke-width="1.5"/>
                                                    <text x="250" y="293" text-anchor="middle" fill="white" font-family="Arial, sans-serif" font-size="12" font-weight="bold">Main Memory (DRAM)</text>
                                                    <text x="420" y="293" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#333">~50-100 ns</text>
                                                    <text x="80" y="293" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#333">~8-128 GB</text>
                                                    
                                                    <!-- Storage -->
                                                    <rect x="120" y="320" width="260" height="36" rx="5" ry="5" fill="url(#storageGradient)" stroke="#B71C1C" stroke-width="1.5"/>
                                                    <text x="250" y="343" text-anchor="middle" fill="white" font-family="Arial, sans-serif" font-size="12" font-weight="bold">Storage (SSD/HDD)</text>
                                                    <text x="420" y="343" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#333">μs - ms</text>
                                                    <text x="80" y="343" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#333">~1-10 TB</text>
                                                    
                                                    <!-- Archive -->
                                                    <rect x="100" y="370" width="300" height="36" rx="5" ry="5" fill="url(#archiveGradient)" stroke="#263238" stroke-width="1.5"/>
                                                    <text x="250" y="393" text-anchor="middle" fill="white" font-family="Arial, sans-serif" font-size="12" font-weight="bold">Archive (Tape/Cloud)</text>
                                                    <text x="420" y="393" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#333">ms - s</text>
                                                    <text x="80" y="393" text-anchor="middle" font-family="Arial, sans-serif" font-size="11" fill="#333">~PB+</text>
                                                </g>
                                                
                                                <!-- Legend -->
                                                <rect x="30" y="430" width="440" height="40" rx="5" ry="5" fill="#fff" stroke="#ccc" stroke-width="1"/>
                                                
                                                <!-- Legend content -->
                                                <text x="60" y="455" font-family="Arial, sans-serif" font-size="12" fill="#333" text-anchor="start">Access Time</text>
                                                <line x1="135" y1="455" x2="155" y2="455" stroke="#333" stroke-width="1.5"/>
                                                <polygon points="155,455 150,452 150,458" fill="#333"/>
                                                
                                                <text x="175" y="455" font-family="Arial, sans-serif" font-size="12" fill="#333" text-anchor="start">Capacity</text>
                                                <line x1="230" y1="455" x2="250" y2="455" stroke="#333" stroke-width="1.5"/>
                                                <polygon points="250,455 245,452 245,458" fill="#333"/>
                                                
                                                <text x="270" y="455" font-family="Arial, sans-serif" font-size="12" fill="#333" text-anchor="start">Cost</text>
                                                <line x1="305" y1="455" x2="325" y2="455" stroke="#333" stroke-width="1.5"/>
                                                <polygon points="305,455 310,452 310,458" fill="#333"/>
                                                
                                                <text x="345" y="455" font-family="Arial, sans-serif" font-size="12" fill="#333" text-anchor="start">Volatility</text>
                                                <line x1="400" y1="455" x2="420" y2="455" stroke="#333" stroke-width="1.5"/>
                                                <polygon points="400,455 405,452 405,458" fill="#333"/>
                                            </svg>
                                        </div>
                                    </div>
                                </div>
                    
                                <div class="col-md-7">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Hierarchy Characteristics</div>
                                        <div class="card-body">
                                            <h5>Principle of Locality:</h5>
                                            <ul>
                                                <li><strong>Temporal Locality:</strong> Recently accessed data is likely to be accessed again soon.</li>
                                                <li><strong>Spatial Locality:</strong> Data located close to recently accessed data is likely to be accessed next.</li>
                                            </ul>
                    
                                            <h5 class="mt-4">Memory Level Descriptions:</h5>
                                            <ul>
                                                <li><strong>Registers:</strong> Fastest, smallest memory directly inside the CPU. Stores operands and results of operations. Accessed every clock cycle.</li>
                                                <li><strong>Caches (L1–L3):</strong> Small, fast SRAM-based memory between the CPU and main memory. Reduces latency by storing frequently used data.</li>
                                                <li><strong>Main Memory (DRAM):</strong> Larger and slower than cache. Holds running programs and active data. Volatile.</li>
                                                <li><strong>Secondary Storage (SSD/HDD):</strong> Non-volatile mass storage for files and software. Much slower but highly capacious.</li>
                                                <li><strong>Archive (Tape/Cloud):</strong> Lowest cost per bit, used for cold storage, backups, and long-term data retention.</li>
                                            </ul>
                    
                                            <div class="alert alert-info mt-3">
                                                <h5>Hierarchy Levels Overview:</h5>
                                                <table class="table table-sm">
                                                    <tr>
                                                        <th>Level</th>
                                                        <th>Technology</th>
                                                        <th>Access Time</th>
                                                        <th>Typical Size</th>
                                                    </tr>
                                                    <tr>
                                                        <td>L0</td>
                                                        <td>CPU Registers</td>
                                                        <td>0.1–1 ns</td>
                                                        <td>KB</td>
                                                    </tr>
                                                    <tr>
                                                        <td>L1</td>
                                                        <td>SRAM (private to core)</td>
                                                        <td>1–3 ns</td>
                                                        <td>32–64 KB</td>
                                                    </tr>
                                                    <tr>
                                                        <td>L2</td>
                                                        <td>SRAM (shared by core pairs)</td>
                                                        <td>3–10 ns</td>
                                                        <td>256 KB–1 MB</td>
                                                    </tr>
                                                    <tr>
                                                        <td>L3</td>
                                                        <td>SRAM (shared across cores)</td>
                                                        <td>10–30 ns</td>
                                                        <td>2–64 MB</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Main</td>
                                                        <td>DRAM</td>
                                                        <td>50–100 ns</td>
                                                        <td>4–128 GB</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Storage</td>
                                                        <td>Flash (SSD) / HDD</td>
                                                        <td>100 μs–10 ms</td>
                                                        <td>500 GB–20 TB</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Archive</td>
                                                        <td>Tape / Cloud</td>
                                                        <td>Milliseconds to minutes</td>
                                                        <td>Petabytes (PB)</td>
                                                    </tr>
                                                </table>
                                            </div>
                    
                                            <h5 class="mt-4">Cache Organization:</h5>
                                            <ul>
                                                <li><strong>Inclusive Cache:</strong> Higher-level caches (e.g., L3) duplicate contents of lower levels (e.g., L1/L2). Easier for coherence but increases redundancy.</li>
                                                <li><strong>Exclusive Cache:</strong> Each level contains unique data. More efficient space-wise but complex to manage.</li>
                                                <li><strong>Write-Through:</strong> Data written to both cache and memory simultaneously. Simplifies coherence.</li>
                                                <li><strong>Write-Back:</strong> Data written to cache first; memory updated later. Improves performance but needs dirty bit tracking.</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <div class="row mt-3">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-warning text-white">Performance Optimization</div>
                                        <div class="card-body">
                                            <h5>Cache Optimization Techniques:</h5>
                                            <ul>
                                                <li><strong>Prefetching:</strong> Predicts future memory accesses and loads data into the cache before it is actually needed. This reduces stall cycles caused by memory latency.
                                                    <ul>
                                                        <li><em>Hardware prefetching</em>: Uses access patterns to load blocks (e.g., stride-based).</li>
                                                        <li><em>Software prefetching</em>: Compiler-inserted instructions to hint the hardware.</li>
                                                    </ul>
                                                </li>
                                
                                                <li><strong>Blocking (Loop Tiling):</strong> Breaks down large data operations (like matrix multiplications) into smaller chunks that fit in cache, ensuring reuse of cache-resident data.
                                                    <ul>
                                                        <li>Reduces cache thrashing and improves locality.</li>
                                                        <li>Example: Accessing sub-matrices (tiles) instead of full rows/columns.</li>
                                                    </ul>
                                                </li>
                                
                                                <li><strong>Set-Associativity:</strong> Improves cache efficiency by allowing each memory block to map to multiple cache locations (sets), lowering the risk of conflict misses.
                                                    <ul>
                                                        <li>Direct-mapped (1-way) vs. 2-way, 4-way, 8-way caches.</li>
                                                        <li>Higher associativity = fewer collisions, but slightly higher lookup time.</li>
                                                    </ul>
                                                </li>
                                
                                                <li><strong>Replacement Policies:</strong> Determines which cache block to evict when the cache is full.
                                                    <ul>
                                                        <li>Examples: LRU (Least Recently Used), FIFO, Random.</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                
                                            <div class="alert alert-secondary mt-3">
                                                <p><strong>Example:</strong> In matrix multiplication, using blocking with 64×64 tiles fits submatrices into L1 cache (32 KB), significantly reducing access to slower DRAM.</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>                                
                    
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-danger text-white">Modern Developments</div>
                                        <div class="card-body">
                                            <h5>Key Innovations in Memory Architecture:</h5>
                                            <ul>
                                                <li><strong>Non-Uniform Memory Access (NUMA):</strong> Memory latency depends on the proximity of memory to the processing core. Common in multi-socket systems where each processor has its own local memory.
                                                    <ul>
                                                        <li>Access to remote memory is slower than local memory.</li>
                                                        <li>NUMA-aware OS and thread scheduling improves performance.</li>
                                                    </ul>
                                                </li>
                                
                                                <li><strong>Persistent Memory (PMEM):</strong> Combines features of RAM and storage. It is byte-addressable, fast like DRAM, and retains data like flash.
                                                    <ul>
                                                        <li>Example: Intel Optane DC Persistent Memory Modules.</li>
                                                        <li>Use cases: in-memory databases, fast restart after power loss.</li>
                                                    </ul>
                                                </li>
                                
                                                <li><strong>3D Stacked Memory:</strong> Vertical stacking of memory dies using through-silicon vias (TSVs) for high bandwidth and low power.
                                                    <ul>
                                                        <li>HBM (High Bandwidth Memory) used in GPUs (e.g., NVIDIA A100).</li>
                                                        <li>HMC (Hybrid Memory Cube) integrates memory and logic layers.</li>
                                                    </ul>
                                                </li>
                                
                                                <li><strong>Near-Memory Processing (NMP):</strong> Integrates compute units close to memory to minimize data movement and latency.
                                                    <ul>
                                                        <li>Ideal for data-intensive tasks (e.g., AI inference, analytics).</li>
                                                        <li>Reduces memory bandwidth bottlenecks.</li>
                                                    </ul>
                                                </li>
                                
                                                <li><strong>Unified Memory Architecture (UMA):</strong> Shared memory space between CPU and GPU, removing the need for explicit data copying.
                                                    <ul>
                                                        <li>Seen in Apple M1/M2 chips and CUDA’s unified memory model.</li>
                                                        <li>Simplifies programming and improves performance for heterogeneous workloads.</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                
                                            <div class="alert alert-success mt-2">
                                                <p><strong>Emerging Paradigm:</strong> <em>Memory-Centric Computing</em> reimagines computing with memory at the center—processing happens where data lives, reducing bottlenecks and energy consumption in AI and HPC systems.</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('3.1')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('3.3')">Next</button>
                        </div>
                    </div>
                    

                    <!-- Slide 3.3: RAM, SRAM and DRAM -->
                    <div class="slide" id="slide-3.3">
                        <h2 class="slide-title">RAM Technologies: SRAM vs DRAM</h2>
                        <div class="slide-content">
                            <div class="row">
                                <!-- SRAM -->
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">SRAM (Static Random Access Memory)</div>
                                        <div class="card-body">
                                            <h5>Definition:</h5>
                                            <p><strong>SRAM</strong> is a type of volatile memory that stores data using a bistable latching circuitry, meaning it does not need to be refreshed as long as power is supplied.</p>
                    
                                            <h5>Architecture:</h5>
                                            <ul>
                                                <li>6-Transistor (6T) cell: Consists of two cross-coupled inverters and two access transistors.</li>
                                                <li>Data is stored in flip-flop circuits—this makes it fast and stable but larger in area.</li>
                                                <li>No capacitors are used, unlike DRAM.</li>
                                            </ul>
                    
                                            <div class="text-center my-3">
                                                <svg width="200" height="120" viewBox="0 0 200 120" class="border p-2">
                                                    <!-- SRAM 6T Cell Schematic -->
                                                    <rect x="20" y="20" width="40" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                    <text x="40" y="40" text-anchor="middle" font-size="8">M1</text>
                                                    <rect x="70" y="20" width="40" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                    <text x="90" y="40" text-anchor="middle" font-size="8">M2</text>
                                                    <path d="M40 50 Q60 60 80 50" stroke="#00796b" fill="none"/>
                                                    <path d="M80 70 Q60 80 40 70" stroke="#00796b" fill="none"/>
                                                    <text x="60" y="100" text-anchor="middle" font-size="8">6T SRAM Cell</text>
                                                </svg>
                                            </div>
                    
                                            <h5>Key Characteristics:</h5>
                                            <ul>
                                                <li><strong>Speed:</strong> Extremely fast access (~0.5-5ns)</li>
                                                <li><strong>Power:</strong> Higher power usage due to leakage current</li>
                                                <li><strong>Density:</strong> Low density due to large cell size (~6 transistors per bit)</li>
                                                <li><strong>No Refresh Needed:</strong> Data retention while powered</li>
                                            </ul>
                    
                                            <div class="alert alert-info mt-2">
                                                <strong>Applications:</strong> CPU caches (L1, L2, L3), TLBs, GPU registers, network buffers.
                                            </div>
                                        </div>
                                    </div>
                                </div>
                    
                                <!-- DRAM -->
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">DRAM (Dynamic Random Access Memory)</div>
                                        <div class="card-body">
                                            <h5>Definition:</h5>
                                            <p><strong>DRAM</strong> is a type of volatile memory that stores each bit using a transistor and a capacitor (1T1C). Since capacitors leak charge, the memory must be periodically refreshed.</p>
                    
                                            <h5>Architecture:</h5>
                                            <ul>
                                                <li>1-Transistor + 1-Capacitor per cell</li>
                                                <li>Data stored as electric charge in the capacitor</li>
                                                <li>Requires periodic refresh cycles (~64ms)</li>
                                            </ul>
                    
                                            <h5>DRAM Generations:</h5>
                                            <table class="table table-sm">
                                                <tr>
                                                    <th>Type</th>
                                                    <th>Transfer Rate</th>
                                                    <th>Voltage</th>
                                                </tr>
                                                <tr>
                                                    <td>DDR4</td>
                                                    <td>1600–3200 MT/s</td>
                                                    <td>1.2V</td>
                                                </tr>
                                                <tr>
                                                    <td>DDR5</td>
                                                    <td>4800–6400 MT/s</td>
                                                    <td>1.1V</td>
                                                </tr>
                                                <tr>
                                                    <td>LPDDR5</td>
                                                    <td>6400 MT/s</td>
                                                    <td>~0.5V (mobile-optimized)</td>
                                                </tr>
                                            </table>
                    
                                            <h5>Advanced DRAM Types:</h5>
                                            <ul>
                                                <li><strong>HBM (High Bandwidth Memory):</strong> 3D-stacked DRAM for GPUs/AI</li>
                                                <li><strong>GDDR6:</strong> High-speed graphics DRAM</li>
                                                <li><strong>RLDRAM:</strong> Reduced-latency DRAM for networking</li>
                                            </ul>
                    
                                            <div class="alert alert-warning mt-2">
                                                <strong>Refresh Overhead:</strong> Memory loses bandwidth to refresh cycles (e.g., ~5% in DDR5).
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <!-- Comparative Analysis -->
                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Comparative Analysis</div>
                                        <div class="card-body">
                                            <div class="row">
                                                <div class="col-md-6">
                                                    <h5>SRAM vs DRAM:</h5>
                                                    <table class="table table-bordered">
                                                        <tr>
                                                            <th>Parameter</th>
                                                            <th>SRAM</th>
                                                            <th>DRAM</th>
                                                        </tr>
                                                        <tr>
                                                            <td>Access Time</td>
                                                            <td>1–10 ns</td>
                                                            <td>50–100 ns</td>
                                                        </tr>
                                                        <tr>
                                                            <td>Cell Size</td>
                                                            <td>~140–200 F²</td>
                                                            <td>~6–10 F²</td>
                                                        </tr>
                                                        <tr>
                                                            <td>Power Use</td>
                                                            <td>Static (idle leakage)</td>
                                                            <td>Dynamic (refresh cycles)</td>
                                                        </tr>
                                                        <tr>
                                                            <td>Cost/bit</td>
                                                            <td>Very high (~100× DRAM)</td>
                                                            <td>Low (~$0.01/GB)</td>
                                                        </tr>
                                                        <tr>
                                                            <td>Volatility</td>
                                                            <td>Volatile (needs power)</td>
                                                            <td>Volatile + needs refresh</td>
                                                        </tr>
                                                    </table>
                                                </div>
                                                <div class="col-md-6">
                                                    <h5>Modern Implementations:</h5>
                                                    <ul>
                                                        <li><strong>eDRAM:</strong> High-density DRAM integrated into chips (e.g., IBM z15 L4)</li>
                                                        <li><strong>STT-MRAM:</strong> Non-volatile memory aiming to replace SRAM</li>
                                                        <li><strong>Z-RAM:</strong> High-density, zero-capacitor DRAM variant</li>
                                                    </ul>
                                                    <div class="alert alert-secondary mt-2">
                                                        <p><strong>Future Trends:</strong> 3D monolithic SRAM, gain-cell DRAM, hybrid memory cubes, and unified memory architectures with AI/ML integration.</p>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('3.2')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('3.4')">Next</button>
                        </div>
                    </div>                    

                    <!-- Slide 3.4: Interleaved and Associative Memory -->
                    <div class="slide" id="slide-3.4">
                        <h2 class="slide-title">Interleaved & Associative Memory</h2>
                        <div class="slide-content">
                            <div class="row">
                                <!-- Memory Interleaving Section -->
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Memory Interleaving</div>
                                        <div class="card-body">
                                            <h5>Definition:</h5>
                                            <p><strong>Memory interleaving</strong> is a technique that distributes memory addresses across multiple memory banks, allowing multiple memory accesses to be overlapped and improving bandwidth.</p>
                    
                                            <h5>Concept:</h5>
                                            <p>Instead of accessing memory serially, addresses are split across banks so that while one bank is busy, others can be accessed concurrently.</p>
                    
                                            <div class="text-center my-3">
                                                <svg width="100%" height="150" viewBox="0 0 300 150">
                                                    <!-- Interleaving Diagram -->
                                                    <rect x="10" y="20" width="60" height="100" fill="#bbdefb" stroke="#0d47a1"/>
                                                    <text x="40" y="70" text-anchor="middle">Bank 0</text>
                                                    <rect x="80" y="20" width="60" height="100" fill="#c8e6c9" stroke="#2e7d32"/>
                                                    <text x="110" y="70" text-anchor="middle">Bank 1</text>
                                                    <rect x="150" y="20" width="60" height="100" fill="#ffecb3" stroke="#ffa000"/>
                                                    <text x="180" y="70" text-anchor="middle">Bank 2</text>
                                                    <rect x="220" y="20" width="60" height="100" fill="#ffcdd2" stroke="#c62828"/>
                                                    <text x="250" y="70" text-anchor="middle">Bank 3</text>
                                                    <text x="150" y="140" text-anchor="middle">4-Way Memory Interleaving</text>
                                                </svg>
                                            </div>
                    
                                            <h5>Interleaving Types:</h5>
                                            <ul>
                                                <li><strong>Low-Order Interleaving:</strong> Distributes consecutive memory words across banks.
                                                    <pre class="bg-light p-2">Address: [Bank Bits][Word Offset]</pre>
                                                </li>
                                                <li><strong>High-Order Interleaving:</strong> Allocates entire memory blocks to separate banks.
                                                    <pre class="bg-light p-2">Address: [Block Offset][Bank Bits]</pre>
                                                </li>
                                            </ul>
                    
                                            <h5>Performance Impact:</h5>
                                            <ul>
                                                <li>Reduces memory access latency via parallelism.</li>
                                                <li>Improves throughput in multi-threaded and pipelined systems.</li>
                                                <li>Common in vector processors, GPUs, and high-performance systems.</li>
                                                <li><strong>Example:</strong> 8-way interleaving can offer up to 6–8× effective memory bandwidth.</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                    
                                <!-- Associative Memory Section -->
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Associative Memory (CAM)</div>
                                        <div class="card-body">
                                            <h5>Definition:</h5>
                                            <p><strong>Associative Memory</strong>, also called <strong>Content-Addressable Memory (CAM)</strong>, retrieves data based on the content rather than the address. It allows simultaneous comparison of the search data with all stored entries.</p>
                    
                                            <h5>How CAM Works:</h5>
                                            <ul>
                                                <li>Every memory word is compared in parallel to the input query.</li>
                                                <li>Returns the matching address or all matches (in TCAM).</li>
                                                <li>Enables high-speed lookup operations (e.g., in TLBs or routers).</li>
                                            </ul>
                    
                                            <h5>Types of CAM:</h5>
                                            <table class="table table-sm">
                                                <tr>
                                                    <th>Type</th>
                                                    <th>Bits/Cell</th>
                                                    <th>Use Case</th>
                                                </tr>
                                                <tr>
                                                    <td>Binary CAM</td>
                                                    <td>1</td>
                                                    <td>Translation Lookaside Buffers (TLBs), Cache Tag Matching</td>
                                                </tr>
                                                <tr>
                                                    <td>Ternary CAM (TCAM)</td>
                                                    <td>1.5 (includes "don't care")</td>
                                                    <td>IP routing, ACLs in network routers</td>
                                                </tr>
                                            </table>
                    
                                            <h5>Example: TCAM Matching</h5>
                                            <pre class="bg-light p-2">
// Search IP prefix 192.168.X.X
Pattern: 192.168.*.*
Mask:    255.255.0.0
Result:  Returns matching entries across subnets
                        </pre>
                    
                                            <div class="alert alert-warning mt-2">
                                                <strong>Power Draw:</strong> Parallel comparisons make CAMs power-hungry (e.g., 1Mb TCAM can consume 15–20W).
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <!-- Advanced Architectures Section -->
                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Advanced Architectures & Applications</div>
                                        <div class="card-body">
                                            <div class="row">
                                                <!-- Interleaving Innovations -->
                                                <div class="col-md-6">
                                                    <h5>Bank Conflict Mitigation:</h5>
                                                    <ul>
                                                        <li><strong>Skewed Interleaving:</strong> Banks use different hash functions to reduce conflict.</li>
                                                        <li><strong>Prime Number of Banks:</strong> Reduces stride-based collisions.</li>
                                                        <li><strong>Sub-Banking:</strong> Each memory bank further divided into sub-units for better concurrency.</li>
                                                    </ul>
                                                </div>
                    
                                                <!-- CAM Innovations -->
                                                <div class="col-md-6">
                                                    <h5>CAM Efficiency Techniques:</h5>
                                                    <ul>
                                                        <li><strong>Partitioned CAM:</strong> Hierarchical lookup for faster search.</li>
                                                        <li><strong>Power-Gating:</strong> Dynamically disables unused sections to save power.</li>
                                                        <li><strong>Hybrid RAM/CAM:</strong> Configurable memory that can operate as RAM or CAM.</li>
                                                    </ul>
                                                </div>
                                            </div>
                    
                                            <div class="alert alert-secondary mt-3">
                                                <h5>Real-World Implementations:</h5>
                                                <div class="row">
                                                    <div class="col-md-4">
                                                        <p><strong>GPUs:</strong> 32-way interleaved shared memory in NVIDIA Ampere for warps</p>
                                                    </div>
                                                    <div class="col-md-4">
                                                        <p><strong>Network Switches:</strong> TCAMs with up to 100M entries (e.g., Cisco Nexus series)</p>
                                                    </div>
                                                    <div class="col-md-4">
                                                        <p><strong>AI Accelerators:</strong> CAMs used for K-Nearest Neighbor (KNN) vector similarity search</p>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('3.3')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('3.5')">Next</button>
                        </div>
                    </div>                    

                    <!-- Slide 3.5: Cache Memory Principles -->
                    <div class="slide" id="slide-3.5">
                        <h2 class="slide-title">Cache Memory Principles</h2>
                        <div class="slide-content">
                            <div class="row">
                                <!-- Cache Fundamentals -->
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Cache Fundamentals</div>
                                        <div class="card-body">
                                            <h5>Definition:</h5>
                                            <p><strong>Cache memory</strong> is a small, fast memory placed between the CPU and main memory (RAM), used to store frequently accessed data and instructions, reducing average memory access time.</p>
                    
                                            <h5>Cache Organization:</h5>
                                            <ul>
                                                <li><strong>Cache Block (Line):</strong> Minimum unit of data transfer (typically 64 bytes).</li>
                                                <li><strong>Set:</strong> A group of blocks among which the block can be placed, defined by indexing bits.</li>
                                                <li><strong>Way:</strong> Represents the number of blocks per set, defining cache associativity.</li>
                                            </ul>
                    
                                            <div class="text-center my-3">
                                                <svg width="100%" height="180" viewBox="0 0 300 180">
                                                    <!-- Cache Structure -->
                                                    <rect x="10" y="10" width="280" height="30" fill="#e3f2fd" stroke="#1565c0"/>
                                                    <text x="150" y="30" text-anchor="middle">Cache (64KB, 4-way)</text>
                    
                                                    <rect x="10" y="50" width="70" height="30" fill="#bbdefb" stroke="#0d47a1"/>
                                                    <text x="45" y="70" text-anchor="middle">Set 0</text>
                                                    <rect x="80" y="50" width="70" height="30" fill="#bbdefb" stroke="#0d47a1"/>
                                                    <text x="115" y="70" text-anchor="middle">Set 1</text>
                                                    <rect x="150" y="50" width="70" height="30" fill="#bbdefb" stroke="#0d47a1"/>
                                                    <text x="185" y="70" text-anchor="middle">Set 2</text>
                                                    <rect x="220" y="50" width="70" height="30" fill="#bbdefb" stroke="#0d47a1"/>
                                                    <text x="255" y="70" text-anchor="middle">Set N</text>
                    
                                                    <!-- Ways -->
                                                    <rect x="10" y="90" width="70" height="20" fill="#e8f5e9" stroke="#2e7d32"/>
                                                    <rect x="10" y="110" width="70" height="20" fill="#e8f5e9" stroke="#2e7d32"/>
                                                    <rect x="10" y="130" width="70" height="20" fill="#e8f5e9" stroke="#2e7d32"/>
                                                    <rect x="10" y="150" width="70" height="20" fill="#e8f5e9" stroke="#2e7d32"/>
                                                    <text x="45" y="100" text-anchor="middle" font-size="8">Way 0</text>
                                                    <text x="45" y="120" text-anchor="middle" font-size="8">Way 1</text>
                                                    <text x="45" y="140" text-anchor="middle" font-size="8">Way 2</text>
                                                    <text x="45" y="160" text-anchor="middle" font-size="8">Way 3</text>
                                                </svg>
                                            </div>
                    
                                            <h5>Cache Parameters:</h5>
                                            <pre class="bg-light p-2">
Total Cache Size = Number of Sets × Number of Ways × Block Size

Example:
64KB = 256 sets × 4 ways × 64B block</pre>
                                        </div>
                                    </div>
                                </div>
                    
                                <!-- Cache Performance -->
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Cache Performance</div>
                                        <div class="card-body">
                                            <h5>Performance Metrics:</h5>
                                            <ul>
                                                <li><strong>Hit Rate:</strong> Percentage of memory accesses found in the cache (L1: 95–99%).</li>
                                                <li><strong>Miss Penalty:</strong> Time taken to fetch data from the next level (L2/L3/main memory).</li>
                                                <li><strong>AMAT (Avg. Memory Access Time):</strong>
                                                    <pre class="bg-light p-2">AMAT = Hit Time + (Miss Rate × Miss Penalty)</pre>
                                                </li>
                                            </ul>
                    
                                            <h5>Types of Cache Misses:</h5>
                                            <table class="table table-sm">
                                                <tr>
                                                    <th>Type</th>
                                                    <th>Cause</th>
                                                    <th>Solution</th>
                                                </tr>
                                                <tr>
                                                    <td><strong>Compulsory</strong></td>
                                                    <td>First access to data block</td>
                                                    <td>Hardware/software prefetching</td>
                                                </tr>
                                                <tr>
                                                    <td><strong>Conflict</strong></td>
                                                    <td>Two blocks map to the same set</td>
                                                    <td>Higher associativity or better mapping</td>
                                                </tr>
                                                <tr>
                                                    <td><strong>Capacity</strong></td>
                                                    <td>Cache is too small for working set</td>
                                                    <td>Use larger or multi-level caches</td>
                                                </tr>
                                            </table>
                    
                                            <div class="alert alert-warning mt-2">
                                                <strong>Modern Cache Hierarchies:</strong> CPUs often use L1 (split), L2 (private), L3 (shared) caches with different inclusivity policies (inclusive, exclusive, or non-inclusive).
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <!-- Advanced Cache Techniques -->
                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Advanced Cache Techniques</div>
                                        <div class="card-body">
                                            <div class="row">
                                                <div class="col-md-4">
                                                    <h5>Prefetching:</h5>
                                                    <ul>
                                                        <li><strong>Stream Buffers:</strong> Detect and load sequential blocks.</li>
                                                        <li><strong>Stride Prediction:</strong> Anticipate regular access patterns.</li>
                                                        <li><strong>ML-based:</strong> Use learning algorithms to predict access behavior.</li>
                                                    </ul>
                                                </div>
                                                <div class="col-md-4">
                                                    <h5>Replacement Policies:</h5>
                                                    <ul>
                                                        <li><strong>LRU (Least Recently Used):</strong> Evict the oldest accessed block.</li>
                                                        <li><strong>PLRU:</strong> Approximate LRU with less overhead.</li>
                                                        <li><strong>Random:</strong> Simple but unpredictable performance.</li>
                                                    </ul>
                                                </div>
                                                <div class="col-md-4">
                                                    <h5>Write Policies:</h5>
                                                    <ul>
                                                        <li><strong>Write-Through:</strong> Immediately updates main memory.</li>
                                                        <li><strong>Write-Back:</strong> Updates memory only on eviction (reduces traffic).</li>
                                                        <li><strong>Write Allocate:</strong> Allocates block on write miss (common with write-back).</li>
                                                    </ul>
                                                </div>
                                            </div>
                    
                                            <div class="alert alert-secondary mt-3">
                                                <h5>Case Study: Intel Sunny Cove</h5>
                                                <div class="row">
                                                    <div class="col-md-4">
                                                        <p><strong>L1 Data Cache:</strong> 48KB, 12-way set-associative, 4-cycle latency</p>
                                                    </div>
                                                    <div class="col-md-4">
                                                        <p><strong>L2 Cache:</strong> 512KB, 8-way, 14-cycle latency</p>
                                                    </div>
                                                    <div class="col-md-4">
                                                        <p><strong>L3 Cache:</strong> 2MB/core, 16-way, ~40-cycle latency, shared</p>
                                                    </div>
                                                </div>
                                                <p><strong>Policy Note:</strong> L3 is typically non-inclusive, helping reduce duplication and coherency complexity.</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('3.4')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('3.6')">Next</button>
                        </div>
                    </div>                    

                    <!-- Slide 3.6: Memory Mappings -->
                    <div class="slide" id="slide-3.6">
                        <h2 class="slide-title">Memory Mapping Techniques</h2>
                        <div class="slide-content">
                            <div class="row">
                                <!-- Direct Mapped -->
                                <div class="col-md-4">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Direct Mapped</div>
                                        <div class="card-body">
                                            <h5>Definition & Operation:</h5>
                                            <p>
                                                A <strong>direct-mapped cache</strong> assigns each main memory block to exactly one cache line using a modulo operation. 
                                                This creates a one-to-one mapping between a memory block and a cache line index, determined by:
                                            </p>
                                            <pre class="bg-light p-2">
Index = (Block Address) MOD (Number of Cache Lines)
                        </pre>
                                            <p>
                                                During lookup, only one tag comparison is needed, making this the <strong>fastest and most hardware-efficient</strong> mapping strategy. 
                                                However, two blocks that map to the same line will evict each other, causing frequent <em>conflict misses</em> despite low spatial reuse.
                                            </p>
                    
                                            <div class="text-center my-3">
                                                <!-- Diagram omitted for brevity -->
                                            </div>
                    
                                            <h5>Design Characteristics:</h5>
                                            <ul>
                                                <li>Minimal hardware: only one comparator and simple indexing logic</li>
                                                <li>Highest conflict miss rate due to no flexibility in placement</li>
                                                <li>Well-suited for fast-access structures (e.g., Instruction TLBs)</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                    
                                <!-- Set-Associative -->
                                <div class="col-md-4">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Set-Associative</div>
                                        <div class="card-body">
                                            <h5>Definition & Operation:</h5>
                                            <p>
                                                A <strong>set-associative cache</strong> divides the cache into multiple <strong>sets</strong>, each containing <em>N</em> lines (ways). 
                                                A memory block maps to a specific set, but can occupy any line within it. This balances flexibility and efficiency.
                                            </p>
                                            <pre class="bg-light p-2">
Set Index = (Block Address) MOD (Number of Sets)
                        </pre>
                                            <p>
                                                Lookup involves comparing the block tag against all tags within the set (N comparisons). 
                                                This structure reduces conflict misses significantly over direct-mapped caches and provides better adaptability to common memory access patterns (e.g., loops).
                                            </p>
                    
                                            <h5>Design Characteristics:</h5>
                                            <ul>
                                                <li>Improved hit rate with moderate hardware cost (N comparators per set)</li>
                                                <li>Most common configuration in modern CPUs (4-way to 16-way)</li>
                                                <li>Replacement policies needed (e.g., LRU, PLRU)</li>
                                            </ul>
                    
                                            <div class="alert alert-info mt-2">
                                                <strong>Design Trade-Offs:</strong>
                                                <ul>
                                                    <li>Higher associativity improves hit rate but increases hit time</li>
                                                    <li>4- to 8-way is a practical sweet spot for L1/L2 caches</li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                    
                                <!-- Fully Associative -->
                                <div class="col-md-4">
                                    <div class="card h-100">
                                        <div class="card-header bg-warning text-white">Fully Associative</div>
                                        <div class="card-body">
                                            <h5>Definition & Operation:</h5>
                                            <p>
                                                In a <strong>fully associative cache</strong>, a memory block can be placed <em>anywhere</em> in the cache. 
                                                On access, the cache performs a <strong>parallel comparison</strong> between the block tag and all stored tags to find a match.
                                            </p>
                                            <p>
                                                This method eliminates conflict misses entirely, making it ideal for caches that must absorb diverse and unpredictable memory access patterns.
                                                However, the hardware required for parallel tag matching (typically a CAM) is costly in terms of area, power, and delay.
                                            </p>
                    
                                            <h5>Design Characteristics:</h5>
                                            <ul>
                                                <li>Best flexibility and lowest miss rate</li>
                                                <li>Worst latency and power usage due to exhaustive search</li>
                                                <li>Used in <strong>TLBs, victim caches, store buffers</strong></li>
                                            </ul>
                    
                                            <div class="alert alert-secondary mt-2">
                                                <strong>Why Use It?</strong>
                                                <p>
                                                    Often deployed for <em>small, high-impact caches</em> that require minimal miss rates, such as TLBs (for virtual-to-physical translation) and victim caches (to absorb conflict misses).
                                                </p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <!-- Comparative Table -->
                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Comparative Analysis</div>
                                        <div class="card-body">
                                            <table class="table table-bordered">
                                                <thead class="thead-dark">
                                                    <tr>
                                                        <th>Mapping Type</th>
                                                        <th>Hit Time</th>
                                                        <th>Miss Rate</th>
                                                        <th>Hardware Cost</th>
                                                        <th>Power Usage</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    <tr>
                                                        <td>Direct Mapped</td>
                                                        <td><strong>Fastest</strong> (1 cycle)</td>
                                                        <td><span class="text-danger">Highest</span></td>
                                                        <td><strong>Lowest</strong></td>
                                                        <td><strong>Lowest</strong></td>
                                                    </tr>
                                                    <tr>
                                                        <td>Set-Associative</td>
                                                        <td>Moderate (2–3 cycles)</td>
                                                        <td>Lower</td>
                                                        <td>Moderate (N comparators)</td>
                                                        <td>Moderate</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Fully Associative</td>
                                                        <td><span class="text-warning">Slowest</span> (depends on CAM delay)</td>
                                                        <td><strong>Lowest</strong></td>
                                                        <td><span class="text-warning">Highest</span></td>
                                                        <td><span class="text-warning">Highest</span></td>
                                                    </tr>
                                                </tbody>
                                            </table>
                    
                                            <div class="alert alert-warning mt-3">
                                                <h5>Modern Hybrid Techniques:</h5>
                                                <div class="row">
                                                    <div class="col-md-4">
                                                        <p><strong>Skewed Associative:</strong> Different hash/index functions per way to reduce collisions</p>
                                                    </div>
                                                    <div class="col-md-4">
                                                        <p><strong>Z-Cache:</strong> Dynamically remaps blocks to different sets to simulate full associativity</p>
                                                    </div>
                                                    <div class="col-md-4">
                                                        <p><strong>Column-Associative:</strong> Uses secondary access logic (like way prediction) to reduce power in associative lookups</p>
                                                    </div>
                                                </div>
                                                <p class="mt-2">These techniques aim to improve hit rates with minimal power/area impact—crucial for modern CPUs and embedded processors.</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('3.5')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('3.7')">Next</button>
                        </div>
                    </div>                    

                    <!-- Slide 3.7: Cache Performance -->
                    <div class="slide" id="slide-3.7">
                        <h2 class="slide-title">Cache Performance</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Key Metrics</div>
                                        <div class="card-body">
                                            <h5>Hit Rate:</h5>
                                            <p>The hit rate is the percentage of memory accesses that are satisfied by the cache. A higher hit rate indicates better cache performance.</p>
                                            <p><strong>Typical Values:</strong> L1 cache can have hit rates of 95-99%, while L2 and L3 caches have lower hit rates depending on their size and proximity to the processor.</p>
                                            
                                            <h5>Miss Rate:</h5>
                                            <p>The miss rate is the complement of the hit rate (1 - hit rate). It indicates the percentage of memory accesses that are not satisfied by the cache and must be fetched from a lower memory hierarchy level.</p>
                    
                                            <h5>Average Memory Access Time (AMAT):</h5>
                                            <pre class="bg-light p-2">
AMAT = Hit Time + Miss Rate × Miss Penalty
                        </pre>
                                            <p>AMAT is the average time it takes to access memory, factoring in the time it takes to hit or miss in the cache, as well as the time spent accessing memory from lower levels (e.g., main memory or disk).</p>
                                        </div>
                                    </div>
                                </div>
                    
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Miss Penalty</div>
                                        <div class="card-body">
                                            <h5>Miss Penalty:</h5>
                                            <p>Miss penalty refers to the time spent retrieving data from a lower-level memory hierarchy (such as L2 or main memory) when a cache miss occurs.</p>
                                            <ul>
                                                <li><strong>Cache miss penalty:</strong> L1 to L2 latency can be around 10-15 cycles.</li>
                                                <li><strong>Main memory miss penalty:</strong> Can be significantly higher, often in the range of 100-200 cycles.</li>
                                            </ul>
                    
                                            <h5>Optimizing Cache Performance:</h5>
                                            <ul>
                                                <li><strong>Cache Size:</strong> Larger caches reduce miss rates but increase latency.</li>
                                                <li><strong>Associativity:</strong> Higher associativity reduces conflict misses but can increase the complexity of cache management.</li>
                                                <li><strong>Replacement Policy:</strong> A well-optimized replacement policy (e.g., LRU) can improve cache efficiency.</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Cache Optimization Techniques</div>
                                        <div class="card-body">
                                            <h5>Prefetching:</h5>
                                            <p>Prefetching is a technique to reduce cache misses by fetching data before it is actually needed.</p>
                                            <ul>
                                                <li><strong>Stream buffers:</strong> Prefetching sequential memory accesses.</li>
                                                <li><strong>Stride prediction:</strong> Identifying regular memory access patterns.</li>
                                                <li><strong>Machine learning:</strong> Predicting future accesses based on historical data.</li>
                                            </ul>
                    
                                            <h5>Replacement Policies:</h5>
                                            <ul>
                                                <li><strong>LRU (Least Recently Used):</strong> Evicts the least recently used cache line.</li>
                                                <li><strong>PLRU (Pseudo-LRU):</strong> An approximation of LRU, reducing hardware complexity.</li>
                                                <li><strong>Random replacement:</strong> Randomly selects a cache line to replace.</li>
                                            </ul>
                    
                                            <h5>Write Policies:</h5>
                                            <ul>
                                                <li><strong>Write-through:</strong> Updates both cache and memory.</li>
                                                <li><strong>Write-back:</strong> Updates memory only when a cache line is evicted.</li>
                                                <li><strong>Write allocate:</strong> Brings the data into cache on write miss.</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="row mt-3">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Cache Performance Metrics</div>
                                        <div class="card-body">
                                            <h5>Key Equations:</h5>
                                            <div class="alert alert-secondary">
                                                <p><strong>Average Memory Access Time (AMAT):</strong></p>
                                                <p>AMAT = Hit Time + Miss Rate × Miss Penalty</p>
                                                <p><small>Where:<br>
                                                Hit Time = 1-4 cycles (L1)<br>
                                                Miss Penalty = 10-200 cycles (DRAM access)</small></p>
                                            </div>
                    
                                            <h5>Miss Rate Components:</h5>
                                            <table class="table table-sm">
                                                <tr>
                                                    <th>Miss Type</th>
                                                    <th>% in Typical Workload</th>
                                                    <th>Reduction Technique</th>
                                                </tr>
                                                <tr>
                                                    <td>Compulsory (Cold)</td>
                                                    <td>5-10%</td>
                                                    <td>Prefetching</td>
                                                </tr>
                                                <tr>
                                                    <td>Capacity</td>
                                                    <td>30-50%</td>
                                                    <td>Larger cache/block size</td>
                                                </tr>
                                                <tr>
                                                    <td>Conflict</td>
                                                    <td>20-40%</td>
                                                    <td>Higher associativity</td>
                                                </tr>
                                            </table>
                                        </div>
                                    </div>
                                </div>
                    
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Advanced Optimization Techniques</div>
                                        <div class="card-body">
                                            <h5>Hardware Prefetching:</h5>
                                            <ul>
                                                <li><strong>Stream Buffers:</strong> Detect sequential patterns</li>
                                                <li><strong>Stride Prediction:</strong> Track regular intervals (e.g., array access)</li>
                                                <li><strong>ML-Based:</strong> Neural network predictors</li>
                                            </ul>
                    
                                            <h5 class="mt-4">Cache Replacement Policies:</h5>
                                            <table class="table table-sm">
                                                <tr>
                                                    <th>Policy</th>
                                                    <th>Implementation Cost</th>
                                                    <th>Hit Rate Improvement</th>
                                                </tr>
                                                <tr>
                                                    <td>LRU</td>
                                                    <td>High (timestamp per line)</td>
                                                    <td>15-20% over random</td>
                                                </tr>
                                                <tr>
                                                    <td>PLRU</td>
                                                    <td>Medium (tree of bits)</td>
                                                    <td>10-15% over random</td>
                                                </tr>
                                                <tr>
                                                    <td>ARC</td>
                                                    <td>High (adaptive)</td>
                                                    <td>25-30% over LRU</td>
                                                </tr>
                                            </table>
                    
                                            <div class="alert alert-warning mt-3">
                                                <h5>Case Study: Intel ADL Cache Hierarchy</h5>
                                                <ul>
                                                    <li>L1D: 48KB, 12-way, 4 cycles</li>
                                                    <li>L2: 1.25MB, 20-way, 14 cycles</li>
                                                    <li>MLC: 3MB shared, 24-way</li>
                                                    <li>Advanced prefetchers: IP, spatial, stride</li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Modern Cache Architectures</div>
                                        <div class="card-body">
                                            <div class="row">
                                                <div class="col-md-4">
                                                    <h5>Non-Uniform Cache:</h5>
                                                    <ul>
                                                        <li>NUCA: Physical distribution</li>
                                                        <li>vNUCA: OS-managed partitioning</li>
                                                    </ul>
                                                </div>
                                                <div class="col-md-4">
                                                    <h5>Specialized Caches:</h5>
                                                    <ul>
                                                        <li>Victim caches (Jouppi, 1990)</li>
                                                        <li>Filter caches (Kin et al.)</li>
                                                        <li>Domain-specific caches (GPU, AI)</li>
                                                    </ul>
                                                </div>
                                                <div class="col-md-4">
                                                    <h5>Emerging Technologies:</h5>
                                                    <ul>
                                                        <li>3D stacked DRAM caches</li>
                                                        <li>Persistent memory caches</li>
                                                        <li>Optical cache interconnects</li>
                                                    </ul>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('3.6')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('3.8')">Next</button>
                        </div>
                    </div>
                    

                    <!-- Slide 3.8: Virtual Memory -->
                    <div class="slide" id="slide-3.8">
                        <h2 class="slide-title">Virtual Memory</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">What is Virtual Memory?</div>
                                        <div class="card-body">
                                            <p>Virtual memory is a memory management technique that provides an "idealized abstraction of the storage resources that are actually available on a given machine," which creates the illusion to users of a very large (main) memory.</p>
                                            
                                            <h5>Key Concepts:</h5>
                                            <ul>
                                                <li><strong>Page Tables:</strong> Map virtual addresses to physical addresses.</li>
                                                <li><strong>Pages:</strong> Fixed-size blocks of virtual memory.</li>
                                                <li><strong>Segmentation:</strong> Division of memory into segments for modular storage.</li>
                                            </ul>
                    
                                            <h5>Page Faults:</h5>
                                            <p>A page fault occurs when a program accesses data not currently in physical memory, causing the OS to fetch the required page from disk storage into RAM.</p>
                                        </div>
                                    </div>
                                </div>
                    
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Virtual Memory Management</div>
                                        <div class="card-body">
                                            <h5>Memory Protection:</h5>
                                            <p>Virtual memory allows the OS to protect memory between different processes, ensuring that one process cannot access or modify the memory of another process.</p>
                    
                                            <h5>Swapping:</h5>
                                            <p>Swapping is a mechanism that allows the OS to move processes between main memory and disk storage, enabling multitasking even when RAM is full.</p>
                    
                                            <h5>Benefits of Virtual Memory:</h5>
                                            <ul>
                                                <li><strong>Isolation:</strong> Prevents direct access between processes.</li>
                                                <li><strong>Efficient Use of RAM:</strong> Allows larger applications to run even with limited physical memory.</li>
                                                <li><strong>Improved Multitasking:</strong> Enables multiple applications to run concurrently without interference.</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Virtual Memory Performance</div>
                                        <div class="card-body">
                                            <h5>Thrashing:</h5>
                                            <p>Thrashing occurs when the system spends more time swapping pages in and out of memory than executing the actual programs. It leads to severe performance degradation.</p>
                    
                                            <h5>TLBs (Translation Lookaside Buffers):</h5>
                                            <p>TLBs are specialized caches used to store recent page table entries to speed up address translation.</p>
                    
                                            <h5>Working Set:</h5>
                                            <p>The working set refers to the set of pages that a process is actively using. If the working set exceeds the available physical memory, page faults will occur more frequently, leading to poor performance.</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="row mt-3">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Virtual Memory Fundamentals</div>
                                        <div class="card-body">
                                            <h5>Address Translation:</h5>
                                            <div class="text-center">
                                                <svg width="100%" height="120" viewBox="0 0 300 120">
                                                    <rect x="10" y="30" width="120" height="30" fill="#bbdefb" stroke="#0d47a1"/>
                                                    <text x="70" y="50" text-anchor="middle">Virtual Address</text>
                                                    <path d="M130 45 L160 45" stroke="#333" marker-end="url(#arrow)"/>
                                                    <rect x="160" y="10" width="120" height="90" fill="#e1f5fe" stroke="#0288d1"/>
                                                    <text x="220" y="30" text-anchor="middle">MMU</text>
                                                    <text x="220" y="60" text-anchor="middle" font-size="10">Page Tables</text>
                                                    <text x="220" y="80" text-anchor="middle" font-size="10">TLB</text>
                                                    <path d="M280 45 L310 45" stroke="#333" marker-end="url(#arrow)"/>
                                                    <rect x="310" y="30" width="120" height="30" fill="#c8e6c9" stroke="#2e7d32"/>
                                                    <text x="370" y="50" text-anchor="middle">Physical Address</text>
                                                </svg>
                                            </div>
                    
                                            <h5 class="mt-3">Page Table Structures:</h5>
                                            <ul>
                                                <li><strong>Hierarchical:</strong> 4-level x86-64 (PML4 → PDP → PD → PT)</li>
                                                <li><strong>Hashed:</strong> Used in PowerPC</li>
                                                <li><strong>Inverted:</strong> Physical → Virtual mapping</li>
                                            </ul>
                    
                                            <div class="alert alert-info mt-3">
                                                <p><strong>Typical Page Sizes:</strong></p>
                                                <ul>
                                                    <li>4KB (standard)</li>
                                                    <li>2MB/1GB (huge pages)</li>
                                                    <li>16KB/64KB (ARM variants)</li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                    
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Translation Lookaside Buffer (TLB)</div>
                                        <div class="card-body">
                                            <h5>TLB Characteristics:</h5>
                                            <table class="table table-sm">
                                                <tr>
                                                    <th>Level</th>
                                                    <th>Entries</th>
                                                    <th>Latency</th>
                                                    <th>Associativity</th>
                                                </tr>
                                                <tr>
                                                    <td>L1 TLB</td>
                                                    <td>64-128</td>
                                                    <td>1 cycle</td>
                                                    <td>Fully associative</td>
                                                </tr>
                                                <tr>
                                                    <td>L2 TLB</td>
                                                    <td>512-2048</td>
                                                    <td>5-10 cycles</td>
                                                    <td>4-8 way</td>
                                                </tr>
                                            </table>
                    
                                            <h5 class="mt-3">TLB Miss Handling:</h5>
                                            <ol>
                                                <li>Hardware page table walk (x86)</li>
                                                <li>Software handler (MIPS, ARM)</li>
                                                <li>Prefetching (adjacent entries)</li>
                                            </ol>
                    
                                            <div class="alert alert-warning mt-3">
                                                <h5>Modern VM Features:</h5>
                                                <ul>
                                                    <li>ASID (Address Space ID)</li>
                                                    <li>Nested paging (AMD-V, EPT)</li>
                                                    <li>Memory compression (zswap)</li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Advanced Virtual Memory</div>
                                        <div class="card-body">
                                            <div class="row">
                                                <div class="col-md-4">
                                                    <h5>Page Replacement:</h5>
                                                    <ul>
                                                        <li>CLOCK algorithm</li>
                                                        <li>Working Set tracking</li>
                                                        <li>ML-based predictors</li>
                                                    </ul>
                                                </div>
                                                <div class="col-md-4">
                                                    <h5>Optimizations:</h5>
                                                    <ul>
                                                        <li>Superpages (contiguous PTEs)</li>
                                                        <li>TLB coalescing</li>
                                                        <li>Speculative translation</li>
                                                    </ul>
                                                </div>
                                                <div class="col-md-4">
                                                    <h5>Security:</h5>
                                                    <ul>
                                                        <li>ASLR (Address randomization)</li>
                                                        <li>SMAP/SMEP protection</li>
                                                        <li>Memory tagging (ARM MTE)</li>
                                                    </ul>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('3.7')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('3.9')">Next</button>
                        </div>
                    </div>
                    

                    <!-- Slide 3.9: External Memory -->
                    <div class="slide" id="slide-3.9">
                        <h2 class="slide-title">External Memory</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">What is External Memory?</div>
                                        <div class="card-body">
                                            <p>External memory refers to any non-volatile storage medium that is outside the main memory of a computer. It includes devices like hard drives, SSDs, optical drives, and USB flash drives.</p>
                    
                                            <h5>Key Types of External Memory:</h5>
                                            <ul>
                                                <li><strong>Hard Disk Drives (HDD):</strong> Magnetic storage, known for larger capacities but slower speeds.</li>
                                                <li><strong>Solid State Drives (SSD):</strong> Faster than HDDs, uses flash memory for storage.</li>
                                                <li><strong>Optical Discs:</strong> CD/DVD storage for long-term data archiving.</li>
                                            </ul>
                    
                                            <h5>Access Time:</h5>
                                            <p>External memory typically has much higher latency compared to internal memory. SSDs are significantly faster than HDDs in terms of data access time.</p>
                                        </div>
                                    </div>
                                </div>
                    
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">External Memory Characteristics</div>
                                        <div class="card-body">
                                            <h5>Capacity:</h5>
                                            <p>External memory is typically used for large-scale data storage. HDDs can range from several GB to multiple TBs, while SSDs are rapidly increasing in storage size.</p>
                    
                                            <h5>Reliability:</h5>
                                            <p>HDDs are more prone to mechanical failure due to their moving parts, whereas SSDs, which have no moving parts, are more durable but still can fail due to flash wear over time.</p>
                    
                                            <h5>Data Transfer Speed:</h5>
                                            <ul>
                                                <li><strong>HDD:</strong> Slower, with typical read/write speeds of around 100 MB/s.</li>
                                                <li><strong>SSD:</strong> Much faster, with read/write speeds of up to 550 MB/s for SATA SSDs and 3500 MB/s for NVMe SSDs.</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">External Memory in Systems</div>
                                        <div class="card-body">
                                            <h5>Role in File Systems:</h5>
                                            <p>External memory devices often serve as the primary storage medium in systems, storing operating systems, applications, and user data. They are integral to file systems, which manage data storage and retrieval.</p>
                    
                                            <h5>Backup and Recovery:</h5>
                                            <p>External memory is commonly used for creating backups and archiving data to ensure that data is not lost in case of system failure.</p>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="row mt-3">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Storage Technologies</div>
                                        <div class="card-body">
                                            <h5>Magnetic Storage:</h5>
                                            <ul>
                                                <li><strong>HDD:</strong> 2-20TB, 5-15ms seek, 150-300MB/s</li>
                                                <li><strong>Shingled:</strong> 20-30% higher density</li>
                                                <li><strong>HAMR:</strong> Heat-assisted recording</li>
                                            </ul>
                    
                                            <h5 class="mt-3">Flash Memory:</h5>
                                            <table class="table table-sm">
                                                <tr>
                                                    <th>Type</th>
                                                    <th>Bits/Cell</th>
                                                    <th>Endurance</th>
                                                    <th>Cost/GB</th>
                                                </tr>
                                                <tr>
                                                    <td>SLC</td>
                                                    <td>1</td>
                                                    <td>100K</td>
                                                    <td>$$$$</td>
                                                </tr>
                                                <tr>
                                                    <td>MLC</td>
                                                    <td>2</td>
                                                    <td>10K</td>
                                                    <td>$$</td>
                                                </tr>
                                                <tr>
                                                    <td>QLC</td>
                                                    <td>4</td>
                                                    <td>1K</td>
                                                    <td>$</td>
                                                </tr>
                                            </table>
                    
                                            <div class="alert alert-info mt-3">
                                                <h5>Emerging Technologies:</h5>
                                                <ul>
                                                    <li>Optane (3D XPoint)</li>
                                                    <li>MRAM storage class memory</li>
                                                    <li>DNA storage (experimental)</li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                    
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Interfaces & Performance</div>
                                        <div class="card-body">
                                            <h5>Storage Interfaces:</h5>
                                            <table class="table table-sm">
                                                <tr>
                                                    <th>Interface</th>
                                                    <th>Bandwidth</th>
                                                    <th>Latency</th>
                                                </tr>
                                                <tr>
                                                    <td>SATA III</td>
                                                    <td>600MB/s</td>
                                                    <td>50-100μs</td>
                                                </tr>
                                                <tr>
                                                    <td>NVMe PCIe 4.0</td>
                                                    <td>8GB/s</td>
                                                    <td>10-20μs</td>
                                                </tr>
                                                <tr>
                                                    <td>NVMe-oF</td>
                                                    <td>100GbE</td>
                                                    <td>100μs</td>
                                                </tr>
                                            </table>
                    
                                            <h5 class="mt-3">Performance Factors:</h5>
                                            <ul>
                                                <li><strong>4K Random IOPS:</strong> 50K-1M for NVMe</li>
                                                <li><strong>Write Amplification:</strong> 1.1-5x (depends on workload)</li>
                                                <li><strong>GC Overhead:</strong> 5-15% performance impact</li>
                                            </ul>
                    
                                            <div class="alert alert-warning mt-3">
                                                <h5>Enterprise Features:</h5>
                                                <ul>
                                                    <li>Multi-stream writes</li>
                                                    <li>Zoned namespaces</li>
                                                    <li>Persistent memory support</li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('3.8')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('3.10')">Next</button>
                        </div>
                    </div>
                    

                    <!-- Slide 3.10: RAID Levels -->
                    <div class="slide" id="slide-3.10">
                        <h2 class="slide-title">RAID Levels</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">What is RAID?</div>
                                        <div class="card-body">
                                            <p>RAID (Redundant Array of Independent Disks) is a data storage virtualization technology that combines multiple physical disk drive components into one or more logical units to improve performance, data redundancy, or both.</p>
                    
                                            <h5>RAID Levels Overview:</h5>
                                            <ul>
                                                <li><strong>RAID 0:</strong> Striping, no redundancy, improves performance.</li>
                                                <li><strong>RAID 1:</strong> Mirroring, duplicates data on two drives, provides redundancy.</li>
                                                <li><strong>RAID 5:</strong> Striping with parity, provides redundancy with better storage efficiency.</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                    
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">RAID 0, 1, 5</div>
                                        <div class="card-body">
                                            <h5>RAID 0:</h5>
                                            <p>RAID 0 splits data into blocks and writes them across all drives. It offers high performance but no redundancy, meaning data is lost if one drive fails.</p>
                    
                                            <h5>RAID 1:</h5>
                                            <p>RAID 1 mirrors data across two drives. It provides redundancy but has a 50% storage overhead.</p>
                    
                                            <h5>RAID 5:</h5>
                                            <p>RAID 5 combines striping with parity data distributed across all drives. It offers redundancy with only one drive's worth of parity and is common in enterprise environments.</p>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Other RAID Levels</div>
                                        <div class="card-body">
                                            <h5>RAID 6:</h5>
                                            <p>RAID 6 is similar to RAID 5 but with double parity, allowing for the failure of two drives. It provides higher fault tolerance but lower write performance.</p>
                    
                                            <h5>RAID 10:</h5>
                                            <p>RAID 10 is a combination of RAID 1 and RAID 0, offering both redundancy and improved performance.</p>
                    
                                            <h5>RAID 50 and 60:</h5>
                                            <p>RAID 50 combines RAID 5 and RAID 0, while RAID 60 combines RAID 6 and RAID 0, providing both redundancy and performance but at the cost of increased complexity.</p>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-primary text-white">RAID Level Comparison</div>
                                        <div class="card-body">
                                            <table class="table table-bordered">
                                                <thead class="thead-dark">
                                                    <tr>
                                                        <th>Level</th>
                                                        <th>Description</th>
                                                        <th>Min Disks</th>
                                                        <th>Fault Tolerance</th>
                                                        <th>Read Perf</th>
                                                        <th>Write Perf</th>
                                                        <th>Efficiency</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    <tr>
                                                        <td><strong>RAID 0</strong></td>
                                                        <td>Striping</td>
                                                        <td>2</td>
                                                        <td>None</td>
                                                        <td>Excellent</td>
                                                        <td>Excellent</td>
                                                        <td>100%</td>
                                                    </tr>
                                                    <tr>
                                                        <td><strong>RAID 1</strong></td>
                                                        <td>Mirroring</td>
                                                        <td>2</td>
                                                        <td>1 disk</td>
                                                        <td>Excellent</td>
                                                        <td>Good</td>
                                                        <td>50%</td>
                                                    </tr>
                                                    <tr>
                                                        <td><strong>RAID 5</strong></td>
                                                        <td>Striped parity</td>
                                                        <td>3</td>
                                                        <td>1 disk</td>
                                                        <td>Good</td>
                                                        <td>Fair</td>
                                                        <td>(N-1)/N</td>
                                                    </tr>
                                                    <tr>
                                                        <td><strong>RAID 6</strong></td>
                                                        <td>Dual parity</td>
                                                        <td>4</td>
                                                        <td>2 disks</td>
                                                        <td>Good</td>
                                                        <td>Poor</td>
                                                        <td>(N-2)/N</td>
                                                    </tr>
                                                    <tr>
                                                        <td><strong>RAID 10</strong></td>
                                                        <td>Mirrored stripes</td>
                                                        <td>4</td>
                                                        <td>1 per mirror</td>
                                                        <td>Excellent</td>
                                                        <td>Good</td>
                                                        <td>50%</td>
                                                    </tr>
                                                </tbody>
                                            </table>
                    
                                            <div class="alert alert-info mt-3">
                                                <h5>Advanced RAID Concepts:</h5>
                                                <div class="row">
                                                    <div class="col-md-4">
                                                        <p><strong>Distributed Parity:</strong> RAID 5/6 parity rotation</p>
                                                    </div>
                                                    <div class="col-md-4">
                                                        <p><strong>Rebuild Impact:</strong> RAID 5 URE risk during rebuild</p>
                                                    </div>
                                                    <div class="col-md-4">
                                                        <p><strong>Hybrid RAID:</strong> SSD caching + HDD arrays</p>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <div class="row mt-3">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">RAID Implementation</div>
                                        <div class="card-body">
                                            <h5>Controller Types:</h5>
                                            <ul>
                                                <li><strong>Hardware:</strong> Dedicated ASIC, battery-backed cache</li>
                                                <li><strong>Software:</strong> OS-based (mdadm, ZFS, Storage Spaces)</li>
                                                <li><strong>Hybrid:</strong> HBA with offload</li>
                                            </ul>
                    
                                            <h5 class="mt-3">Failure Modes:</h5>
                                            <ul>
                                                <li>Write hole (power loss during update)</li>
                                                <li>Silent data corruption</li>
                                                <li>Rebuild stress on remaining disks</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                    
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-warning text-white">Enterprise RAID Features</div>
                                        <div class="card-body">
                                            <h5>Advanced Capabilities:</h5>
                                            <ul>
                                                <li>Online capacity expansion</li>
                                                <li>Tiered storage (SSD+HDD)</li>
                                                <li>Auto-tiering based on access</li>
                                                <li>Remote replication</li>
                                            </ul>
                    
                                            <div class="alert alert-secondary mt-3">
                                                <p><strong>Case Study:</strong> NetApp's RAID-DP uses double parity with specialized WAFL filesystem for 40PB+ systems</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('3.9')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('4.1')">Next</button>
                        </div>
                    </div>
                    

                                        
                    <!-- Slide 4.1: Instruction Formats -->
                    <div class="slide" id="slide-4.1">
                        <h2 class="slide-title">Instruction Formats</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">What are Instruction Formats?</div>
                                        <div class="card-body">
                                            <p>Instruction formats define the structure and layout of machine instructions in a computer's architecture. They specify how bits are organized to represent operations, operands, and addressing information.</p>

                                            <h5>Key Components of Instructions:</h5>
                                            <ul>
                                                <li><strong>Opcode (Operation Code):</strong> Specifies the operation to be performed (ADD, SUB, LOAD, etc.)</li>
                                                <li><strong>Operand Specifiers:</strong> Identify the data to be manipulated</li>
                                                <li><strong>Mode Specifiers:</strong> Indicate how operands are to be interpreted</li>
                                            </ul>

                                            <h5>Instruction Length:</h5>
                                            <p>Instructions can be fixed-length (e.g., 32 bits in ARM) or variable-length (e.g., x86 ranges from 1 to 15 bytes). Fixed-length instructions simplify processor design but may waste space, while variable-length instructions improve code density but increase decoding complexity.</p>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Common Instruction Formats</div>
                                        <div class="card-body">
                                            <h5>Three-Address Format:</h5>
                                            <p><code>ADD R1, R2, R3</code> (R1 ← R2 + R3)</p>
                                            <p>Allows direct specification of two source operands and a separate destination. Common in RISC architectures like ARM and RISC-V.</p>

                                            <h5>Two-Address Format:</h5>
                                            <p><code>ADD R1, R2</code> (R1 ← R1 + R2)</p>
                                            <p>One operand serves as both source and destination. Common in x86 architecture.</p>

                                            <h5>One-Address Format:</h5>
                                            <p><code>ADD R1</code> (ACC ← ACC + R1)</p>
                                            <p>Uses an implicit accumulator for one operand and result. Common in early processors and some microcontrollers.</p>

                                            <h5>Zero-Address Format:</h5>
                                            <p><code>ADD</code> (TOS-1 ← TOS-1 + TOS, pop)</p>
                                            <p>Stack-based operations where operands are implicitly on top of stack. Used in Java Virtual Machine.</p>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Modern Instruction Format Examples</div>
                                        <div class="card-body">
                                            <h5>ARM A64 (AArch64) Instruction Format:</h5>
                                            <div class="row">
                                                <div class="col-md-8">
                                                    <p>Fixed 32-bit instruction length with consistent field arrangement:</p>
                                                    <pre style="font-family: monospace; white-space: pre-wrap; word-wrap: break-word;">
31      25 24      20 19      15 14     10 9        0
|  Opcode  |   Rm/imm  |    Rn    |    Rd   |   Additional  |
        </pre>
                                                    <p>Where Rn, Rm are source registers, Rd is destination register.</p>
                                            
                                                    <!-- Description of each field -->
                                                    <ul>
                                                        <li><strong>Opcode:</strong> Bits 31-25 represent the operation code (e.g., ADD, SUB, etc.).</li>
                                                        <li><strong>Rm/imm:</strong> Bits 24-20 represent either the source register (Rm) or immediate value (depending on the instruction type).</li>
                                                        <li><strong>Rn:</strong> Bits 19-15 represent the source register (Rn).</li>
                                                        <li><strong>Rd:</strong> Bits 14-10 represent the destination register (Rd).</li>
                                                        <li><strong>Additional:</strong> Bits 9-0 may include additional flags or fields depending on the specific instruction.</li>
                                                    </ul>
                                                </div>
                                                <div class="col-md-4">
                                                    <div class="alert alert-info">
                                                        <strong>Example:</strong><br>
                                                        <code>ADD X0, X1, X2</code><br>
                                                        Adds the contents of 64-bit registers X1 and X2, storing the result in X0.
                                                    </div>
                                                </div>
                                            </div>
                                            
                                            <h5 class="mt-3">x86-64 Instruction Format:</h5>
                                            <div class="row">
                                                <div class="col-md-8">
                                                    <p>Variable-length format (1-15 bytes) with multiple prefixes and complex encoding:</p>
                                                    <pre style="font-family: monospace; white-space: pre-wrap; word-wrap: break-word;">
|   Prefixes   | Opcode | ModR/M | SIB | Displacement | Immediate |
0-4 bytes     1-3 B    0-1 B   0-1 B    0-4 bytes      0-4 bytes
        </pre>
                                                    <p>This complex format supports extensive backward compatibility while allowing new extensions.</p>
                                            
                                                    <!-- Description of each field for x86-64 -->
                                                    <ul>
                                                        <li><strong>Prefixes:</strong> The first 1-4 bytes represent optional prefixes that modify the operation (e.g., segment overrides, operand size, address size).</li>
                                                        <li><strong>Opcode:</strong> The next 1-3 bytes represent the operation code for the instruction (e.g., ADD, MOV, etc.).</li>
                                                        <li><strong>ModR/M:</strong> A 1-byte field that encodes the addressing mode and registers used in the instruction.</li>
                                                        <li><strong>SIB (Scale-Index-Base):</strong> An optional 1-byte field used in complex memory addressing modes.</li>
                                                        <li><strong>Displacement:</strong> 0-4 bytes that represent a constant value added to the effective address (for memory accesses).</li>
                                                        <li><strong>Immediate:</strong> 0-4 bytes that represent a constant value directly used by the instruction (e.g., in an ADD immediate operation).</li>
                                                    </ul>
                                                </div>
                                                <div class="col-md-4">
                                                    <div class="alert alert-warning">
                                                        <strong>Modern Complexity:</strong><br>
                                                        Modern x86 processors translate complex CISC instructions into simpler micro-operations (μops) internally, combining the benefits of CISC and RISC architectures.
                                                    </div>
                                                </div>
                                            </div>
                                            
                                            
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('3.10')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('4.2')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 4.2: Instruction Sets -->
                    <div class="slide" id="slide-4.2">
                        <h2 class="slide-title">Instruction Sets</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">What is an Instruction Set?</div>
                                        <div class="card-body">
                                            <p>An Instruction Set Architecture (ISA) defines the complete set of instructions that a processor can execute, forming the interface between hardware and software. It includes opcodes, registers, memory addressing, and data types supported by the architecture.</p>

                                            <h5>Major Categories of Instructions:</h5>
                                            <ul>
                                                <li><strong>Data Movement:</strong> Load, store, move between registers</li>
                                                <li><strong>Arithmetic/Logic:</strong> Add, subtract, AND, OR, XOR, etc.</li>
                                                <li><strong>Control Flow:</strong> Branch, jump, call, return</li>
                                                <li><strong>System:</strong> Privileged operations, interrupts</li>
                                                <li><strong>SIMD/Vector:</strong> Parallel data operations</li>
                                            </ul>

                                            <h5>ISA Classifications:</h5>
                                            <p>ISAs are typically classified as CISC (Complex Instruction Set Computer) or RISC (Reduced Instruction Set Computer), though modern designs often blend characteristics of both.</p>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Major Commercial ISAs</div>
                                        <div class="card-body">
                                            <h5>x86-64 (AMD64/Intel64):</h5>
                                            <p>CISC architecture dominating desktop and server markets. Features variable-length instructions and a large instruction set with complex addressing modes. Includes extensive SIMD extensions (SSE, AVX, AVX-512).</p>

                                            <h5>ARM (AArch64):</h5>
                                            <p>RISC architecture dominant in mobile devices and increasingly common in servers and laptops (Apple M1/M2/M3). Features fixed-length instructions, load-store architecture, and energy efficiency focus.</p>

                                            <h5>RISC-V:</h5>
                                            <p>Open-source RISC architecture gaining traction in embedded systems, academia, and increasingly in commercial products. Modular design with base ISA and optional extensions.</p>

                                            <div class="alert alert-info mt-3">
                                                <p><strong>ISA Evolution:</strong> Modern ISAs continually evolve with new extensions for specialized tasks like AI (AVX-512 for x86, SVE for ARM), cryptography, and virtualization support.</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Instruction Set Comparison</div>
                                        <div class="card-body">
                                            <table class="table table-bordered">
                                                <thead class="thead-dark">
                                                    <tr>
                                                        <th>Feature</th>
                                                        <th>x86-64</th>
                                                        <th>ARM AArch64</th>
                                                        <th>RISC-V (RV64G)</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    <tr>
                                                        <td><strong>Instruction Length</strong></td>
                                                        <td>Variable (1-15 bytes)</td>
                                                        <td>Fixed (4 bytes)</td>
                                                        <td>Fixed (4 bytes, with compressed options)</td>
                                                    </tr>
                                                    <tr>
                                                        <td><strong>General Registers</strong></td>
                                                        <td>16 general purpose 64-bit registers</td>
                                                        <td>31 general purpose 64-bit registers</td>
                                                        <td>31 general purpose 64-bit registers</td>
                                                    </tr>
                                                    <tr>
                                                        <td><strong>Memory Addressing</strong></td>
                                                        <td>Complex with many modes</td>
                                                        <td>Load-store with simpler addressing</td>
                                                        <td>Load-store with minimal addressing modes</td>
                                                    </tr>
                                                    <tr>
                                                        <td><strong>SIMD Extensions</strong></td>
                                                        <td>SSE, AVX, AVX-512 (up to 512-bit)</td>
                                                        <td>NEON, SVE (scalable to 2048-bit)</td>
                                                        <td>V extension (scalable vectors)</td>
                                                    </tr>
                                                    <tr>
                                                        <td><strong>Specialized Features</strong></td>
                                                        <td>AI (AMX), Crypto (AES-NI), Virt. (VT-x)</td>
                                                        <td>AI (MatMul), Crypto, Virt. extensions</td>
                                                        <td>Modular extensions as needed</td>
                                                    </tr>
                                                </tbody>
                                            </table>

                                            <div class="row mt-3">
                                                <div class="col-md-6">
                                                    <div class="alert alert-warning">
                                                        <h5>Modern Trends in ISAs:</h5>
                                                        <ul>
                                                            <li><strong>Specialization:</strong> Domain-specific extensions for AI, cryptography, etc.</li>
                                                            <li><strong>Vector Processing:</strong> Scalable vector extensions becoming standard</li>
                                                            <li><strong>Security Features:</strong> Memory protection, trusted execution environments</li>
                                                        </ul>
                                                    </div>
                                                </div>
                                                <div class="col-md-6">
                                                    <div class="alert alert-info">
                                                        <h5>Real-World Example:</h5>
                                                        <p>Apple's transition from x86-64 to ARM-based Apple Silicon demonstrates the growing importance of ISA choice. The M1/M2/M3 processors deliver superior performance-per-watt by leveraging ARM's RISC design principles combined with specialized hardware accelerators.</p>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('4.1')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('4.3')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 4.3: Addressing Modes -->
                    <div class="slide" id="slide-4.3">
                        <h2 class="slide-title">Addressing Modes</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">What are Addressing Modes?</div>
                                        <div class="card-body">
                                            <p>Addressing modes define the methods by which operands (data) are located for instructions. They determine how the processor calculates the effective address of an operand.</p>

                                            <h5>Importance of Addressing Modes:</h5>
                                            <ul>
                                                <li>Enable flexible access to data in memory and registers</li>
                                                <li>Support different data structures (arrays, records, stacks)</li>
                                                <li>Affect code size and execution performance</li>
                                                <li>Influence programming model complexity</li>
                                            </ul>

                                            <h5>Addressing Mode Considerations:</h5>
                                            <p>RISC architectures typically feature fewer addressing modes for simplicity, while CISC architectures often include many modes for flexibility and code density.</p>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Fundamental Addressing Modes</div>
                                        <div class="card-body">
                                            <h5>Register Addressing:</h5>
                                            <p><code>ADD R1, R2</code> (operand in register)</p>
                                            <p>The operand is contained in a processor register. Fast execution with no memory access required.</p>

                                            <h5>Immediate Addressing:</h5>
                                            <p><code>ADD R1, #42</code> (literal value in instruction)</p>
                                            <p>The operand is a constant value embedded in the instruction itself.</p>

                                            <h5>Direct/Absolute Addressing:</h5>
                                            <p><code>LOAD R1, [0x8000]</code> (fixed memory address)</p>
                                            <p>The instruction contains the complete memory address of the operand.</p>

                                            <h5>Indirect Addressing:</h5>
                                            <p><code>LOAD R1, [R2]</code> (address in register)</p>
                                            <p>A register contains the memory address of the operand.</p>
                                            
                                            <h5>Indexed Addressing:</h5>
                                            <p><code>LOAD R1, [R2+R3]</code> (base + index registers)</p>
                                            <p>The operand's address is calculated by adding an index to a base address.</p>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Advanced Addressing Modes &amp; Modern Examples</div>
                                        <div class="card-body">
                                            <div class="row">
                                                <div class="col-md-6">
                                                    <h5>More Complex Addressing Modes:</h5>
                                                    <ul>
                                                        <li><strong>Base + Displacement:</strong> <code>LOAD R1, [R2+100]</code>
                                                            <p>Base register plus constant offset, ideal for struct/record access</p>
                                                        </li>
                                                        <li><strong>Pre/Post-Increment/Decrement:</strong> <code>LOAD R1, [R2]+</code> or <code>LOAD R1, -[R2]</code>
                                                            <p>Auto-updates pointer register, perfect for stack and queue operations</p>
                                                        </li>
                                                        <li><strong>Scaled Index:</strong> <code>LOAD R1, [R2+R3*4]</code>
                                                            <p>Base plus index×scale, optimized for array access of different element sizes</p>
                                                        </li>
                                                        <li><strong>PC-Relative:</strong> <code>BRANCH label</code> (PC + offset)
                                                            <p>Address relative to Program Counter, enables position-independent code</p>
                                                        </li>
                                                    </ul>
                                                </div>
                                                <div class="col-md-6">
                                                    <h5>Modern Architecture Examples:</h5>
                                                    <div class="alert alert-info mb-3">
                                                        <h6>x86-64 Addressing:</h6>
                                                        <p><code>mov rax, [rbx + rcx*8 + 0x10]</code></p>
                                                        <p>Combines base (rbx), scaled index (rcx*8), and displacement (0x10), allowing complex data structure access in a single instruction.</p>
                                                    </div>
                                                    
                                                    <div class="alert alert-info mb-3">
                                                        <h6>ARM AArch64 Addressing:</h6>
                                                        <p><code>LDR X0, [X1, X2, LSL #3]</code></p>
                                                        <p>Base register (X1) plus scaled register offset (X2 shifted left by 3 bits), efficient for array access with 8-byte elements.</p>
                                                    </div>
                                                    
                                                    <div class="alert alert-info">
                                                        <h6>RISC-V Addressing:</h6>
                                                        <p><code>LD x10, 24(x11)</code></p>
                                                        <p>Simple base plus 12-bit signed offset (24), reflecting RISC-V's minimalist design philosophy.</p>
                                                    </div>
                                                </div>
                                            </div>

                                            <div class="row mt-3">
                                                <div class="col-md-12">
                                                    <div class="alert alert-warning">
                                                        <h5>Addressing Mode Performance Considerations:</h5>
                                                        <div class="row">
                                                            <div class="col-md-4">
                                                                <p><strong>Memory Hierarchy Impact:</strong> Complex addressing modes can increase memory access latency, but with modern cache hierarchies, this is often mitigated.</p>
                                                            </div>
                                                            <div class="col-md-4">
                                                                <p><strong>Code Density vs. Execution Speed:</strong> Rich addressing modes improve code density but may require more complex instruction decoding.</p>
                                                            </div>
                                                            <div class="col-md-4">
                                                                <p><strong>Modern Optimizations:</strong> Address generation units (AGUs) in modern CPUs parallelize address calculations with other operations.</p>
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('4.2')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('4.4')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 4.4: Assembly Language Examples -->
                    <div class="slide" id="slide-4.4">
                        <h2 class="slide-title">Assembly Language Examples</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Assembly Language Fundamentals</div>
                                        <div class="card-body">
                                            <p>Assembly language is a low-level programming language that provides a symbolic representation of a processor's machine code instructions. It has a one-to-one correspondence with machine instructions but uses mnemonics instead of binary codes.</p>

                                            <h5>Key Components:</h5>
                                            <ul>
                                                <li><strong>Labels:</strong> Symbolic names for memory locations</li>
                                                <li><strong>Opcodes:</strong> Instruction mnemonics (ADD, MOV, JMP)</li>
                                                <li><strong>Operands:</strong> Data or addresses for instructions</li>
                                                <li><strong>Directives:</strong> Assembler instructions (.data, .text)</li>
                                                <li><strong>Comments:</strong> Documentation (often after ; or #)</li>
                                            </ul>

                                            <h5>Assembly Language Relevance Today:</h5>
                                            <p>While most software is written in high-level languages, assembly remains crucial for:</p>
                                            <ul>
                                                <li>Performance-critical code sections</li>
                                                <li>Systems programming and OS kernels</li>
                                                <li>Embedded systems with limited resources</li>
                                                <li>Hardware drivers and low-level interfaces</li>
                                                <li>Reverse engineering and security analysis</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">x86-64 Assembly Example</div>
                                        <div class="card-body">
                                            <h5>Function to Calculate Sum of Array Elements:</h5>
                                            <pre><code>    .text
    .global sum_array
sum_array:
    xor     rax, rax          ; Initialize sum to 0
    test    rsi, rsi          ; Check if count is 0
    jz      done              ; If count is 0, return
loop:
    add     rax, [rdi]        ; Add current element to sum
    add     rdi, 8            ; Move to next element (8 bytes)
    dec     rsi               ; Decrement counter
    jnz     loop              ; If counter not zero, continue
done:
    ret                       ; Return sum in RAX</code></pre>

                                            <div class="alert alert-info mt-3">
                                                <p><strong>Function Signature:</strong> <code>long sum_array(long *array, size_t count)</code></p>
                                                <p><strong>Parameter Passing:</strong> In x86-64 System V ABI:</p>
                                                <ul>
                                                    <li>RDI: First argument (array pointer)</li>
                                                    <li>RSI: Second argument (count)</li>
                                                    <li>RAX: Return value (sum)</li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Modern Assembly Language Examples</div>
                                        <div class="card-body">
                                            <div class="row">
                                                <div class="col-md-6">
                                                    <h5>ARM AArch64 Assembly:</h5>
                                                    <pre><code>    .text
    .global vector_add
vector_add:
    cbz     w2, done        // If count==0, return
    
loop:
    ldr     d0, [x0]        // Load double from first array
    ldr     d1, [x1]        // Load double from second array
    fadd    d0, d0, d1      // Floating-point addition
    str     d0, [x0]        // Store result back to first array
    add     x0, x0, #8      // Increment first array pointer
    add     x1, x1, #8      // Increment second array pointer
    subs    w2, w2, #1      // Decrement count
    b.ne    loop            // Loop if not done
    
done:
    ret</code></pre>
                                                    <p>This function adds elements from two double arrays, storing the result in the first array.</p>
                                                </div>
                                                <div class="col-md-6">
                                                    <h5>RISC-V Assembly:</h5>
                                                    <pre><code>    .text
    .global string_length
string_length:
    li      a1, 0           # Initialize length counter to 0
    
loop:
    lb      t0, 0(a0)       # Load byte from string
    beqz    t0, done        # If byte is zero, end of string
    addi    a0, a0, 1       # Increment string pointer
    addi    a1, a1, 1       # Increment length counter
    j       loop            # Continue loop
    
done:
    mv      a0, a1          # Move length to return register
    ret</code></pre>
                                                    <p>A simple function that calculates the length of a null-terminated string.</p>
                                                </div>
                                            </div>

                                            <div class="row mt-4">
                                                <div class="col-md-12">
                                                    <h5>Advanced Assembly Example: SIMD Vector Processing (x86-64 AVX)</h5>
                                                    <pre><code>    .text
    .global avx_vector_multiply
avx_vector_multiply:
    ; RDI = float *result, RSI = float *a, RDX = float *b, RCX = int count
    xor     rax, rax              ; Initialize processed count
    
loop:
    cmp     rax, rcx              ; Check if we've processed all elements
    jge     done                  ; If so, exit
    
    vmovups ymm0, [rsi + rax*4]   ; Load 8 floats from array a
    vmovups ymm1, [rdx + rax*4]   ; Load 8 floats from array b
    vmulps  ymm2, ymm0, ymm1      ; Multiply 8 pairs in parallel
    vmovups [rdi + rax*4], ymm2   ; Store 8 results
    
    add     rax, 8                ; Increment counter by 8 (processed 8 elements)
    jmp     loop                  ; Repeat
    
done:
    ret</code></pre>
                                                    <div class="alert alert-warning mt-3">
                                                        <h5>Modern Assembly Features:</h5>
                                                        <div class="row">
                                                            <div class="col-md-4">
                                                                <p><strong>SIMD Instructions:</strong> Process multiple data elements in parallel (AVX/NEON/SVE)</p>
                                                            </div>
                                                            <div class="col-md-4">
                                                                <p><strong>Specialized Instructions:</strong> Hardware-accelerated operations for crypto, compression, AI</p>
                                                            </div>
                                                            <div class="col-md-4">
                                                                <p><strong>Compiler Integration:</strong> Inline assembly in C/C++ with constraints and optimization hints</p>
                                                            </div>
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('4.3')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('4.5')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 4.5: Processor Organization -->
                    <!-- Slide 4.5: Processor Organization -->
                    <div class="slide" id="slide-4.5">
                        <h2 class="slide-title">Processor Organization</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Processor Architecture Fundamentals</div>
                                        <div class="card-body">
                                            <p>Processor organization refers to the internal structure and design of a CPU, encompassing how its components are arranged and interconnected to execute instructions efficiently.</p>

                                            <h5>Core Components:</h5>
                                            <ul>
                                                <li><strong>Control Unit (CU):</strong> Coordinates the sequencing of operations, manages instruction fetch and decode, and controls other CPU components</li>
                                                <li><strong>Arithmetic Logic Unit (ALU):</strong> Performs mathematical and logical operations</li>
                                                <li><strong>Registers:</strong> Fast, small storage locations within the CPU</li>
                                                <li><strong>Cache Memory:</strong> High-speed memory that bridges the performance gap between CPU and main memory</li>
                                                <li><strong>System Bus:</strong> Communication pathways between CPU components and external memory/devices</li>
                                            </ul>

                                            <h5>Key Organizational Concepts:</h5>
                                            <ul>
                                                <li><strong>Von Neumann Architecture:</strong> Unified memory for both data and instructions</li>
                                                <li><strong>Harvard Architecture:</strong> Separate memory paths for instructions and data</li>
                                                <li><strong>Modified Harvard:</strong> Hybrid approach with separate caches but unified main memory</li>
                                                <li><strong>Multi-core:</strong> Multiple processing cores on a single chip</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Modern Processor Organization</div>
                                        <div class="card-body">
                                            <h5>Contemporary CPU Components:</h5>
                                            <ul>
                                                <li><strong>Front-End:</strong> Instruction fetch, decode, and branch prediction</li>
                                                <li><strong>Execution Engine:</strong> Includes ALUs, FPUs, and specialized execution units</li>
                                                <li><strong>Memory Subsystem:</strong> Multi-level cache hierarchy and memory controllers</li>
                                                <li><strong>System Agent:</strong> Manages external interfaces like PCIe and memory</li>
                                            </ul>

                                            <div class="alert alert-info mt-3">
                                                <h5>Modern Processor Organization Example: AMD Zen Architecture</h5>
                                                <img src="/api/placeholder/640/320" alt="AMD Zen Architecture" class="img-fluid mb-2" />
                                                <ul>
                                                    <li><strong>Core Complex (CCX):</strong> 4-8 cores with shared L3 cache</li>
                                                    <li><strong>Core Layout:</strong> Split front-end with dedicated instruction cache</li>
                                                    <li><strong>Cache Hierarchy:</strong> L1 (per core), L2 (per core), L3 (shared per CCX)</li>
                                                    <li><strong>Infinity Fabric:</strong> Interconnect between core complexes and I/O</li>
                                                    <li><strong>Specialized Units:</strong> AVX units, branch prediction, memory controllers</li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Advanced Processor Organization Concepts</div>
                                        <div class="card-body">
                                            <div class="row">
                                                <div class="col-md-6">
                                                    <h5>System-on-Chip (SoC) Organization:</h5>
                                                    <p>Modern processors, especially in mobile devices and embedded systems, integrate multiple components on a single chip:</p>
                                                    <ul>
                                                        <li><strong>CPU Cores:</strong> Often heterogeneous (big.LITTLE architecture)</li>
                                                        <li><strong>GPU:</strong> Integrated graphics processing units</li>
                                                        <li><strong>NPU/TPU:</strong> Neural/Tensor Processing Units for AI workloads</li>
                                                        <li><strong>DSP:</strong> Digital Signal Processors for media processing</li>
                                                        <li><strong>Memory Controllers:</strong> DRAM and flash memory interfaces</li>
                                                        <li><strong>I/O Controllers:</strong> USB, PCIe, display, camera, network interfaces</li>
                                                        <li><strong>Security Elements:</strong> Secure enclaves, crypto accelerators</li>
                                                    </ul>
                                                </div>
                                                <div class="col-md-6">
                                                    <h5>Processor Interconnects:</h5>
                                                    <p>Communication fabrics that connect processor components are critical for performance:</p>
                                                    <ul>
                                                        <li><strong>Bus Architectures:</strong> Traditional shared communication pathways</li>
                                                        <li><strong>Ring Bus:</strong> Used in Intel processors to connect cores and cache</li>
                                                        <li><strong>Mesh Networks:</strong> 2D grid of interconnects in many-core processors</li>
                                                        <li><strong>Chiplet Interconnects:</strong> AMD Infinity Fabric, Intel EMIB</li>
                                                        <li><strong>NoC (Network-on-Chip):</strong> Packet-switched networks for complex processors</li>
                                                    </ul>
                                                    <div class="alert alert-warning">
                                                        <p><strong>Example:</strong> Apple M-series processors use a unified memory architecture (UMA) with a high-bandwidth fabric connecting CPU, GPU, Neural Engine, and other components to a shared memory pool, eliminating copying between different memory spaces.</p>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('4.4')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('4.6')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 4.6: Register Organization -->
                    <div class="slide" id="slide-4.6">
                        <h2 class="slide-title">Register Organization</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Register Fundamentals</div>
                                        <div class="card-body">
                                            <p>Registers are small, high-speed storage locations within the processor that temporarily hold data, addresses, and control information. They are the fastest memory in the computer system hierarchy.</p>

                                            <h5>Types of Registers:</h5>
                                            <ul>
                                                <li><strong>General-Purpose Registers (GPRs):</strong> Hold data and addresses for a wide range of operations</li>
                                                <li><strong>Special-Purpose Registers:</strong> Serve specific functions in the processor</li>
                                                <li><strong>Control Registers:</strong> Store processor state information and control processor behavior</li>
                                                <li><strong>Status Registers:</strong> Contain flags that reflect the result of operations (e.g., zero, negative, overflow)</li>
                                                <li><strong>Segment Registers:</strong> Used in memory segmentation schemes (primarily in x86)</li>
                                                <li><strong>Floating-Point Registers:</strong> Store floating-point data for mathematical operations</li>
                                                <li><strong>Vector/SIMD Registers:</strong> Hold multiple data elements for parallel processing</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Architecture-Specific Register Organization</div>
                                        <div class="card-body">
                                            <h5>x86-64 Registers:</h5>
                                            <ul>
                                                <li><strong>General Purpose:</strong> RAX, RBX, RCX, RDX, RSI, RDI, RBP, RSP, R8-R15</li>
                                                <li><strong>Instruction Pointer:</strong> RIP</li>
                                                <li><strong>Status Register:</strong> RFLAGS</li>
                                                <li><strong>Segment Registers:</strong> CS, DS, SS, ES, FS, GS</li>
                                                <li><strong>SSE/AVX:</strong> XMM0-XMM15/YMM0-YMM15/ZMM0-ZMM31</li>
                                            </ul>

                                            <h5>ARM AArch64 Registers:</h5>
                                            <ul>
                                                <li><strong>General Purpose:</strong> X0-X30 (64-bit) / W0-W30 (32-bit views)</li>
                                                <li><strong>Stack Pointer:</strong> SP</li>
                                                <li><strong>Link Register:</strong> X30/LR</li>
                                                <li><strong>Program Counter:</strong> PC</li>
                                                <li><strong>SIMD/Vector:</strong> V0-V31 (128-bit)</li>
                                                <li><strong>System Registers:</strong> Various control and status registers</li>
                                            </ul>

                                            <h5>RISC-V Registers:</h5>
                                            <ul>
                                                <li><strong>General Purpose:</strong> x0-x31 (x0 is hardwired to zero)</li>
                                                <li><strong>Floating Point:</strong> f0-f31</li>
                                                <li><strong>Program Counter:</strong> pc</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Register File Architecture and Advanced Concepts</div>
                                        <div class="card-body">
                                            <div class="row">
                                                <div class="col-md-7">
                                                    <h5>Register File Organization:</h5>
                                                    <p>The register file is a key component in processor design that significantly impacts performance:</p>
                                                    <ul>
                                                        <li><strong>Multi-Port Access:</strong> Modern register files support multiple simultaneous reads and writes</li>
                                                        <li><strong>Register Windows:</strong> Used in some RISC architectures (SPARC) to reduce function call overhead</li>
                                                        <li><strong>Register Renaming:</strong> Technique to eliminate false dependencies and enable out-of-order execution</li>
                                                        <li><strong>Physical vs. Architectural Registers:</strong> Modern CPUs have more physical registers than those exposed in the ISA</li>
                                                        <li><strong>Register Hierarchy:</strong> Some designs have different access latencies for different registers</li>
                                                    </ul>
                                                    
                                                    <h5>Register Usage Conventions:</h5>
                                                    <p>Each architecture defines conventions for register usage in function calls:</p>
                                                    <ul>
                                                        <li><strong>Caller/Callee-saved Registers:</strong> Define which registers must be preserved</li>
                                                        <li><strong>Parameter Passing:</strong> Dedicated registers for function arguments</li>
                                                        <li><strong>Return Values:</strong> Specific registers used for function return values</li>
                                                    </ul>
                                                </div>
                                                <div class="col-md-5">
                                                    <div class="alert alert-warning">
                                                        <h5>Example: x86-64 System V ABI Register Usage</h5>
                                                        <table class="table table-sm">
                                                            <thead>
                                                                <tr>
                                                                    <th>Purpose</th>
                                                                    <th>Registers</th>
                                                                </tr>
                                                            </thead>
                                                            <tbody>
                                                                <tr>
                                                                    <td>Function Arguments</td>
                                                                    <td>RDI, RSI, RDX, RCX, R8, R9</td>
                                                                </tr>
                                                                <tr>
                                                                    <td>Return Value</td>
                                                                    <td>RAX, RDX</td>
                                                                </tr>
                                                                <tr>
                                                                    <td>Caller-saved</td>
                                                                    <td>RAX, RCX, RDX, RSI, RDI, R8-R11</td>
                                                                </tr>
                                                                <tr>
                                                                    <td>Callee-saved</td>
                                                                    <td>RBX, RBP, R12-R15</td>
                                                                </tr>
                                                                <tr>
                                                                    <td>Special</td>
                                                                    <td>RSP (stack pointer)</td>
                                                                </tr>
                                                            </tbody>
                                                        </table>
                                                    </div>
                                                    
                                                    <div class="alert alert-info mt-3">
                                                        <h5>Architectural Impact on Register Design:</h5>
                                                        <ul>
                                                            <li><strong>RISC:</strong> Large, uniform register files with simpler addressing modes</li>
                                                            <li><strong>CISC:</strong> Typically fewer general registers with specialized usage</li>
                                                            <li><strong>VLIW:</strong> Often uses even larger register files to support multiple operations</li>
                                                            <li><strong>GPU:</strong> Massive register files to support thousands of threads</li>
                                                        </ul>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('4.5')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('4.7')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 4.7: Instruction Cycle -->
                    <div class="slide" id="slide-4.7">
                        <h2 class="slide-title">Instruction Cycle</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Basic Instruction Cycle</div>
                                        <div class="card-body">
                                            <p>The instruction cycle (also known as the fetch-execute cycle) is the basic operational process of a CPU. It defines the sequence of steps the processor follows to execute instructions.</p>

                                            <h5>Classical Instruction Cycle Phases:</h5>
                                            <ol>
                                                <li><strong>Fetch:</strong> Retrieve the instruction from memory at the address in the program counter (PC)</li>
                                                <li><strong>Decode:</strong> Determine what operation is required and what operands are needed</li>
                                                <li><strong>Execute:</strong> Perform the operation specified by the instruction</li>
                                                <li><strong>Store:</strong> Write results back to registers or memory</li>
                                            </ol>

                                            <div class="alert alert-info">
                                                <h5>Basic Instruction Cycle Diagram:</h5>
                                                <img src="/api/placeholder/550/250" alt="Basic Instruction Cycle" class="img-fluid" />
                                            </div>

                                            <h5>Extended Instruction Cycle (5-stage):</h5>
                                            <ol>
                                                <li><strong>Fetch (IF):</strong> Retrieve instruction from memory</li>
                                                <li><strong>Decode (ID):</strong> Decode instruction and read registers</li>
                                                <li><strong>Execute (EX):</strong> Perform ALU operations</li>
                                                <li><strong>Memory Access (MEM):</strong> Read from or write to memory if required</li>
                                                <li><strong>Write Back (WB):</strong> Write results back to registers</li>
                                            </ol>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Modern Instruction Cycle Implementation</div>
                                        <div class="card-body">
                                            <h5>CPU Microarchitecture Components for Instruction Cycle:</h5>
                                            
                                            <h6>1. Instruction Fetch Unit:</h6>
                                            <ul>
                                                <li><strong>Program Counter:</strong> Maintains address of next instruction</li>
                                                <li><strong>Instruction Cache:</strong> Stores recently accessed instructions</li>
                                                <li><strong>Branch Predictor:</strong> Predicts flow control to avoid pipeline stalls</li>
                                                <li><strong>Prefetch Buffer:</strong> Retrieves instructions ahead of execution</li>
                                            </ul>
                                            
                                            <h6>2. Instruction Decode Unit:</h6>
                                            <ul>
                                                <li><strong>Instruction Register:</strong> Holds current instruction being decoded</li>
                                                <li><strong>Decoder Circuitry:</strong> Translates instruction encoding into control signals</li>
                                                <li><strong>Register Renaming:</strong> Maps architectural registers to physical registers</li>
                                                <li><strong>Dependency Checking:</strong> Identifies data dependencies between instructions</li>
                                            </ul>
                                            
                                            <h6>3. Execution Units:</h6>
                                            <ul>
                                                <li><strong>ALU:</strong> Performs arithmetic and logical operations</li>
                                                <li><strong>FPU:</strong> Handles floating-point calculations</li>
                                                <li><strong>SIMD Units:</strong> Processes vector operations</li>
                                                <li><strong>Address Generation Unit:</strong> Calculates memory addresses</li>
                                                <li><strong>Specialized Units:</strong> Crypto, AI acceleration, etc.</li>
                                            </ul>
                                            
                                            <h6>4. Memory Access Units:</h6>
                                            <ul>
                                                <li><strong>Load/Store Unit:</strong> Handles memory reads and writes</li>
                                                <li><strong>Data Cache:</strong> Stores recently accessed data</li>
                                                <li><strong>Memory Order Buffer:</strong> Ensures proper ordering of memory operations</li>
                                                <li><strong>Translation Lookaside Buffer (TLB):</strong> Caches virtual-to-physical address translations</li>
                                            </ul>
                                            
                                            <h6>5. Write-Back Unit:</h6>
                                            <ul>
                                                <li><strong>Reorder Buffer:</strong> Ensures in-order completion of out-of-order execution</li>
                                                <li><strong>Register File Write Ports:</strong> Interfaces for updating registers</li>
                                                <li><strong>Result Forwarding:</strong> Passes results directly to dependent instructions</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Advanced Instruction Cycle Concepts</div>
                                        <div class="card-body">
                                            <div class="row">
                                                <div class="col-md-6">
                                                    <h5>Instruction Handling in Modern Processors:</h5>
                                                    <p>Modern CPUs implement sophisticated techniques to optimize the instruction cycle:</p>
                                                    
                                                    <h6>Speculative Execution:</h6>
                                                    <ul>
                                                        <li><strong>Branch Prediction:</strong> Guesses which path a branch will take</li>
                                                        <li><strong>Speculative Fetch:</strong> Fetches instructions along predicted path</li>
                                                        <li><strong>Prediction Mechanisms:</strong> Static, dynamic, neural network-based</li>
                                                        <li><strong>Recovery Mechanisms:</strong> Managing mispredictions efficiently</li>
                                                    </ul>
                                                    
                                                    <h6>Out-of-Order Execution:</h6>
                                                    <ul>
                                                        <li><strong>Instruction Window:</strong> Buffer of decoded instructions waiting for execution</li>
                                                        <li><strong>Scoreboarding/Tomasulo's Algorithm:</strong> Tracks instruction dependencies</li>
                                                        <li><strong>Dynamic Scheduling:</strong> Executes instructions when operands are ready</li>
                                                        <li><strong>In-Order Retirement:</strong> Commits results in program order</li>
                                                    </ul>
                                                </div>
                                                <div class="col-md-6">
                                                    <h5>Example: Instruction Cycle in a Modern x86 Processor</h5>
                                                    <ol>
                                                        <li><strong>Front-End:</strong>
                                                            <ul>
                                                                <li>Fetch multiple instructions from L1 instruction cache</li>
                                                                <li>Predict branches using multi-level predictors</li>
                                                                <li>Decode complex x86 instructions into simpler micro-operations (μops)</li>
                                                                <li>Allocate resources in reorder buffer and reservation stations</li>
                                                                <li>Rename registers to eliminate false dependencies</li>
                                                            </ul>
                                                        </li>
                                                        <li><strong>Execution:</strong>
                                                            <ul>
                                                                <li>Dispatch μops to appropriate execution units when operands ready</li>
                                                                <li>Execute operations out-of-order in parallel across multiple units</li>
                                                                <li>Forward results directly to dependent operations</li>
                                                                <li>Speculatively execute beyond branches</li>
                                                            </ul>
                                                        </li>
                                                        <li><strong>Retirement:</strong>
                                                            <ul>
                                                                <li>Commit results in original program order</li>
                                                                <li>Update architectural state (visible registers and memory)</li>
                                                                <li>Handle exceptions and traps</li>
                                                                <li>Discard results of mis-speculated operations</li>
                                                            </ul>
                                                        </li>
                                                    </ol>
                                                    <div class="alert alert-warning mt-2">
                                                        <p><strong>Complexity Impact:</strong> Modern instruction cycles involve dozens to hundreds of pipeline stages and can have 100+ instructions in flight simultaneously, with execution taking place across multiple issue ports and specialized units.</p>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('4.6')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('4.8')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 4.8: Instruction Pipelining -->
                    <div class="slide" id="slide-4.8">
                        <h2 class="slide-title">Instruction Pipelining</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Pipelining Fundamentals</div>
                                        <div class="card-body">
                                            <p>Instruction pipelining is a technique that allows multiple instructions to be processed simultaneously at different stages of the instruction cycle, similar to an assembly line in manufacturing.</p>

                                            <h5>Basic Pipeline Concept:</h5>
                                            <ul>
                                                <li><strong>Definition:</strong> Overlapping the execution of multiple instructions to increase throughput</li>
                                                <li><strong>Stages:</strong> Divides instruction processing into smaller, sequential steps</li>
                                                <li><strong>Throughput:</strong> Completes one instruction per clock cycle (in ideal conditions)</li>
                                                <li><strong>Latency:</strong> Time for a single instruction to complete all stages remains the same</li>
                                            </ul>

                                            <div class="alert alert-info">
                                                <h5>Classic 5-Stage RISC Pipeline:</h5>
                                                <img src="/api/placeholder/550/200" alt="5-Stage Pipeline" class="img-fluid" />
                                                <ol>
                                                    <li><strong>Instruction Fetch (IF):</strong> Get instruction from memory</li>
                                                    <li><strong>Instruction Decode (ID):</strong> Decode and register read</li>
                                                    <li><strong>Execute (EX):</strong> Perform ALU operations</li>
                                                    <li><strong>Memory Access (MEM):</strong> Read/write memory if needed</li>
                                                    <li><strong>Write Back (WB):</strong> Update registers with results</li>
                                                </ol>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Pipeline Hazards and Solutions</div>
                                        <div class="card-body">
                                            <p>Pipeline hazards are situations that prevent the next instruction from executing during its designated clock cycle, causing stalls or bubbles in the pipeline.</p>

                                            <h5>Types of Hazards:</h5>
                                            
                                            <h6>1. Structural Hazards:</h6>
                                            <ul>
                                                <li><strong>Cause:</strong> Hardware resource conflicts (e.g., single memory for instructions and data)</li>
                                                <li><strong>Solutions:</strong>
                                                    <ul>
                                                        <li>Duplicate resources (separate instruction and data caches)</li>
                                                        <li>Pipeline stalls (wait for resource availability)</li>
                                                        <li>Resource scheduling to avoid conflicts</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                            
                                            <h6>2. Data Hazards:</h6>
                                            <ul>
                                                <li><strong>Cause:</strong> Data dependencies between instructions</li>
                                                <li><strong>Types:</strong>
                                                    <ul>
                                                        <li>RAW (Read After Write): True dependency</li>
                                                        <li>WAR (Write After Read): Anti-dependency</li>
                                                        <li>WAW (Write After Write): Output dependency</li>
                                                    </ul>
                                                </li>
                                                <li><strong>Solutions:</strong>
                                                    <ul>
                                                        <li>Forwarding/Bypassing: Pass results directly to dependent instructions</li>
                                                        <li>Register renaming: Eliminate WAR and WAW hazards</li>
                                                        <li>Pipeline stalls/bubbles: Insert delays when necessary</li>
                                                        <li>Instruction scheduling: Compiler reordering to avoid hazards</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                            
                                            <h6>3. Control Hazards:</h6>
                                            <ul>
                                                <li><strong>Cause:</strong> Changes in program flow (branches, jumps, calls)</li>
                                                <li><strong>Solutions:</strong>
                                                    <ul>
                                                        <li>Branch prediction: Guess branch outcome</li>
                                                        <li>Delayed branching: Execution of instructions in branch delay slots</li>
                                                        <li>Speculative execution: Continue execution along predicted path</li>
                                                        <li>Predication: Execute both paths and select result based on condition</li>
                                                    </ul>
                                                </li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Advanced Pipelining Techniques</div>
                                        <div class="card-body">
                                            <div class="row">
                                                <div class="col-md-6">
                                                    <h5>Modern Pipeline Implementations:</h5>
                                                    
                                                    <h6>Superpipelining:</h6>
                                                    <ul>
                                                        <li><strong>Definition:</strong> Dividing pipeline stages into smaller substages</li>
                                                        <li><strong>Benefit:</strong> Allows higher clock frequencies</li>
                                                        <li><strong>Challenge:</strong> Increases branch misprediction penalty</li>
                                                        <li><strong>Example:</strong> Early MIPS R4000 with 8-stage pipeline</li>
                                                    </ul>
                                                    
                                                    <h6>Deep Pipelining:</h6>
                                                    <ul>
                                                        <li><strong>Definition:</strong> Pipelines with many stages (15-30+)</li>
                                                        <li><strong>Examples:</strong>
                                                            <ul>
                                                                <li>Intel Pentium 4: 20+ stage pipeline</li>
                                                                <li>Intel Skylake: ~14-19 stages</li>
                                                                <li>AMD Zen: ~12-17 stages</li>
                                                            </ul>
                                                        </li>
                                                        <li><strong>Tradeoffs:</strong> Higher frequencies but increased hazard penalties</li>
                                                    </ul>
                                                    
                                                    <h6>Dynamic Pipelining:</h6>
                                                    <ul>
                                                        <li><strong>Definition:</strong> Adaptively changing pipeline behavior based on program characteristics</li>
                                                        <li><strong>Techniques:</strong>
                                                            <ul>
                                                                <li>Loop stream detection and optimization</li>
                                                                <li>Micro-op fusion and fission</li>
                                                                <li>Adaptive branch prediction</li>
                                                            </ul>
                                                        </li>
                                                    </ul>
                                                    
                                                    <h6>Multi-threading in Pipelines:</h6>
                                                    <ul>
                                                        <li><strong>Fine-grained MT:</strong> Alternate threads each cycle</li>
                                                        <li><strong>Coarse-grained MT:</strong> Switch on long-latency events</li>
                                                        <li><strong>Simultaneous MT (SMT):</strong> Multiple threads share execution resources</li>
                                                    </ul>
                                                </div>
                                                <div class="col-md-6">
                                                    <h5>Pipeline Performance Analysis:</h5>
                                                    
                                                    <h6>Key Performance Metrics:</h6>
                                                    <ul>
                                                        <li><strong>Cycles Per Instruction (CPI):</strong> Average clock cycles to complete one instruction</li>
                                                        <li><strong>Instructions Per Cycle (IPC):</strong> Inverse of CPI, measures throughput</li>
                                                        <li><strong>Pipeline Efficiency:</strong> Ratio of useful work to total cycles</li>
                                                        <li><strong>Pipeline Bubbles:</strong> Empty stages representing wasted cycles</li>
                                                        <li><strong>Branch Misprediction Rate:</strong> Percentage of incorrectly predicted branches</li>
                                                    </ul>
                                                    
                                                    <h6>Pipeline Performance Equation:</h6>
                                                    <p>CPU Time = Instruction Count × CPI × Clock Cycle Time</p>
                                                    
                                                    <div class="alert alert-warning">
                                                        <h5>Case Study: Pipeline Optimization in Modern CPUs</h5>
                                                        <p><strong>Example:</strong> Consider a processor with a 20-stage pipeline executing a branch-heavy workload:</p>
                                                        <ul>
                                                            <li>Without branch prediction: Each branch causes ~20 cycle bubble (full pipeline flush)</li>
                                                            <li>With 90% accurate branch prediction: Only 10% of branches cause pipeline flushes</li>
                                                            <li>With branch prediction + speculative execution: Performance improves by up to 5x</li>
                                                        </ul>
                                                        <p>Modern CPUs employ sophisticated branch predictors with >95% accuracy for typical code.</p>
                                                    </div>
                                                    
                                                    <h6>Advanced Pipeline Visualization:</h6>
                                                    <img src="/api/placeholder/500/180" alt="Advanced Pipeline Visualization" class="img-fluid" />
                                                    <p class="small text-muted mt-1">Pipeline diagram showing instruction execution across multiple stages with hazard resolution, forwarding paths, and speculative execution.</p>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('4.7')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('4.9')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 4.9: RISC vs CISC -->
                    <div class="slide" id="slide-4.9">
                        <h2 class="slide-title">RISC vs CISC</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">RISC: Reduced Instruction Set Computing</div>
                                        <div class="card-body">
                                            <p>RISC is a CPU design philosophy that favors simplicity and optimization for common operations, using a small set of simple instructions that can be executed in a single clock cycle.</p>

                                            <h5>Key RISC Characteristics:</h5>
                                            <ul>
                                                <li><strong>Simple Instructions:</strong> Each instruction performs one basic operation</li>
                                                <li><strong>Fixed Instruction Length:</strong> All instructions have the same size (typically 32 or 64 bits)</li>
                                                <li><strong>Load-Store Architecture:</strong> Only load/store instructions access memory; all other operations use registers</li>
                                                <li><strong>Large Register Set:</strong> More general-purpose registers (16-32+)</li>
                                                <li><strong>Simple Addressing Modes:</strong> Limited number of ways to specify operands</li>
                                                <li><strong>Pipelined Execution:</strong> Designed for efficient pipelining</li>
                                                <li><strong>Hardwired Control Unit:</strong> Fixed instruction decoding logic</li>
                                            </ul>

                                            <h5>RISC Examples:</h5>
                                            <ul>
                                                <li><strong>ARM:</strong> Dominant in mobile and embedded systems</li>
                                                <li><strong>RISC-V:</strong> Open-source ISA gaining popularity</li>
                                                <li><strong>MIPS:</strong> Used in networking and embedded applications</li>
                                                <li><strong>POWER/PowerPC:</strong> IBM servers and game consoles</li>
                                                <li><strong>SPARC:</strong> Oracle/Sun servers and workstations</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">CISC: Complex Instruction Set Computing</div>
                                        <div class="card-body">
                                            <p>CISC is a CPU design philosophy that emphasizes high-level, complex instructions that can perform multiple operations in a single instruction, often requiring multiple clock cycles.</p>

                                            <h5>Key CISC Characteristics:</h5>
                                            <ul>
                                                <li><strong>Complex Instructions:</strong> Single instructions perform multiple operations</li>
                                                <li><strong>Variable Instruction Length:</strong> Instructions can be different sizes</li>
                                                <li><strong>Memory-to-Memory Operations:</strong> Can operate directly on memory operands</li>
                                                <li><strong>Fewer Registers:</strong> Traditionally fewer general-purpose registers</li>
                                                <li><strong>Rich Addressing Modes:</strong> Many ways to specify operands</li>
                                                <li><strong>Microprogrammed Control:</strong> Complex instructions implemented as microcode</li>
                                                <li><strong>Specialized Instructions:</strong> Instructions for specific high-level tasks</li>
                                            </ul>

                                            <h5>CISC Examples:</h5>
                                            <ul>
                                                <li><strong>x86/x86-64:</strong> Dominant in desktop, laptop, and server markets</li>
                                                <li><strong>System/360, z/Architecture:</strong> IBM mainframes</li>
                                                <li><strong>VAX:</strong> DEC's classic CISC architecture</li>
                                                <li><strong>Motorola 68000:</strong> Used in early Apple Macintosh and Amiga</li>
                                                <li><strong>Intel 80486 and earlier:</strong> Pure CISC designs</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Convergence and Modern Implementations</div>
                                        <div class="card-body">
                                            <div class="row">
                                                <div class="col-md-6">
                                                    <h5>RISC vs CISC: Comparative Analysis</h5>
                                                    
                                                    <table class="table table-sm">
                                                        <thead>
                                                            <tr>
                                                                <th>Aspect</th>
                                                                <th>RISC</th>
                                                                <th>CISC</th>
                                                            </tr>
                                                        </thead>
                                                        <tbody>
                                                            <tr>
                                                                <td>Code Size</td>
                                                                <td>Larger (more instructions)</td>
                                                                <td>Smaller (fewer instructions)</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Compiler Complexity</td>
                                                                <td>Higher (more optimization)</td>
                                                                <td>Lower (more work in hardware)</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Instruction Decode</td>
                                                                <td>Simple, fast</td>
                                                                <td>Complex, slower</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Execution Model</td>
                                                                <td>Hardwired control</td>
                                                                <td>Often microcoded</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Pipeline Design</td>
                                                                <td>Straightforward</td>
                                                                <td>More complex</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Power Efficiency</td>
                                                                <td>Generally better</td>
                                                                <td>Generally worse</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Backwards Compatibility</td>
                                                                <td>Easier to maintain</td>
                                                                <td>More challenging</td>
                                                            </tr>
                                                        </tbody>
                                                    </table>
                                                    
                                                    <h5>Historical Context:</h5>
                                                    <ul>
                                                        <li><strong>CISC Origins (1960s-70s):</strong> When memory was expensive, complex instructions reduced code size</li>
                                                        <li><strong>RISC Revolution (1980s):</strong> Research showed simpler instructions with optimization could outperform CISC</li>
                                                        <li><strong>CISC Resurgence (1990s):</strong> x86 gained dominance through market forces despite technical limitations</li>
                                                        <li><strong>RISC in Mobile (2000s-present):</strong> ARM's RISC design enabled the smartphone revolution</li>
                                                    </ul>
                                                </div>
                                                <div class="col-md-6">
                                                    <h5>Modern Convergence: RISC-CISC Hybrid Approaches</h5>
                                                    
                                                    <h6>CISC with RISC Inside:</h6>
                                                    <ul>
                                                        <li><strong>Micro-op Translation:</strong> Modern x86 processors translate CISC instructions into RISC-like micro-operations</li>
                                                        <li><strong>Example: Intel Core Architecture</strong>
                                                            <ul>
                                                                <li>Frontend decodes x86 instructions into μops</li>
                                                                <li>Backend executes μops using RISC-like principles</li>
                                                                <li>Micro-op cache stores decoded instructions</li>
                                                            </ul>
                                                        </li>
                                                        <li><strong>Best of Both Worlds:</strong> x86 compatibility with RISC-like execution efficiency</li>
                                                    </ul>
                                                    
                                                    <h6>RISC with CISC Features:</h6>
                                                    <ul>
                                                        <li><strong>Instruction Set Extensions:</strong> RISC architectures adding specialized complex operations</li>
                                                        <li><strong>Examples:</strong>
                                                            <ul>
                                                                <li>ARM NEON/SVE for vector processing</li>
                                                                <li>RISC-V vector and DSP extensions</li>
                                                                <li>ARM/RISC-V cryptographic instructions</li>
                                                            </ul>
                                                        </li>
                                                    </ul>
                                                    
                                                    <div class="alert alert-warning">
                                                        <h5>Case Study: Apple's Transition from Intel to ARM</h5>
                                                        <p>Apple's switch from x86 (CISC) to Apple Silicon (ARM RISC) demonstrates RISC advantages:</p>
                                                        <ul>
                                                            <li>Performance per watt improved significantly (2-3x)</li>
                                                            <li>Custom ARM cores optimized for Apple's workloads</li>
                                                            <li>Rosetta 2 translation layer maintains x86 compatibility</li>
                                                            <li>Specialized accelerators complement the RISC cores</li>
                                                        </ul>
                                                        <p>This transition highlights how RISC designs can outperform CISC when properly optimized.</p>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('4.8')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('4.10')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 4.10: Superscalar Processors -->
                    <div class="slide" id="slide-4.10">
                        <h2 class="slide-title">Superscalar Processors</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Superscalar Fundamentals</div>
                                        <div class="card-body">
                                            <p>Superscalar processing is a CPU design technique that allows multiple instructions to be executed simultaneously within a single clock cycle by using multiple execution units in parallel.</p>

                                            <h5>Key Characteristics:</h5>
                                            <ul>
                                                <li><strong>Definition:</strong> Architecture capable of executing more than one instruction per clock cycle</li>
                                                <li><strong>Multiple Execution Units:</strong> Parallel ALUs, FPUs, load/store units, branch units, etc.</li>
                                                <li><strong>Instruction-Level Parallelism (ILP):</strong> Exploits parallelism within a single instruction stream</li>
                                                <li><strong>Issue Width:</strong> Number of instructions that can be issued simultaneously (2-way, 4-way, etc.)</li>
                                                <li><strong>Dispatch Width:</strong> Number of instructions that can be sent to execution units</li>
                                                <li><strong>Completion/Retirement Width:</strong> Number of instructions that can complete per cycle</li>
                                            </ul>

                                            <h5>Superscalar vs. Other Parallelism Techniques:</h5>
                                            <ul>
                                                <li><strong>Pipelining:</strong> Overlaps stages of different instructions (temporal parallelism)</li>
                                                <li><strong>Superscalar:</strong> Multiple instructions in the same stage simultaneously (spatial parallelism)</li>
                                                <li><strong>VLIW:</strong> Compiler-scheduled parallel operations in fixed-length instruction words</li>
                                                <li><strong>SIMD:</strong> Same operation applied to multiple data elements</li>
                                                <li><strong>Multi-core:</strong> Multiple independent processor cores</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Superscalar Implementation</div>
                                        <div class="card-body">
                                            <h5>Superscalar Execution Pipeline:</h5>
                                            
                                            <h6>1. Instruction Fetch and Decode:</h6>
                                            <ul>
                                                <li><strong>Multiple Instruction Fetch:</strong> Retrieve several instructions per cycle</li>
                                                <li><strong>Branch Prediction:</strong> Essential for maintaining instruction flow</li>
                                                <li><strong>Instruction Alignment:</strong> Handle variable-length instructions (in CISC)</li>
                                                <li><strong>Parallel Decoding:</strong> Multiple decoders to handle instruction stream</li>
                                            </ul>
                                            
                                            <h6>2. Instruction Scheduling and Dispatch:</h6>
                                            <ul>
                                                <li><strong>Register Renaming:</strong> Eliminates false dependencies (WAR, WAW)</li>
                                                <li><strong>Dependency Analysis:</strong> Identifies true dependencies (RAW)</li>
                                                <li><strong>Out-of-Order Execution:</strong> Dynamic scheduling of instructions based on readiness</li>
                                                <li><strong>Reservation Stations:</strong> Hold instructions waiting for operands</li>
                                                <li><strong>Reorder Buffer:</strong> Tracks in-flight instructions to maintain program order</li>
                                            </ul>
                                            
                                            <h6>3. Execution and Completion:</h6>
                                            <ul>
                                                <li><strong>Multiple Functional Units:</strong> Several instances of each type (ALU, FPU, etc.)</li>
                                                <li><strong>Result Forwarding:</strong> Bypasses register file for dependent instructions</li>
                                                <li><strong>In-Order Retirement:</strong> Results committed in program order</li>
                                                <li><strong>Precise Exceptions:</strong> Maintained despite out-of-order execution</li>
                                            </ul>
                                            
                                            <div class="alert alert-info mt-2">
                                                <h5>Example: Superscalar Block Diagram</h5>
                                                <img src="/api/placeholder/530/200" alt="Superscalar Processor Diagram" class="img-fluid" />
                                                <p class="small text-muted mt-1">A simplified block diagram showing parallel fetch, decode, dispatch, execution, and retirement in a 4-way superscalar processor.</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Advanced Superscalar Concepts and Modern Implementations</div>
                                        <div class="card-body">
                                            <div class="row">
                                                <div class="col-md-6">
                                                    <h5>Challenges in Superscalar Design:</h5>
                                                    
                                                    <h6>1. Diminishing Returns in ILP:</h6>
                                                    <ul>
                                                        <li><strong>ILP Wall:</strong> Limited parallelism available in typical code</li>
                                                        <li><strong>Amdahl's Law:</strong> Serial portions limit overall speedup</li>
                                                        <li><strong>Resource Constraints:</strong> Power, area, and complexity increase dramatically with width</li>
                                                    </ul>
                                                    
                                                    <h6>2. Control Flow Limitations:</h6>
                                                    <ul>
                                                        <li><strong>Branch Misprediction Penalties:</strong> Increase with pipeline depth and width</li>
                                                        <li><strong>Control Dependencies:</strong> Restrict available parallelism</li>
                                                        <li><strong>Solutions:</strong> Predication, speculative execution, branch predictors</li>
                                                    </ul>
                                                    
                                                    <h6>3. Memory System Bottlenecks:</h6>
                                                    <ul>
                                                        <li><strong>Memory Wall:</strong> Growing gap between processor and memory speed</li>
                                                        <li><strong>Cache Misses:</strong> Cause significant stalls in wide-issue processors</li>
                                                        <li><strong>Solutions:</strong> Prefetching, non-blocking caches, memory-level parallelism</li>
                                                    </ul>
                                                    
                                                    <h5>Advanced Optimization Techniques:</h5>
                                                    <ul>
                                                        <li><strong>Trace Cache:</strong> Stores already-decoded micro-operations</li>
                                                        <li><strong>Loop Stream Detection:</strong> Optimizes small loops without refetching</li>
                                                        <li><strong>Macro-op Fusion:</strong> Combines instructions at decode time</li>
                                                        <li><strong>Micro-op Fusion:</strong> Combines micro-ops into single execution unit operations</li>
                                                        <li><strong>Memory Disambiguation:</strong> Speculative memory access reordering</li>
                                                        <li><strong>Dynamic Resource Allocation:</strong> Adapts execution resources to workload needs</li>
                                                    </ul>
                                                </div>
                                                <div class="col-md-6">
                                                    <h5>Modern Superscalar Implementations:</h5>
                                                    
                                                    <h6>Intel Core Microarchitecture:</h6>
                                                    <ul>
                                                        <li><strong>Fetch/Decode:</strong> Up to 6 instructions per cycle</li>
                                                        <li><strong>Execution:</strong> 8-12 execution ports with multiple units per port</li>
                                                        <li><strong>Out-of-Order Window:</strong> 200+ instructions in flight</li>
                                                        <li><strong>Key Features:</strong> Micro-op cache, loop stream detector, advanced branch prediction</li>
                                                    </ul>
                                                    
                                                    <h6>AMD Zen Architecture:</h6>
                                                    <ul>
                                                        <li><strong>Fetch:</strong> 16 bytes per cycle with advanced prediction</li>
                                                        <li><strong>Decode:</strong> 4 instructions per cycle</li>
                                                        <li><strong>Dispatch:</strong> 6 micro-ops per cycle</li>
                                                        <li><strong>Execution:</strong> 10 execution pipes with specialized units</li>
                                                        <li><strong>Key Features:</strong> Op cache, stack engine, perceptron predictor</li>
                                                    </ul>
                                                    
                                                    <h6>Apple A-series/M-series:</h6>
                                                    <ul>
                                                        <li><strong>Decode/Issue:</strong> Up to 8 instructions per cycle</li>
                                                        <li><strong>Very wide execution:</strong> 7+ ALUs, multiple load/store units</li>
                                                        <li><strong>Key Features:</strong> Enormous reorder buffer, aggressive speculation</li>
                                                    </ul>

                                                    <div class="alert alert-warning">
                                                        <h5>Case Study: Performance Scaling in Modern Superscalar Processors</h5>
                                                        <p>Apple's M1/M2 cores demonstrate the benefits of wide superscalar design:</p>
                                                        <ul>
                                                            <li>8-wide decode with 600+ instruction reorder buffer</li>
                                                            <li>7 ALUs, 4 load/store units, 2 branch units, 2-3 FPUs</li>
                                                            <li>Result: 2-3x single-thread performance per watt compared to contemporary x86 designs</li>
                                                            <li>Shows that with enough execution resources and power efficiency, superscalar scaling can continue beyond traditional limits</li>
                                                        </ul>
                                                    </div>
                                                </div>
                                            </div>
                                            
                                            <div class="row mt-3">
                                                <div class="col-md-12">
                                                    <h5>Future Directions in Processor Parallelism:</h5>
                                                    <ul>
                                                        <li><strong>Heterogeneous Cores:</strong> Big/little architectures with different performance/power characteristics</li>
                                                        <li><strong>Domain-Specific Accelerators:</strong> Specialized units for AI, graphics, cryptography integrated with superscalar cores</li>
                                                        <li><strong>Near-Memory Processing:</strong> Moving computation closer to data to overcome memory wall</li>
                                                        <li><strong>Reconfigurable Execution Units:</strong> Adapt hardware resources to workload characteristics</li>
                                                        <li><strong>Advanced Compiler-Hardware Co-design:</strong> Better static analysis to identify parallelism opportunities</li>
                                                        <li><strong>Speculative Multithreading:</strong> Automatic parallelization of serial code sections at runtime</li>
                                                    </ul>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('4.9')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('5.1')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 5.1: Micro-Operations -->
                    <div class="slide" id="slide-5.1">
                        <h2 class="slide-title">Micro-Operations</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Micro-Operations Fundamentals</div>
                                        <div class="card-body">
                                            <p>Micro-operations (micro-ops or μops) are the elementary operations that a processor performs internally to execute machine instructions. They represent the lowest-level actions that control the datapath within a CPU.</p>

                                            <h5>Understanding Micro-Operations:</h5>
                                            <ul>
                                                <li><strong>Definition:</strong> Primitive, indivisible operations that manipulate data and control processor resources</li>
                                                <li><strong>Purpose:</strong> Break down complex instructions into simple, manageable steps</li>
                                                <li><strong>Execution Time:</strong> Typically executed in a single clock cycle</li>
                                                <li><strong>Visibility:</strong> Internal to the processor (not visible to programmers)</li>
                                                <li><strong>Control Signals:</strong> Each micro-op generates specific control signals to coordinate hardware components</li>
                                            </ul>

                                            <h5>Types of Micro-Operations:</h5>
                                            <ul>
                                                <li><strong>Register Transfer:</strong> Move data between registers (e.g., R1 ← R2)</li>
                                                <li><strong>Arithmetic:</strong> Perform calculations (e.g., R1 ← R2 + R3)</li>
                                                <li><strong>Logic:</strong> Perform bitwise operations (e.g., R1 ← R2 AND R3)</li>
                                                <li><strong>Shift/Rotate:</strong> Manipulate bits in registers (e.g., R1 ← R2 << 3)</li>
                                                <li><strong>Memory Access:</strong> Load from or store to memory (e.g., R1 ← MEM[address])</li>
                                                <li><strong>Control Transfer:</strong> Change instruction flow (e.g., PC ← address)</li>
                                                <li><strong>Special Purpose:</strong> Manage processor state, flags, etc.</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Micro-Operations in Modern Processors</div>
                                        <div class="card-body">
                                            <h5>Instruction to Micro-ops Translation:</h5>
                                            <ul>
                                                <li><strong>CISC Architectures:</strong> Complex instructions decomposed into multiple micro-ops
                                                    <ul>
                                                        <li>Example: x86 ADD [mem], reg might decompose into:
                                                            <ol>
                                                                <li>LOAD temp ← MEM[address]</li>
                                                                <li>ADD temp ← temp + reg</li>
                                                                <li>STORE MEM[address] ← temp</li>
                                                            </ol>
                                                        </li>
                                                    </ul>
                                                </li>
                                                <li><strong>RISC Architectures:</strong> Instructions often map 1:1 to micro-ops</li>
                                                <li><strong>Instruction Decoder:</strong> Translates machine code into internal micro-op format</li>
                                                <li><strong>Micro-op Queue/Buffer:</strong> Holds decoded micro-ops before scheduling</li>
                                            </ul>
                                            
                                            <h5>Advanced Micro-operation Techniques:</h5>
                                            <ul>
                                                <li><strong>Micro-op Fusion:</strong> Combining multiple micro-ops into a single operation during execution</li>
                                                <li><strong>Macro-op Fusion:</strong> Combining adjacent instructions into a single micro-op</li>
                                                <li><strong>Micro-op Cache:</strong> Stores decoded micro-ops to bypass instruction decode
                                                    <ul>
                                                        <li>Reduces decode power consumption and latency</li>
                                                        <li>Particularly valuable for CISC architectures</li>
                                                    </ul>
                                                </li>
                                                <li><strong>Micro-op Cracking:</strong> Breaking complex micro-ops into simpler operations</li>
                                                <li><strong>Loop Stream Detector:</strong> Identifies small loops and streams micro-ops directly from buffer</li>
                                            </ul>
                                            
                                            <div class="alert alert-info mt-2">
                                                <h5>Example: x86-64 Instruction Translation</h5>
                                                <p><code>MOVQ [RBX + 8*RCX + 32], RAX</code> (Store RAX to memory)</p>
                                                <p>Micro-operations:</p>
                                                <ol>
                                                    <li>Calculate Address: <code>TEMP ← RBX + (RCX×8) + 32</code></li>
                                                    <li>Store Data: <code>MEM[TEMP] ← RAX</code></li>
                                                </ol>
                                                <p class="small text-muted mt-1">Modern x86 processors create these micro-ops internally to execute this single instruction.</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Micro-Operation Pipeline and Processing</div>
                                        <div class="card-body">
                                            <div class="row">
                                                <div class="col-md-6">
                                                    <h5>Micro-Operation Pipeline Flow:</h5>
                                                    
                                                    <h6>1. Generation Stage:</h6>
                                                    <ul>
                                                        <li><strong>Instruction Fetch:</strong> Retrieve instructions from memory</li>
                                                        <li><strong>Pre-decode:</strong> Initial instruction scanning</li>
                                                        <li><strong>Decode:</strong> Convert instructions to micro-ops</li>
                                                        <li><strong>Micro-op Sources:</strong>
                                                            <ul>
                                                                <li>Direct decode from instruction stream</li>
                                                                <li>Micro-op cache (decoded instruction cache)</li>
                                                                <li>Microcode ROM (for complex instructions)</li>
                                                            </ul>
                                                        </li>
                                                    </ul>
                                                    
                                                    <h6>2. Scheduling and Execution:</h6>
                                                    <ul>
                                                        <li><strong>Register Renaming:</strong> Map architectural registers to physical registers</li>
                                                        <li><strong>Allocation:</strong> Reserve resources for micro-ops</li>
                                                        <li><strong>Scheduling:</strong> Determine execution order based on dependencies</li>
                                                        <li><strong>Dispatch:</strong> Send to appropriate execution units</li>
                                                        <li><strong>Execution:</strong> Perform the actual operation</li>
                                                        <li><strong>Writeback:</strong> Update register file with results</li>
                                                    </ul>
                                                    
                                                    <h6>3. Retirement:</h6>
                                                    <ul>
                                                        <li><strong>Reorder Buffer:</strong> Tracks micro-ops to ensure in-order completion</li>
                                                        <li><strong>Retirement/Commit:</strong> Make results architecturally visible</li>
                                                        <li><strong>Exception Handling:</strong> Process any exceptions</li>
                                                    </ul>
                                                </div>
                                                <div class="col-md-6">
                                                    <h5>Performance Implications of Micro-operations:</h5>
                                                    
                                                    <h6>Advantages:</h6>
                                                    <ul>
                                                        <li><strong>Simplified Execution Units:</strong> Each unit handles a standard micro-op format</li>
                                                        <li><strong>Enhanced Parallelism:</strong> Enables out-of-order execution of instruction parts</li>
                                                        <li><strong>Optimized Execution:</strong> Common sequences can be optimized</li>
                                                        <li><strong>Architectural Flexibility:</strong> Same ISA can have different micro-op implementations</li>
                                                        <li><strong>Microcode Updates:</strong> Allows bug fixes without hardware changes</li>
                                                    </ul>
                                                    
                                                    <h6>Challenges:</h6>
                                                    <ul>
                                                        <li><strong>Instruction Bloat:</strong> One instruction might expand to many micro-ops</li>
                                                        <li><strong>Decode Bandwidth:</strong> Limits throughput in instruction-heavy code</li>
                                                        <li><strong>Energy Consumption:</strong> Translation process requires power</li>
                                                        <li><strong>Complexity:</strong> Additional hardware for decode, queue, scheduling</li>
                                                    </ul>

                                                    <div class="alert alert-warning">
                                                        <h5>Case Study: Intel vs. AMD Micro-op Implementation</h5>
                                                        <p>Different approaches to micro-op design impact processor efficiency:</p>
                                                        <ul>
                                                            <li><strong>Intel:</strong> Uses a variable-size micro-op format (~100-192 bits per micro-op)
                                                                <ul>
                                                                    <li>Explicit source/destination encoding</li>
                                                                    <li>Larger micro-ops but fewer needed per instruction</li>
                                                                </ul>
                                                            </li>
                                                            <li><strong>AMD:</strong> Uses fixed-size micro-ops (~64 bits per micro-op)
                                                                <ul>
                                                                    <li>May require multiple micro-ops to express complex operations</li>
                                                                    <li>Simpler design but potentially higher micro-op count</li>
                                                                </ul>
                                                            </li>
                                                        </ul>
                                                        <p>These design choices affect pipeline efficiency, cache utilization, and ultimately performance per watt.</p>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('4.10')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('5.2')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 5.2: Functional Requirements -->
                    <div class="slide" id="slide-5.2">
                        <h2 class="slide-title">Functional Requirements of Processor Control</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Control Unit Fundamentals</div>
                                        <div class="card-body">
                                            <p>The control unit is the "brain" of the CPU that coordinates all processor activities. It interprets instructions and generates the necessary control signals to direct the operation of other functional units.</p>

                                            <h5>Primary Functions of the Control Unit:</h5>
                                            <ul>
                                                <li><strong>Instruction Sequencing:</strong> Ensures instructions are executed in the correct order</li>
                                                <li><strong>Instruction Interpretation:</strong> Decodes instructions to determine required actions</li>
                                                <li><strong>Control Signal Generation:</strong> Produces signals that coordinate component operations</li>
                                                <li><strong>Timing Coordination:</strong> Synchronizes operations across different functional units</li>
                                                <li><strong>Exception Handling:</strong> Manages interrupts, traps, and error conditions</li>
                                                <li><strong>Resource Allocation:</strong> Assigns hardware resources to operations</li>
                                                <li><strong>State Management:</strong> Maintains and transitions processor state</li>
                                            </ul>

                                            <h5>Instruction Execution Cycle (Von Neumann Cycle):</h5>
                                            <ul>
                                                <li><strong>Fetch:</strong> Retrieve instruction from memory</li>
                                                <li><strong>Decode:</strong> Determine what the instruction does</li>
                                                <li><strong>Execute:</strong> Perform the required operation</li>
                                                <li><strong>Memory Access:</strong> Read from or write to memory if needed</li>
                                                <li><strong>Write-Back:</strong> Store results in registers</li>
                                                <li><strong>Next Instruction:</strong> Update program counter and repeat cycle</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Control Signals and Requirements</div>
                                        <div class="card-body">
                                            <h5>Essential Control Signals in Modern Processors:</h5>
                                            
                                            <h6>1. Datapath Control Signals:</h6>
                                            <ul>
                                                <li><strong>Register File Control:</strong> Read/write enables, register selection</li>
                                                <li><strong>ALU Operation:</strong> Function selection (ADD, SUB, AND, OR, etc.)</li>
                                                <li><strong>Data Routing:</strong> Multiplexer select signals for data paths</li>
                                                <li><strong>Shifting/Rotation:</strong> Direction and amount control</li>
                                                <li><strong>Condition Flags:</strong> Set/clear/test zero, carry, overflow, sign, etc.</li>
                                            </ul>
                                            
                                            <h6>2. Memory Interface Signals:</h6>
                                            <ul>
                                                <li><strong>Memory Read/Write:</strong> Control memory operations</li>
                                                <li><strong>Address Selection:</strong> Control address generation and routing</li>
                                                <li><strong>Data Size:</strong> Byte, word, double word access control</li>
                                                <li><strong>Cache Control:</strong> Cache access, coherency operations</li>
                                                <li><strong>Memory Barriers:</strong> Enforce memory ordering</li>
                                            </ul>
                                            
                                            <h6>3. Pipeline Control Signals:</h6>
                                            <ul>
                                                <li><strong>Pipeline Stall:</strong> Halt specific pipeline stages</li>
                                                <li><strong>Pipeline Flush:</strong> Clear incorrect speculative execution</li>
                                                <li><strong>Hazard Resolution:</strong> Handle data and control hazards</li>
                                                <li><strong>Forwarding Paths:</strong> Route data between pipeline stages</li>
                                                <li><strong>Branch Resolution:</strong> Update branch prediction state</li>
                                            </ul>
                                            
                                            <div class="alert alert-info mt-2">
                                                <h5>Example: Control Signals for a Single Instruction</h5>
                                                <p>For ADD R1, R2, R3 (R1 ← R2 + R3):</p>
                                                <ol>
                                                    <li>Register File: Read ports select R2 and R3</li>
                                                    <li>ALU Operation: Set to ADD function</li>
                                                    <li>ALU Source: Select register inputs (vs. immediate)</li>
                                                    <li>Register Write: Enable write to R1</li>
                                                    <li>Flag Update: Enable condition code updates</li>
                                                </ol>
                                                <p class="small text-muted mt-1">Each of these control signals must be generated at precisely the right time for correct execution.</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Advanced Control Requirements in Modern Processors</div>
                                        <div class="card-body">
                                            <div class="row">
                                                <div class="col-md-6">
                                                    <h5>Requirements for Complex Execution Models:</h5>
                                                    
                                                    <h6>1. Out-of-Order Execution Control:</h6>
                                                    <ul>
                                                        <li><strong>Instruction Tagging:</strong> Uniquely identify each instruction</li>
                                                        <li><strong>Dependency Tracking:</strong> Record producer-consumer relationships</li>
                                                        <li><strong>Resource Allocation:</strong> Manage reservation stations, reorder buffer entries</li>
                                                        <li><strong>Issue Logic:</strong> Select ready instructions for execution</li>
                                                        <li><strong>Commit Control:</strong> Ensure architectural state updates occur in order</li>
                                                        <li><strong>Speculation Recovery:</strong> Restore state after incorrect speculation</li>
                                                    </ul>
                                                    
                                                    <h6>2. Specialized Execution Units:</h6>
                                                    <ul>
                                                        <li><strong>Vector/SIMD Control:</strong> Element width, lane masks, permutation control</li>
                                                        <li><strong>FPU Precision Control:</strong> Rounding modes, exception behavior</li>
                                                        <li><strong>Branch Prediction Unit:</strong> History updates, prediction mechanisms</li>
                                                        <li><strong>Accelerator Control:</strong> Configure specialized units (AES, CRC, etc.)</li>
                                                        <li><strong>Prefetch Unit:</strong> Stream detection, prefetch distance</li>
                                                    </ul>
                                                    
                                                    <h5>Functional Requirements for Power Management:</h5>
                                                    <ul>
                                                        <li><strong>Clock Gating:</strong> Disable clocks to unused components</li>
                                                        <li><strong>Power Gating:</strong> Remove power from idle execution units</li>
                                                        <li><strong>Voltage/Frequency Scaling:</strong> Adjust operating parameters</li>
                                                        <li><strong>Thermal Monitoring:</strong> Respond to temperature conditions</li>
                                                        <li><strong>Activity Monitoring:</strong> Track functional unit utilization</li>
                                                        <li><strong>Core/Thread Parking:</strong> Disable unused cores or hardware threads</li>
                                                    </ul>
                                                </div>
                                                <div class="col-md-6">
                                                    <h5>Control Challenges in Complex Processors:</h5>
                                                    
                                                    <h6>1. Timing Complexity:</h6>
                                                    <ul>
                                                        <li><strong>Critical Paths:</strong> Control signals often define critical timing paths</li>
                                                        <li><strong>Signal Distribution:</strong> Delivering signals across large die areas</li>
                                                        <li><strong>Clock Domain Crossing:</strong> Synchronizing between different clock domains</li>
                                                        <li><strong>Signal Propagation:</strong> Wire delays increasingly significant</li>
                                                    </ul>
                                                    
                                                    <h6>2. Verification Challenges:</h6>
                                                    <ul>
                                                        <li><strong>Combinatorial Explosion:</strong> Enormous state space to verify</li>
                                                        <li><strong>Corner Cases:</strong> Rare combinations of events that may cause errors</li>
                                                        <li><strong>Formal Verification:</strong> Mathematical proof of correctness</li>
                                                        <li><strong>Post-Silicon Validation:</strong> Detecting bugs in manufactured chips</li>
                                                    </ul>
                                                    
                                                    <h6>3. Architectural Requirements:</h6>
                                                    <ul>
                                                        <li><strong>Security Features:</strong> Control for speculative execution protections</li>
                                                        <li><strong>Virtualization Support:</strong> Guest/host state management</li>
                                                        <li><strong>Debug Facilities:</strong> Hardware breakpoints, performance counters</li>
                                                        <li><strong>System Management:</strong> Low-level platform control</li>
                                                    </ul>

                                                    <div class="alert alert-warning">
                                                        <h5>Case Study: Intel Management Engine</h5>
                                                        <p>Modern processors often include control systems beyond the main CPU:</p>
                                                        <ul>
                                                            <li>Separate microcontroller running independently of main CPU</li>
                                                            <li>Has control over critical system functions:
                                                                <ul>
                                                                    <li>Power management and thermal control</li>
                                                                    <li>Initialization before main CPU boot</li>
                                                                    <li>System security and attestation</li>
                                                                    <li>Remote management capabilities</li>
                                                                </ul>
                                                            </li>
                                                            <li>Demonstrates how control requirements extend beyond traditional CPU functions</li>
                                                            <li>Illustrates the increasing complexity of processor control systems</li>
                                                        </ul>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('5.1')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('5.3')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 5.3: Processor Control -->
                    <div class="slide" id="slide-5.3">
                        <h2 class="slide-title">Processor Control</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Control Unit Architecture</div>
                                        <div class="card-body">
                                            <p>The control unit is responsible for coordinating all processor operations by generating control signals that direct the behavior of the datapath components. Two primary implementations exist: hardwired control and microprogrammed control.</p>

                                            <h5>Control Unit Design Approaches:</h5>
                                            <ul>
                                                <li><strong>Hardwired Control:</strong> Fixed logic circuits implementing the control function
                                                    <ul>
                                                        <li>Fast execution (direct hardware implementation)</li>
                                                        <li>Optimized for specific instruction set</li>
                                                        <li>Difficult to modify after manufacture</li>
                                                        <li>Compact silicon area for simple ISAs</li>
                                                    </ul>
                                                </li>
                                                <li><strong>Microprogrammed Control:</strong> Control signals generated by executing microinstructions
                                                    <ul>
                                                        <li>Flexible and easier to design</li>
                                                        <li>Slower execution (additional interpretation layer)</li>
                                                        <li>Can be updated after manufacture (microcode updates)</li>
                                                        <li>Better suited for complex instruction sets</li>
                                                    </ul>
                                                </li>
                                                <li><strong>Hybrid Approaches:</strong> Combining both techniques
                                                    <ul>
                                                        <li>Hardwired control for common instructions</li>
                                                        <li>Microcode for complex or rare instructions</li>
                                                        <li>Modern x86 processors use this approach</li>
                                                    </ul>
                                                </li>
                                            </ul>

                                            <h5>Control Unit Functionality:</h5>
                                            <ul>
                                                <li><strong>Instruction Decoding:</strong> Interpret instruction opcode</li>
                                                <li><strong>Control Signal Generation:</strong> Produce signals for all datapath components</li>
                                                <li><strong>Sequencing:</strong> Determine the order of operations</li>
                                                <li><strong>State Management:</strong> Track current processor state</li>
                                                <li><strong>Exception Handling:</strong> Respond to interrupts and exceptions</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Control Signal Generation</div>
                                        <div class="card-body">
                                            <h5>Control Signal Sources:</h5>
                                            
                                            <h6>1. Instruction-Derived Signals:</h6>
                                            <ul>
                                                <li><strong>Opcode Field:</strong> Primary determination of operation type</li>
                                                <li><strong>Function/Mode Fields:</strong> Specify variants of operations</li>
                                                <li><strong>Register Specifiers:</strong> Select registers for operations</li>
                                                <li><strong>Addressing Mode Bits:</strong> Determine operand access method</li>
                                                <li><strong>Immediate Values:</strong> Embedded constants in instructions</li>
                                            </ul>
                                            
                                            <h6>2. Processor State Signals:</h6>
                                            <ul>
                                                <li><strong>Condition Codes/Flags:</strong> Results of previous operations</li>
                                                <li><strong>Mode Registers:</strong> Processor operating mode (user/supervisor)</li>
                                                <li><strong>Control Registers:</strong> System configuration settings</li>
                                                <li><strong>Exception State:</strong> Pending interrupt information</li>
                                                <li><strong>Pipeline State:</strong> Current execution stage of each instruction</li>
                                            </ul>
                                            
                                            <h6>3. External Signals:</h6>
                                            <ul>
                                                <li><strong>Interrupt Requests:</strong> External device signals</li>
                                                <li><strong>Memory System Signals:</strong> Cache hits/misses, memory ready</li>
                                                <li><strong>System Bus Signals:</strong> Bus arbitration and protocol signals</li>
                                                <li><strong>Power Management:</strong> Thermal and power constraints</li>
                                            </ul>
                                            
                                            <div class="alert alert-info mt-2">
                                                <h5>Control Unit State Machine Example</h5>
                                                <img src="/api/placeholder/530/180" alt="Control Unit State Machine" class="img-fluid" />
                                                <p class="small text-muted mt-1">Simplified state diagram for instruction execution showing fetch, decode, execute, memory, and writeback states with transition conditions.</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Modern Control Unit Design Considerations</div>
                                        <div class="card-body">
                                            <div class="row">
                                                <div class="col-md-6">
                                                    <h5>Control for Advanced Pipeline Architectures:</h5>
                                                    
                                                    <h6>1. Superscalar Control Challenges:</h6>
                                                    <ul>
                                                        <li><strong>Multiple Instruction Decode:</strong> Parallel decoding of several instructions</li>
                                                        <li><strong>Resource Conflict Resolution:</strong> Managing competition for execution units</li>
                                                        <li><strong>Inter-instruction Dependencies:</strong> Detecting and handling dependencies</li>
                                                        <li><strong>Instruction Grouping:</strong> Identifying instructions that can execute together</li>
                                                        <li><strong>Completion Sequencing:</strong> Ensuring proper program order for results</li>
                                                    </ul>
                                                    
                                                    <h6>2. Out-of-Order Execution Control:</h6>
                                                    <ul>
                                                        <li><strong>Instruction Shelving:</strong> Buffering decoded instructions</li>
                                                        <li><strong>Data Dependency Analysis:</strong> Building the dependency graph</li>
                                                        <li><strong>Dynamic Scheduling:</strong> Selecting ready instructions for execution</li>
                                                        <li><strong>Register Renaming:</strong> Eliminating false dependencies</li>
                                                        <li><strong>Commit Control:</strong> Maintaining precise architectural state</li>
                                                    </ul>
                                                    
                                                    <h6>3. Speculative Execution Control:</h6>
                                                    <ul>
                                                        <li><strong>Branch Prediction:</strong> Direction and target speculation</li>
                                                        <li><strong>Checkpoint Creation:</strong> Saving processor state for recovery</li>
                                                        <li><strong>Speculative State Tracking:</strong> Identifying speculative operations</li>
                                                        <li><strong>Recovery Mechanisms:</strong> Restoring correct state after misprediction</li>
                                                        <li><strong>Security Controls:</strong> Preventing side-channel leaks</li>
                                                    </ul>
                                                </div>
                                                <div class="col-md-6">
                                                    <h5>Control Design Evolution:</h5>
                                                    
                                                    <h6>1. Historical Progression:</h6>
                                                    <ul>
                                                        <li><strong>Early Processors:</strong> Simple hardwired state machines</li>
                                                        <li><strong>Complex CISC Era:</strong> Predominantly microprogrammed control</li>
                                                        <li><strong>RISC Revolution:</strong> Return to hardwired control</li>
                                                        <li><strong>Modern Hybrids:</strong> Hardwired fast path with microcode support</li>
                                                        <li><strong>Current Trend:</strong> Distributed control with specialized controllers</li>
                                                    </ul>
                                                    
                                                    <h6>2. Distributed Control in Modern CPUs:</h6>
                                                    <ul>
                                                        <li><strong>Front-end Control:</strong> Fetch, decode, branch prediction</li>
                                                        <li><strong>Scheduler Control:</strong> Instruction dispatch and tracking</li>
                                                        <li><strong>Execution Control:</strong> Multiple specialized execution clusters</li>
                                                        <li><strong>Memory Subsystem Control:</strong> Load/store ordering, caches</li>
                                                        <li><strong>Retirement Control:</strong> Commit logic and exception handling</li>
                                                        <li><strong>System Agent Control:</strong> External interfaces, power management</li>
                                                    </ul>

                                                    <div class="alert alert-warning">
                                                        <h5>Case Study: ARM "Big.LITTLE" Control Challenges</h5>
                                                        <p>Heterogeneous multi-core designs present unique control requirements:</p>
                                                        <ul>
                                                            <li><strong>Different Core Types:</strong> High-performance and energy-efficient cores with different ISA implementations</li>
                                                            <li><strong>Workload Steering:</strong> Determining optimal core for each thread</li>
                                                            <li><strong>Dynamic Migration:</strong> Moving execution between cores seamlessly</li>
                                                            <li><strong>Cache Coherence:</strong> Maintaining consistent view of memory across cores</li>
                                                            <li><strong>Power Domain Management:</strong> Activating only necessary cores</li>
                                                        </ul>
                                                        <p>These heterogeneous systems require sophisticated control mechanisms that extend beyond traditional single-core control units.</p>
                                                    </div>
                                                </div>
                                            </div>
                                            
                                            <div class="row mt-3">
                                                <div class="col-md-12">
                                                    <h5>Future Control Unit Directions:</h5>
                                                    <ul>
                                                        <li><strong>AI-Assisted Control:</strong> Using machine learning to optimize control signal generation</li>
                                                        <li><strong>Adaptive Control:</strong> Dynamically adjusting control based on workload</li>
                                                        <li><strong>Quantum Control:</strong> Exploring control for quantum computing architectures</li>
                                                        <li><strong>Security-First Design:</strong> Building control units with security as a primary concern</li>
                                                        <li><strong>Integration with SoC:</strong> Control units that manage entire system-on-chip architectures</li>
                                                        <li><strong>3D Integration:</strong> Control units that span multiple layers of silicon</li>
                                                        <li><strong>Neuromorphic Control:</strong> Exploring brain-inspired control architectures</li>
                                                        <li><strong>Distributed Control:</strong> Moving towards decentralized control architectures</li>
                                                        <li><strong>Open-Source Control:</strong> Community-driven control unit designs</li>
                                                        <li><strong>Control for Emerging Technologies:</strong> Adapting control units for new computing paradigms</li>
                                                    </ul>
                                                </div>
                                            </div>
                                        </div>
                                    </div>

                                </div>
                            </div>
                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Control Unit Design Examples</div>
                                        <div class="card-body">
                                            <h5>Examples of Control Unit Implementations:</h5>
                                            
                                            <h6>1. ARM Cortex-A Series:</h6>
                                            <ul>
                                                <li><strong>Microprogrammed Control:</strong> Used for complex instructions</li>
                                                <li><strong>Hardwired Control:</strong> For simple instructions</li>
                                                <li><strong>Dynamic Voltage and Frequency Scaling:</strong> Power management features</li>
                                            </ul>
                                            
                                            <h6>2. Intel Core i7:</h6>
                                            <ul>
                                                <li><strong>Out-of-Order Execution:</strong> Advanced control for instruction scheduling</li>
                                                <li><strong>Branch Prediction:</strong> Sophisticated prediction algorithms</li>
                                                <li><strong>Turbo Boost Technology:</strong> Dynamic frequency scaling based on workload</li>
                                            </ul>

                                            <h6>3. RISC-V Processors:</h6>
                                            <ul>
                                                <li><strong>Open-Source Control Units:</strong> Community-driven designs</li>
                                                <li><strong>Modular Architecture:</strong> Customizable control units for specific applications</li>
                                                <li><strong>Support for Heterogeneous Computing:</strong> Control for multiple core types</li>
                                            </ul>

                                            <h6>4. NVIDIA GPUs:</h6>
                                            <ul>
                                                <li><strong>SIMD Control:</strong> Control for parallel execution of threads</li>
                                                <li><strong>Dynamic Thread Scheduling:</strong> Managing thousands of threads</li>
                                                <li><strong>Memory Coalescing:</strong> Optimizing memory access patterns</li>
                                                <li><strong>Cache Coherence Protocols:</strong> Ensuring data consistency across cores</li>
                                            </ul>
                                        </div>
                                    </div>

                                </div>
                            </div>
                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Control Unit Design Challenges</div>
                                        <div class="card-body">
                                            <h5>Challenges in Control Unit Design:</h5>
                                            <ul>
                                                <li><strong>Complexity:</strong> Increasing complexity of control logic</li>
                                                <li><strong>Power Consumption:</strong> Balancing performance and power efficiency</li>
                                                <li><strong>Security:</strong> Protecting against side-channel attacks</li>
                                                <li><strong>Reliability:</strong> Ensuring correct operation under all conditions</li>
                                                <li><strong>Scalability:</strong> Adapting to future technology nodes</li>
                                                <li><strong>Integration:</strong> Combining control with other system components</li>
                                            </ul>
                                            <h5>Future Directions:</h5>
                                            <ul>
                                                <li><strong>AI and Machine Learning:</strong> Using AI to optimize control logic</li>
                                                <li><strong>Quantum Computing:</strong> Exploring control for quantum architectures</li>
                                                <li><strong>Neuromorphic Computing:</strong> Brain-inspired control architectures</li>
                                                <li><strong>3D Integration:</strong> Control units that span multiple layers of silicon</li>
                                                <li><strong>Open-Source Designs:</strong> Community-driven control unit designs</li>
                                                <li><strong>Security-First Design:</strong> Building control units with security as a primary concern</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Control Unit Design Summary</div>
                                        <div class="card-body">
                                            <h5>Summary of Control Unit Design:</h5>
                                            <ul>
                                                <li><strong>Control Unit Role:</strong> Coordinates all processor operations</li>
                                                <li><strong>Design Approaches:</strong> Hardwired, microprogrammed, and hybrid</li>
                                                <li><strong>Control Signals:</strong> Generated from instruction opcodes and processor state</li>
                                                <li><strong>Modern Challenges:</strong> Complexity, power consumption, security, reliability</li>
                                                <li><strong>Future Directions:</strong> AI-assisted control, quantum computing, neuromorphic architectures</li>
                                            </ul>
                                            <h5>Key Takeaways:</h5>
                                            <ul>
                                                <li>Control units are critical for processor operation</li>
                                                <li>Design approaches vary based on architecture and requirements</li>
                                                <li>Future trends point towards more complex and adaptive control systems</li>
                                                <li>Understanding control unit design is essential for computer architecture</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('5.2')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('5.4')">Next</button>
                        </div>
                    </div>

                    <div class="slide" id="slide-5.4">
                        <h2 class="slide-title">Hardwired Control Implementation</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Hardwired Control: Fundamentals</div>
                                        <div class="card-body">
                                            <h5>Definition and Core Concepts:</h5>
                                            <p>Hardwired control is an implementation approach where control signals are generated by dedicated combinational and sequential logic circuits specifically designed to implement the processor's instruction set.</p>
                                            
                                            <div class="alert alert-info">
                                                <strong>Key Characteristics:</strong>
                                                <ul>
                                                    <li>Fixed, dedicated circuitry for each control function</li>
                                                    <li>Direct hardware implementation of the control algorithm</li>
                                                    <li>Faster execution compared to microprogrammed designs</li>
                                                    <li>Optimized for a specific instruction set architecture (ISA)</li>
                                                    <li>Control logic determined at design time and fixed at manufacture</li>
                                                </ul>
                                            </div>
                                            
                                            <h5>Hardware Components in Hardwired Design:</h5>
                                            <ul>
                                                <li><strong>Instruction Register (IR):</strong> Holds the current instruction being executed</li>
                                                <li><strong>Instruction Decoder:</strong> Translates opcodes into control line activations</li>
                                                <li><strong>Control State Register:</strong> Maintains the current state of instruction execution</li>
                                                <li><strong>Next-State Logic:</strong> Determines the sequence of states for each instruction</li>
                                                <li><strong>Control Signal Generator:</strong> Produces specific control signals for each state</li>
                                                <li><strong>Timing Circuits:</strong> Coordinate the timing of control signals</li>
                                            </ul>
                                            
                                            <h5>Working Principle:</h5>
                                            <div class="text-center mb-3">
                                                <svg width="100%" height="150" viewBox="0 0 400 150">
                                                    <!-- Hardwired Control FSM Diagram -->
                                                    <rect x="50" y="30" width="80" height="40" fill="#e3f2fd" stroke="#1565c0" rx="5" ry="5"/>
                                                    <text x="90" y="55" text-anchor="middle" font-size="10">Fetch</text>
                                                    
                                                    <rect x="170" y="30" width="80" height="40" fill="#e3f2fd" stroke="#1565c0" rx="5" ry="5"/>
                                                    <text x="210" y="55" text-anchor="middle" font-size="10">Decode</text>
                                                    
                                                    <rect x="290" y="30" width="80" height="40" fill="#e3f2fd" stroke="#1565c0" rx="5" ry="5"/>
                                                    <text x="330" y="55" text-anchor="middle" font-size="10">Execute</text>
                                                    
                                                    <!-- State transitions -->
                                                    <path d="M130 50 L170 50" stroke="#333" marker-end="url(#arrow)"/>
                                                    <path d="M250 50 L290 50" stroke="#333" marker-end="url(#arrow)"/>
                                                    <path d="M330 70 L330 110 L90 110 L90 70" stroke="#333" marker-end="url(#arrow)"/>
                                                    
                                                    <!-- Control signals -->
                                                    <rect x="50" y="100" width="300" height="30" fill="#bbdefb" stroke="#0d47a1"/>
                                                    <text x="200" y="120" text-anchor="middle" font-size="9">Control Signals to Datapath</text>
                                                </svg>
                                            </div>
                                            <ol>
                                                <li>Current instruction and processor state serve as inputs</li>
                                                <li>Logic circuits compute the next state and control outputs</li>
                                                <li>State transitions occur with clock cycles</li>
                                                <li>Each state generates a specific set of control signals</li>
                                                <li>The process repeats for each new instruction</li>
                                            </ol>
                                        </div>
                                    </div>
                                </div>
                    
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Hardwired Control: Design Process</div>
                                        <div class="card-body">
                                            <h5>Step-by-Step Design Methodology:</h5>
                                            
                                            <h6>1. Instruction Analysis:</h6>
                                            <ul>
                                                <li>Identify all instructions in the ISA</li>
                                                <li>Break each instruction into micro-operations</li>
                                                <li>Determine execution cycles needed for each instruction</li>
                                                <li>Map out all possible instruction execution paths</li>
                                            </ul>
                                            
                                            <h6>2. State Machine Definition:</h6>
                                            <div class="alert alert-secondary">
                                                <p><strong>State Encoding Examples:</strong></p>
                                                <table class="table table-sm">
                                                    <tr>
                                                        <th>Encoding Type</th>
                                                        <th>Bits Required</th>
                                                        <th>Advantages</th>
                                                    </tr>
                                                    <tr>
                                                        <td>Binary</td>
                                                        <td>log₂(n)</td>
                                                        <td>Minimal flip-flops</td>
                                                    </tr>
                                                    <tr>
                                                        <td>One-hot</td>
                                                        <td>n</td>
                                                        <td>Simpler decode logic</td>
                                                    </tr>
                                                    <tr>
                                                        <td>Gray code</td>
                                                        <td>log₂(n)</td>
                                                        <td>Reduced glitches</td>
                                                    </tr>
                                                </table>
                                            </div>
                                            
                                            <h6>3. Logic Design:</h6>
                                            <ul>
                                                <li>Derive boolean equations for next-state logic</li>
                                                <li>Create truth tables for control signal generation</li>
                                                <li>Optimize logic using techniques like Karnaugh maps</li>
                                                <li>Design decoder circuitry for instruction opcodes</li>
                                            </ul>
                                            
                                            <h6>4. Implementation and Optimization:</h6>
                                            <ul>
                                                <li>Convert logic equations to gate-level designs</li>
                                                <li>Optimize for power, area, and timing constraints</li>
                                                <li>Verify functionality through simulation</li>
                                                <li>Finalize physical layout design</li>
                                            </ul>
                                            
                                            <div class="alert alert-warning mt-3">
                                                <h6>Design Challenges:</h6>
                                                <ul>
                                                    <li><strong>Complexity:</strong> Logic complexity grows with instruction set size</li>
                                                    <li><strong>Verification:</strong> Ensuring correct operation across all possible states</li>
                                                    <li><strong>Timing:</strong> Managing critical paths and clock domains</li>
                                                    <li><strong>Modifications:</strong> Difficulty in adapting design after manufacture</li>
                                                    <li><strong>Debugging:</strong> Limited visibility into internal state for debugging</li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Detailed Example: MIPS R2000 Hardwired Control Unit</div>
                                        <div class="card-body">
                                            <div class="row">
                                                <div class="col-md-6">
                                                    <h5>MIPS R2000 Hardwired Control Implementation:</h5>
                                                    <p>The MIPS R2000 is a classic RISC processor with a hardwired control unit that exemplifies the principles of hardwired design.</p>
                                                    
                                                    <h6>Instruction Format and Decoding:</h6>
                                                    <div class="text-center mb-3">
                                                        <svg width="100%" height="60" viewBox="0 0 300 60">
                                                            <!-- MIPS Instruction Format -->
                                                            <rect x="10" y="10" width="280" height="40" fill="#e1f5fe" stroke="#0288d1"/>
                                                            <rect x="10" y="10" width="60" height="40" fill="#bbdefb" stroke="#0d47a1"/>
                                                            <rect x="70" y="10" width="50" height="40" fill="#c8e6c9" stroke="#2e7d32"/>
                                                            <rect x="120" y="10" width="50" height="40" fill="#c8e6c9" stroke="#2e7d32"/>
                                                            <rect x="170" y="10" width="50" height="40" fill="#c8e6c9" stroke="#2e7d32"/>
                                                            <rect x="220" y="10" width="70" height="40" fill="#ffecb3" stroke="#ffa000"/>
                                                            
                                                            <text x="40" y="35" text-anchor="middle" font-size="8">Opcode</text>
                                                            <text x="95" y="35" text-anchor="middle" font-size="8">rs</text>
                                                            <text x="145" y="35" text-anchor="middle" font-size="8">rt</text>
                                                            <text x="195" y="35" text-anchor="middle" font-size="8">rd</text>
                                                            <text x="255" y="35" text-anchor="middle" font-size="8">funct</text>
                                                        </svg>
                                                        <p class="small text-muted">MIPS R-type instruction format (6-bit opcode, three 5-bit register fields, 6-bit function code)</p>
                                                    </div>
                                                    
                                                    <h6>Control Signal Generation:</h6>
                                                    <p>For a simple ADD instruction (R-type with function code 0x20):</p>
                                                    <ol>
                                                        <li><strong>Fetch:</strong> PC output enabled, memory read activated, IR load enabled</li>
                                                        <li><strong>Decode:</strong> Opcode decoder identifies R-type instruction</li>
                                                        <li><strong>Register Read:</strong> Register file read enables activated for rs and rt</li>
                                                        <li><strong>Execute:</strong> ALU configured for addition operation based on function code</li>
                                                        <li><strong>Writeback:</strong> Register file write enable activated, ALU result bus selected as input</li>
                                                    </ol>
                                                </div>
                                                <div class="col-md-6">
                                                    <div class="card">
                                                        <div class="card-header bg-light">MIPS R2000 Control Signal Table (Simplified)</div>
                                                        <div class="card-body">
                                                            <table class="table table-sm table-bordered">
                                                                <thead class="thead-light">
                                                                    <tr>
                                                                        <th>Instruction</th>
                                                                        <th>RegDst</th>
                                                                        <th>ALUSrc</th>
                                                                        <th>MemtoReg</th>
                                                                        <th>RegWrite</th>
                                                                        <th>MemRead</th>
                                                                        <th>MemWrite</th>
                                                                        <th>Branch</th>
                                                                        <th>ALUOp</th>
                                                                    </tr>
                                                                </thead>
                                                                <tbody>
                                                                    <tr>
                                                                        <td>R-type (ADD, SUB, etc.)</td>
                                                                        <td>1</td>
                                                                        <td>0</td>
                                                                        <td>0</td>
                                                                        <td>1</td>
                                                                        <td>0</td>
                                                                        <td>0</td>
                                                                        <td>0</td>
                                                                        <td>10</td>
                                                                    </tr>
                                                                    <tr>
                                                                        <td>LW (Load Word)</td>
                                                                        <td>0</td>
                                                                        <td>1</td>
                                                                        <td>1</td>
                                                                        <td>1</td>
                                                                        <td>1</td>
                                                                        <td>0</td>
                                                                        <td>0</td>
                                                                        <td>00</td>
                                                                    </tr>
                                                                    <tr>
                                                                        <td>SW (Store Word)</td>
                                                                        <td>X</td>
                                                                        <td>1</td>
                                                                        <td>X</td>
                                                                        <td>0</td>
                                                                        <td>0</td>
                                                                        <td>1</td>
                                                                        <td>0</td>
                                                                        <td>00</td>
                                                                    </tr>
                                                                    <tr>
                                                                        <td>BEQ (Branch if Equal)</td>
                                                                        <td>X</td>
                                                                        <td>0</td>
                                                                        <td>X</td>
                                                                        <td>0</td>
                                                                        <td>0</td>
                                                                        <td>0</td>
                                                                        <td>1</td>
                                                                        <td>01</td>
                                                                    </tr>
                                                                </tbody>
                                                            </table>
                                                            <p class="small text-muted">Note: X represents "don't care" conditions where the signal value does not affect operation</p>
                                                        </div>
                                                    </div>
                                                    
                                                    <div class="mt-3">
                                                        <h6>Hardwired Implementation Logic:</h6>
                                                        <p>For the RegWrite signal (determines if a register is written to):</p>
                                                        <pre class="bg-light p-2">
RegWrite = (Op5' ∧ Op4' ∧ Op3' ∧ Op2' ∧ Op1' ∧ Op0')   // R-type
            ∨ (Op5 ∧ Op4' ∧ Op3' ∧ Op2' ∧ Op1 ∧ Op0)    // LW
            ∨ (Op5' ∧ Op4' ∧ Op3 ∧ Op2' ∧ Op1' ∧ Op0)   // ADDI
            ∨ ...</pre>
                                                        <p>This would be implemented as a combination of decoders and OR gates in the physical circuit.</p>
                                                    </div>
                                                </div>
                                            </div>

                                            
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="row mt-3">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-warning text-dark">Benefits of Hardwired Control</div>
                                        <div class="card-body">
                                            <h5>Advantages in Detail:</h5>
                                            
                                            <h6>1. Performance:</h6>
                                            <ul>
                                                <li><strong>Speed:</strong> Direct hardware implementation minimizes instruction execution time</li>
                                                <li><strong>Lower Latency:</strong> No microinstruction fetch/decode overhead</li>
                                                <li><strong>Parallelism:</strong> Can generate multiple control signals simultaneously</li>
                                                <li><strong>Deterministic Timing:</strong> Predictable execution time for each instruction</li>
                                            </ul>
                                            
                                            <h6>2. Efficiency:</h6>
                                            <ul>
                                                <li><strong>Circuit Size:</strong> More compact for simple instruction sets</li>
                                                <li><strong>Power Consumption:</strong> Can be optimized for specific instruction patterns</li>
                                                <li><strong>Resource Utilization:</strong> No need for microprogram storage memory</li>
                                                <li><strong>Clock Frequency:</strong> Can operate at higher frequencies with optimized logic</li>
                                            </ul>
                                            
                                            <h6>3. Design Benefits:</h6>
                                            <ul>
                                                <li><strong>Optimization:</strong> Can be heavily optimized for common instruction paths</li>
                                                <li><strong>Predictability:</strong> Consistent behavior under all conditions</li>
                                                <li><strong>Ideal for RISC:</strong> Well-suited for reduced instruction set architectures</li>
                                                <li><strong>Verification:</strong> Can be exhaustively tested during design phase</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                                
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-danger text-white">Limitations of Hardwired Control</div>
                                        <div class="card-body">
                                            <h5>Challenges and Drawbacks:</h5>
                                            
                                            <h6>1. Design Complexity:</h6>
                                            <ul>
                                                <li><strong>Scaling Issues:</strong> Complexity increases exponentially with instruction set size</li>
                                                <li><strong>Design Time:</strong> Requires more engineering effort to design and verify</li>
                                                <li><strong>Error Prone:</strong> More complex logic leads to higher chance of design errors</li>
                                                <li><strong>Testing Complexity:</strong> Exhaustive testing becomes challenging for large designs</li>
                                            </ul>
                                            
                                            <h6>2. Flexibility Limitations:</h6>
                                            <ul>
                                                <li><strong>Fixed Functionality:</strong> Cannot be modified after manufacture</li>
                                                <li><strong>No Post-Production Fixes:</strong> Bugs require hardware revision</li>
                                                <li><strong>Instruction Set Extension:</strong> Difficult to add new instructions</li>
                                                <li><strong>Limited Adaptability:</strong> Cannot adjust to new requirements or optimizations</li>
                                            </ul>
                                            
                                            <h6>3. Practical Constraints:</h6>
                                            <ul>
                                                <li><strong>Complex Instructions:</strong> Inefficient for implementing complex operations</li>
                                                <li><strong>Debugging Difficulty:</strong> Limited visibility into control state</li>
                                                <li><strong>Microarchitectural Changes:</strong> Requires complete redesign for pipeline modifications</li>
                                                <li><strong>Implementation Challenges:</strong> Physical design becomes complex for large instruction sets</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Real-World Applications and Case Studies</div>
                                        <div class="card-body">
                                            <div class="row">
                                                <div class="col-md-6">
                                                    <h5>Successful Hardwired Control Implementations:</h5>
                                                    
                                                    <h6>1. ARM Cortex-M Series:</h6>
                                                    <div class="alert alert-secondary">
                                                        <p>The ARM Cortex-M0/M3/M4 processors use highly optimized hardwired control to achieve excellent performance/power ratio for embedded applications.</p>
                                                        <table class="table table-sm">
                                                            <tr>
                                                                <th>Model</th>
                                                                <th>Pipeline Stages</th>
                                                                <th>Control Logic Gates</th>
                                                            </tr>
                                                            <tr>
                                                                <td>Cortex-M0</td>
                                                                <td>3</td>
                                                                <td>12K</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Cortex-M3</td>
                                                                <td>3</td>
                                                                <td>18K</td>
                                                            </tr>
                                                            <tr>
                                                                <td>Cortex-M4</td>
                                                                <td>3</td>
                                                                <td>24K</td>
                                                            </tr>
                                                        </table>
                                                    </div>
                                                    
                                                    <h6>2. RISC-V Implementations:</h6>
                                                    <p>Many RISC-V cores (especially RV32I implementations) use hardwired control to maintain simplicity and performance.</p>
                                                    <ul>
                                                        <li><strong>Implementation:</strong> Clean-slate hardwired design</li>
                                                        <li><strong>Benefit:</strong> Open-source verification and community improvements</li>
                                                        <li><strong>Scalability:</strong> Base instruction set can be efficiently implemented</li>
                                                        <li><strong>Customization:</strong> Vendors can optimize control for specific applications</li>
                                                    </ul>
                                                </div>
                                                <div class="col-md-6">
                                                    <h6>3. High-Performance GPU Control Units:</h6>
                                                    <p>Modern GPUs use specialized hardwired control for SIMD (Single Instruction, Multiple Data) execution units.</p>
                                                    <div class="alert alert-info">
                                                        <ul>
                                                            <li><strong>Implementation:</strong> Dedicated control paths for shader operations</li>
                                                            <li><strong>Benefit:</strong> Maximum throughput for parallel computation</li>
                                                            <li><strong>Specialization:</strong> Optimized for graphics and compute workloads</li>
                                                            <li><strong>Efficiency:</strong> Reduced overhead for identical operations across many threads</li>
                                                        </ul>
                                                    </div>
                                                    
                                                    <h6>4. Custom ASICs for Specific Applications:</h6>
                                                    <p>Application-Specific Integrated Circuits often use hardwired control for maximum efficiency.</p>
                                                    <ul>
                                                        <li><strong>Implementation:</strong> Fully customized control for specific algorithms</li>
                                                        <li><strong>Benefit:</strong> Optimal performance for dedicated tasks (e.g., crypto, AI)</li>
                                                        <li><strong>Power Efficiency:</strong> Minimized control overhead for battery-powered devices</li>
                                                        <li><strong>Security:</strong> Hardware-level implementation of security protocols</li>
                                                    </ul>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('5.3')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('5.5')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 5.5: Micro-programmed Control -->
                    <div class="slide" id="slide-5.5">
                        <h2 class="slide-title">Microprogrammed Control</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Microprogrammed Control: Core Concepts</div>
                                        <div class="card-body">
                                            <h5>Definition and Fundamentals:</h5>
                                            <p>Microprogrammed control is an implementation approach where control signals are generated by executing a sequence of microinstructions stored in a dedicated memory called the control store or microprogram memory.</p>
                                            
                                            <div class="alert alert-info">
                                                <strong>Key Characteristics:</strong>
                                                <ul>
                                                    <li>Control signals generated by interpreting stored microinstructions</li>
                                                    <li>Each machine instruction maps to a sequence of microinstructions</li>
                                                    <li>Software-like approach to control unit implementation</li>
                                                    <li>Greater flexibility compared to hardwired designs</li>
                                                    <li>Can be modified after manufacture (through microcode updates)</li>
                                                </ul>
                                            </div>
                                            
                                            <h5>Core Terminology:</h5>
                                            <ul>
                                                <li><strong>Microinstruction:</strong> A single word that specifies multiple control signals</li>
                                                <li><strong>Microprogram:</strong> A sequence of microinstructions that implements a machine instruction</li>
                                                <li><strong>Control Store:</strong> The memory that holds the microprogram</li>
                                                <li><strong>Microsequencer:</strong> Logic that determines the next microinstruction to execute</li>
                                                <li><strong>Microprogramming:</strong> The process of writing microprograms</li>
                                                <li><strong>Microarchitecture:</strong> The implementation details below the ISA level</li>
                                            </ul>
                                            
                                            <h5>Hierarchical View of Instruction Execution:</h5>
                                            <ol>
                                                <li><strong>User Program:</strong> High-level program written in a programming language</li>
                                                <li><strong>Machine Instructions:</strong> ISA-level instructions (visible to programmer)</li>
                                                <li><strong>Microinstructions:</strong> Internal control words (invisible to programmer)</li>
                                                <li><strong>Hardware Operations:</strong> Actual signal activations on circuits</li>
                                            </ol>
                                        </div>
                                    </div>
                                </div>
                    
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Microprogrammed Control: Architecture</div>
                                        <div class="card-body">
                                            <h5>Components of a Microprogrammed Control Unit:</h5>
                                            
                                            <h6>1. Control Store (Microprogram Memory):</h6>
                                            <ul>
                                                <li><strong>Purpose:</strong> Stores all microinstructions</li>
                                                <li><strong>Implementation:</strong> ROM, PROM, or writable control store (WCS)</li>
                                                <li><strong>Organization:</strong> Addressable memory with each location containing one microinstruction</li>
                                                <li><strong>Capacity:</strong> Typically ranges from a few KB to several MB in complex processors</li>
                                            </ul>
                                            
                                            <h6>2. Microinstruction Register:</h6>
                                            <ul>
                                                <li><strong>Purpose:</strong> Holds the current microinstruction being executed</li>
                                                <li><strong>Function:</strong> Outputs control signals directly to datapath components</li>
                                                <li><strong>Updates:</strong> Loaded with new microinstruction each microcycle</li>
                                            </ul>
                                            
                                            <h6>3. Microprogram Counter (μPC):</h6>
                                            <ul>
                                                <li><strong>Purpose:</strong> Tracks the address of the next microinstruction</li>
                                                <li><strong>Operation:</strong> Increments sequentially or changes based on branch conditions</li>
                                                <li><strong>Initialization:</strong> Set to starting address of microprogram for each instruction</li>
                                            </ul>
                                            
                                            <h6>4. Microsequencer:</h6>
                                            <ul>
                                                <li><strong>Purpose:</strong> Determines the next microinstruction address</li>
                                                <li><strong>Functions:</strong> Sequential access, branching, subroutine calls, conditional execution</li>
                                                <li><strong>Inputs:</strong> Current microinstruction, status flags, instruction register</li>
                                                <li><strong>Outputs:</strong> Next microinstruction address for the control store</li>
                                            </ul>
                                            
                                            <h6>5. Mapping Logic:</h6>
                                            <ul>
                                                <li><strong>Purpose:</strong> Translates machine instruction opcodes to microprogram starting addresses</li>
                                                <li><strong>Implementation:</strong> Often a ROM-based lookup table</li>
                                                <li><strong>Operation:</strong> Decodes opcode and addressing mode to find entry point</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Microinstruction Formats and Design</div>
                                        <div class="card-body">
                                            <div class="row">
                                                <div class="col-md-6">
                                                    <h5>Microinstruction Encoding Approaches:</h5>
                                                    
                                                    <h6>1. Horizontal Microinstructions:</h6>
                                                    <div class="alert alert-secondary">
                                                        <p><strong>Definition:</strong> Wide format where each bit directly controls one control signal</p>
                                                        <ul>
                                                            <li><strong>Width:</strong> Typically 64-128 bits</li>
                                                            <li><strong>Encoding:</strong> Minimal encoding, direct control</li>
                                                            <li><strong>Parallelism:</strong> Maximum, can activate many signals simultaneously</li>
                                                            <li><strong>Memory Usage:</strong> Inefficient, requires wide control store</li>
                                                            <li><strong>Speed:</strong> Fast execution (no decoding required)</li>
                                                            <li><strong>Example Format:</strong> [ALU operation bits][Register selection bits][Memory control bits][Next address control bits]</li>
                                                        </ul>
                                                        <div class="text-center mt-2">
                                                            <svg width="100%" height="50" viewBox="0 0 300 50">
                                                                <rect x="10" y="10" width="280" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                                <text x="150" y="30" text-anchor="middle" font-size="8">64-128 bit wide control field (1 bit per control signal)</text>
                                                            </svg>
                                                        </div>
                                                    </div>
                                                    
                                                    <h6>2. Vertical Microinstructions:</h6>
                                                    <div class="alert alert-secondary">
                                                        <p><strong>Definition:</strong> Narrow format with encoded fields that require additional decoding</p>
                                                        <ul>
                                                            <li><strong>Width:</strong> Typically 16-32 bits</li>
                                                            <li><strong>Encoding:</strong> Heavily encoded fields</li>
                                                            <li><strong>Parallelism:</strong> Limited, often one operation per microinstruction</li>
                                                            <li><strong>Memory Usage:</strong> Efficient use of control store space</li>
                                                            <li><strong>Speed:</strong> Slower execution (requires decoding)</li>
                                                            <li><strong>Example Format:</strong> [Operation code][Operand specifier][Next address field]</li>
                                                        </ul>
                                                        <div class="text-center mt-2">
                                                            <svg width="100%" height="50" viewBox="0 0 300 50">
                                                                <rect x="10" y="10" width="80" height="30" fill="#bbdefb" stroke="#0d47a1"/>
                                                                <rect x="90" y="10" width="80" height="30" fill="#bbdefb" stroke="#0d47a1"/>
                                                                <rect x="170" y="10" width="60" height="30" fill="#bbdefb" stroke="#0d47a1"/>
                                                                <rect x="230" y="10" width="60" height="30" fill="#bbdefb" stroke="#0d47a1"/>
                                                                <text x="50" y="30" text-anchor="middle" font-size="8">Opcode</text>
                                                                <text x="130" y="30" text-anchor="middle" font-size="8">Operand</text>
                                                                <text x="200" y="30" text-anchor="middle" font-size="8">Cond</text>
                                                                <text x="260" y="30" text-anchor="middle" font-size="8">Next</text>
                                                            </svg>
                                                        </div>
                                                    </div>
                    
                                                    <h6>3. Hybrid (Diagonal) Microinstructions:</h6>
                                                    <div class="alert alert-secondary">
                                                        <p><strong>Definition:</strong> Compromise between horizontal and vertical approaches</p>
                                                        <ul>
                                                            <li><strong>Width:</strong> Moderate, typically 32-64 bits</li>
                                                            <li><strong>Encoding:</strong> Mix of direct and encoded fields</li>
                                                            <li><strong>Design:</strong> Encoding applied to mutually exclusive operations</li>
                                                            <li><strong>Optimization:</strong> Balances memory efficiency and execution speed</li>
                                                            <li><strong>Example Format:</strong> [ALU operation code][Direct register enable bits][Memory control code][Next address field]</li>
                                                        </ul>
                                                        <div class="text-center mt-2">
                                                            <svg width="100%" height="50" viewBox="0 0 300 50">
                                                                <rect x="10" y="10" width="60" height="30" fill="#c8e6c9" stroke="#2e7d32"/>
                                                                <rect x="70" y="10" width="120" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                                <rect x="190" y="10" width="60" height="30" fill="#c8e6c9" stroke="#2e7d32"/>
                                                                <rect x="250" y="10" width="40" height="30" fill="#ffecb3" stroke="#ffa000"/>
                                                                <text x="40" y="30" text-anchor="middle" font-size="8">ALU</text>
                                                                <text x="130" y="30" text-anchor="middle" font-size="8">Direct Controls</text>
                                                                <text x="220" y="30" text-anchor="middle" font-size="8">Mem</text>
                                                                <text x="270" y="30" text-anchor="middle" font-size="8">Next</text>
                                                            </svg>
                                                        </div>
                                                    </div>
                                                </div>
                                                <div class="col-md-6">
                                                    <h5>Microinstruction Sequencing Techniques:</h5>
                                                    
                                                    <h6>1. Basic Sequencing Methods:</h6>
                                                    <ul>
                                                        <li><strong>Linear:</strong> Simple increment of μPC</li>
                                                        <li><strong>Branching:</strong> Conditional jumps based on status flags</li>
                                                        <li><strong>Subroutine Calls:</strong> Microprogram stacks for common sequences</li>
                                                    </ul>
                                                    
                                                    <h6>2. Next Address Field Types:</h6>
                                                    <table class="table table-sm">
                                                        <tr>
                                                            <th>Type</th>
                                                            <th>Bits Required</th>
                                                            <th>Flexibility</th>
                                                        </tr>
                                                        <tr>
                                                            <td>Sequential</td>
                                                            <td>0</td>
                                                            <td>None (always μPC+1)</td>
                                                        </tr>
                                                        <tr>
                                                            <td>Two-way</td>
                                                            <td>1</td>
                                                            <td>Branch/Continue</td>
                                                        </tr>
                                                        <tr>
                                                            <td>Multi-way</td>
                                                            <td>2-4</td>
                                                            <td>Limited jumps</td>
                                                        </tr>
                                                        <tr>
                                                            <td>Full address</td>
                                                            <td>10-12</td>
                                                            <td>Complete control</td>
                                                        </tr>
                                                    </table>
                                                    
                                                    <h6>3. Advanced Sequencing Features:</h6>
                                                    <div class="alert alert-info">
                                                        <ul>
                                                            <li><strong>Microsubroutines:</strong> Reusable microcode segments</li>
                                                            <li><strong>Microinterrupts:</strong> Handling exceptional conditions</li>
                                                            <li><strong>Pipelining:</strong> Overlapping fetch and execution</li>
                                                            <li><strong>Nanoprogramming:</strong> Two-level control store</li>
                                                        </ul>
                                                    </div>
                                                    
                                                    <h5>Microprogramming Example:</h5>
                                                    <pre class="bg-light p-2">
; ADD R1, R2, R3 implementation
FETCH:  MAR ← PC              ; Get next instruction
        PC ← PC + 1
        MDR ← Memory[MAR]
        IR ← MDR

DECODE: μPC ← Mapping[IR.opcode]

EXECUTE: A ← R2               ; Microinstruction 1
            B ← R3               ; Microinstruction 2
            ALU ← ADD            ; Microinstruction 3
            R1 ← ALUout          ; Microinstruction 4
            μPC ← FETCH          ; Return to fetch</pre>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                    
                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-warning text-white">Microprogramming in Modern Processors</div>
                                        <div class="card-body">
                                            <div class="row">
                                                <div class="col-md-4">
                                                    <h5>Historical Evolution:</h5>
                                                    <ul>
                                                        <li>IBM 360 (1964): First widespread use</li>
                                                        <li>VAX (1977): Complex microprogramming</li>
                                                        <li>x86: Microcode updates for bug fixes</li>
                                                    </ul>
                                                </div>
                                                <div class="col-md-4">
                                                    <h5>Current Applications:</h5>
                                                    <ul>
                                                        <li>Complex instruction decoding</li>
                                                        <li>Exception handling</li>
                                                        <li>Power management sequences</li>
                                                        <li>Security features (e.g., Intel SGX)</li>
                                                    </ul>
                                                </div>
                                                <div class="col-md-4">
                                                    <h5>Performance Considerations:</h5>
                                                    <ul>
                                                        <li>Control store access time critical path</li>
                                                        <li>Writable Control Store (WCS) overhead</li>
                                                        <li>Parallel vs. serial microinstruction issue</li>
                                                    </ul>
                                                </div>
                                            </div>
                                            
                                            <div class="alert alert-success mt-3">
                                                <h5>Microcode Update Mechanism:</h5>
                                                <ol>
                                                    <li>CPU receives microcode patch (via BIOS or OS)</li>
                                                    <li>Patch authenticated by cryptographic signature</li>
                                                    <li>Loaded into reserved area of control store</li>
                                                    <li>Mapping tables updated to point to new microcode</li>
                                                    <li>Activated on next context switch or reboot</li>
                                                </ol>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('5.4')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('6.1')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 6.1: Classification of Parallel Systems -->
                    <div class="slide" id="slide-6.1">
                        <h2 class="slide-title">Classification of Parallel Systems</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Parallel Computing: Fundamentals</div>
                                        <div class="card-body">
                                            <h5>Definition and Core Concepts:</h5>
                                            <p>Parallel computing is a computational approach where multiple processors work simultaneously on different parts of a problem to achieve faster execution times and solve larger problems than would be possible with a single processor.</p>
                                            
                                            <div class="alert alert-info">
                                                <strong>Key Characteristics:</strong>
                                                <ul>
                                                    <li>Simultaneous execution of multiple instructions or data operations</li>
                                                    <li>Resource sharing among multiple processing elements</li>
                                                    <li>Coordination and synchronization mechanisms</li>
                                                    <li>Scalability across different problem sizes</li>
                                                    <li>Performance improvement through concurrency</li>
                                                </ul>
                                            </div>
                                            
                                            <h5>Levels of Parallelism:</h5>
                                            <ul>
                                                <li><strong>Bit-level Parallelism:</strong> Processing multiple bits simultaneously (e.g., 32-bit vs. 8-bit operations)</li>
                                                <li><strong>Instruction-level Parallelism (ILP):</strong> Multiple instructions executed simultaneously</li>
                                                <li><strong>Data-level Parallelism (DLP):</strong> Same operation performed on multiple data elements</li>
                                                <li><strong>Task-level Parallelism (TLP):</strong> Different operations performed simultaneously on different data</li>
                                                <li><strong>Thread-level Parallelism:</strong> Multiple threads executing in parallel</li>
                                            </ul>
                                            
                                            <h5>Historical Development:</h5>
                                            <ol>
                                                <li><strong>1960s:</strong> First supercomputers (CDC 6600, IBM System/360)</li>
                                                <li><strong>1970s:</strong> Vector processors (Cray-1)</li>
                                                <li><strong>1980s:</strong> Massively parallel processors (Connection Machine)</li>
                                                <li><strong>1990s:</strong> Symmetric multiprocessing (SMP) systems</li>
                                                <li><strong>2000s:</strong> Multicore processors become mainstream</li>
                                                <li><strong>2010s:</strong> Heterogeneous computing (CPU+GPU)</li>
                                                <li><strong>2020s:</strong> Specialized AI accelerators and domain-specific architectures</li>
                                            </ol>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Classification Parameters</div>
                                        <div class="card-body">
                                            <h5>Primary Classification Dimensions:</h5>
                                            
                                            <h6>1. Processing Element Organization:</h6>
                                            <ul>
                                                <li><strong>Homogeneous:</strong> Identical processing elements</li>
                                                <li><strong>Heterogeneous:</strong> Different types of processing elements (e.g., CPU+GPU)</li>
                                            </ul>
                                            
                                            <h6>2. Control Mechanism:</h6>
                                            <ul>
                                                <li><strong>SISD:</strong> Single Instruction, Single Data (conventional)</li>
                                                <li><strong>SIMD:</strong> Single Instruction, Multiple Data (vector processing)</li>
                                                <li><strong>MISD:</strong> Multiple Instruction, Single Data (rare)</li>
                                                <li><strong>MIMD:</strong> Multiple Instruction, Multiple Data (most common)</li>
                                            </ul>
                                            
                                            <h6>3. Memory Architecture:</h6>
                                            <ul>
                                                <li><strong>Shared Memory:</strong> All processors access a common memory space</li>
                                                <li><strong>Distributed Memory:</strong> Each processor has private memory</li>
                                                <li><strong>Hybrid:</strong> Combination of shared and distributed approaches</li>
                                            </ul>
                                            
                                            <h6>4. Interconnection Network:</h6>
                                            <ul>
                                                <li><strong>Bus-based:</strong> Single shared communication path</li>
                                                <li><strong>Switched:</strong> Point-to-point connections (mesh, torus, hypercube)</li>
                                                <li><strong>Hierarchical:</strong> Multi-level interconnection</li>
                                            </ul>
                                            
                                            <h6>5. Granularity:</h6>
                                            <ul>
                                                <li><strong>Fine-grained:</strong> Many small tasks with frequent communication</li>
                                                <li><strong>Coarse-grained:</strong> Fewer large tasks with less frequent communication</li>
                                            </ul>
                                            
                                            <h6>6. Programming Model:</h6>
                                            <ul>
                                                <li><strong>Shared Memory:</strong> OpenMP, POSIX threads</li>
                                                <li><strong>Message Passing:</strong> MPI</li>
                                                <li><strong>Data Parallel:</strong> CUDA, OpenCL</li>
                                                <li><strong>Hybrid:</strong> MPI+OpenMP</li>
                                            </ul>
                                            
                                            <div class="alert alert-warning mt-3">
                                                <strong>Practical Classification Challenges:</strong>
                                                <p>Modern systems often blur traditional classification boundaries, combining multiple approaches. For example, a cluster of multicore nodes represents both distributed memory (across nodes) and shared memory (within each node).</p>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Major Classes of Parallel Systems</div>
                                        <div class="card-body">
                                            <div class="row">
                                                <div class="col-md-6">
                                                    <h5>Shared Memory Systems:</h5>
                                                    
                                                    <h6>1. Symmetric Multiprocessors (SMP):</h6>
                                                    <div class="alert alert-secondary">
                                                        <p><strong>Definition:</strong> Multiple identical processors that share a common memory</p>
                                                        <ul>
                                                            <li><strong>Memory Access:</strong> Uniform access time (UMA)</li>
                                                            <li><strong>Scale:</strong> Limited to dozens of processors</li>
                                                            <li><strong>Examples:</strong> Modern server systems, multicore desktops</li>
                                                            <li><strong>Advantages:</strong> Ease of programming, fast communication</li>
                                                            <li><strong>Challenges:</strong> Memory contention, cache coherence, limited scalability</li>
                                                        </ul>
                                                        <div class="text-center mt-2">
                                                            <svg width="100%" height="120" viewBox="0 0 300 120">
                                                                <rect x="10" y="10" width="50" height="40" fill="#bbdefb" stroke="#0d47a1"/>
                                                                <rect x="70" y="10" width="50" height="40" fill="#bbdefb" stroke="#0d47a1"/>
                                                                <rect x="130" y="10" width="50" height="40" fill="#bbdefb" stroke="#0d47a1"/>
                                                                <rect x="190" y="10" width="50" height="40" fill="#bbdefb" stroke="#0d47a1"/>
                                                                <rect x="10" y="70" width="230" height="40" fill="#ffcdd2" stroke="#b71c1c"/>
                                                                <text x="35" y="35" text-anchor="middle" font-size="10">CPU 1</text>
                                                                <text x="95" y="35" text-anchor="middle" font-size="10">CPU 2</text>
                                                                <text x="155" y="35" text-anchor="middle" font-size="10">CPU 3</text>
                                                                <text x="215" y="35" text-anchor="middle" font-size="10">CPU 4</text>
                                                                <text x="125" y="95" text-anchor="middle" font-size="10">Shared Memory</text>
                                                                <line x1="35" y1="50" x2="35" y2="70" stroke="#000" stroke-width="2"/>
                                                                <line x1="95" y1="50" x2="95" y2="70" stroke="#000" stroke-width="2"/>
                                                                <line x1="155" y1="50" x2="155" y2="70" stroke="#000" stroke-width="2"/>
                                                                <line x1="215" y1="50" x2="215" y2="70" stroke="#000" stroke-width="2"/>
                                                            </svg>
                                                        </div>
                                                    </div>
                                                    
                                                    <h6>2. Non-Uniform Memory Access (NUMA):</h6>
                                                    <div class="alert alert-secondary">
                                                        <p><strong>Definition:</strong> Multiple processors with different access times to different memory regions</p>
                                                        <ul>
                                                            <li><strong>Memory Access:</strong> Faster to local memory, slower to remote memory</li>
                                                            <li><strong>Scale:</strong> Can scale to hundreds of processors</li>
                                                            <li><strong>Examples:</strong> SGI Origin, modern multi-socket servers</li>
                                                            <li><strong>Advantages:</strong> Better scalability than UMA, locality exploitation</li>
                                                            <li><strong>Challenges:</strong> Performance tuning for locality, complex synchronization</li>
                                                        </ul>
                                                    </div>
                                                </div>
                                                <div class="col-md-6">
                                                    <h5>Distributed Memory Systems:</h5>
                                                    
                                                    <h6>1. Massively Parallel Processors (MPP):</h6>
                                                    <div class="alert alert-secondary">
                                                        <p><strong>Definition:</strong> Large number of processors, each with private memory, connected by a high-speed network</p>
                                                        <ul>
                                                            <li><strong>Memory Access:</strong> No direct access to remote memory</li>
                                                            <li><strong>Scale:</strong> Thousands to millions of processors</li>
                                                            <li><strong>Examples:</strong> IBM Blue Gene, Cray XT series</li>
                                                            <li><strong>Advantages:</strong> Excellent scalability, no contention for memory</li>
                                                            <li><strong>Challenges:</strong> Complex programming, communication overhead</li>
                                                        </ul>
                                                    </div>
                                                    
                                                    <h6>2. Clusters:</h6>
                                                    <div class="alert alert-secondary">
                                                        <p><strong>Definition:</strong> Collection of independent computers connected by a network</p>
                                                        <ul>
                                                            <li><strong>Memory Access:</strong> Distributed with message passing</li>
                                                            <li><strong>Scale:</strong> Tens to thousands of nodes</li>
                                                            <li><strong>Examples:</strong> Beowulf clusters, commercial cloud computing</li>
                                                            <li><strong>Advantages:</strong> Cost-effective, incremental scalability</li>
                                                            <li><strong>Challenges:</strong> Network latency, fault tolerance</li>
                                                        </ul>
                                                    </div>
                                                    
                                                    <h6>3. Grid and Cloud Computing:</h6>
                                                    <div class="alert alert-secondary">
                                                        <p><strong>Definition:</strong> Geographically distributed resources coordinated to solve problems</p>
                                                        <ul>
                                                            <li><strong>Memory Access:</strong> Highly distributed, heterogeneous</li>
                                                            <li><strong>Scale:</strong> Potentially unlimited</li>
                                                            <li><strong>Examples:</strong> AWS, Google Cloud, SETI@Home</li>
                                                            <li><strong>Advantages:</strong> Resource sharing, availability, elasticity</li>
                                                            <li><strong>Challenges:</strong> Security, reliability, performance variability</li>
                                                        </ul>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('5.5')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('6.2')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 6.2: Flynn's Taxonomy -->
                    <div class="slide" id="slide-6.2">
                        <h2 class="slide-title">Flynn's Taxonomy</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Flynn's Taxonomy: Foundation</div>
                                        <div class="card-body">
                                            <h5>Overview and Historical Context:</h5>
                                            <p>Flynn's Taxonomy, proposed by Michael J. Flynn in 1966, classifies computer architectures based on two fundamental concepts: instruction streams and data streams. It remains the most widely used classification scheme for parallel architectures.</p>
                                            
                                            <div class="alert alert-info">
                                                <strong>Core Classification Dimensions:</strong>
                                                <ul>
                                                    <li><strong>Instruction Stream:</strong> Sequence of instructions performed by the computer</li>
                                                    <li><strong>Data Stream:</strong> Sequence of data operated on by the instructions</li>
                                                    <li><strong>Stream Quantity:</strong> Single (S) or Multiple (M)</li>
                                                </ul>
                                            </div>
                                            
                                            <h5>The Four Basic Categories:</h5>
                                            <ol>
                                                <li><strong>SISD:</strong> Single Instruction Stream, Single Data Stream</li>
                                                <li><strong>SIMD:</strong> Single Instruction Stream, Multiple Data Streams</li>
                                                <li><strong>MISD:</strong> Multiple Instruction Streams, Single Data Stream</li>
                                                <li><strong>MIMD:</strong> Multiple Instruction Streams, Multiple Data Streams</li>
                                            </ol>
                                            
                                            <h5>Flynn's Taxonomy: Conceptual Matrix</h5>
                                            <table class="table table-bordered">
                                                <thead class="table-dark">
                                                    <tr>
                                                        <th></th>
                                                        <th>Single Data Stream</th>
                                                        <th>Multiple Data Streams</th>
                                                    </tr>
                                                </thead>
                                                <tbody>
                                                    <tr>
                                                        <th>Single Instruction Stream</th>
                                                        <td>SISD</td>
                                                        <td>SIMD</td>
                                                    </tr>
                                                    <tr>
                                                        <th>Multiple Instruction Streams</th>
                                                        <td>MISD</td>
                                                        <td>MIMD</td>
                                                    </tr>
                                                </tbody>
                                            </table>
                                            
                                            <h5>Limitations of Flynn's Taxonomy:</h5>
                                            <ul>
                                                <li>Does not capture memory organization (shared vs. distributed)</li>
                                                <li>No distinction between synchronous and asynchronous execution</li>
                                                <li>Cannot adequately classify hybrid architectures</li>
                                                <li>Does not address granularity of parallelism</li>
                                                <li>Modern architectures often implement multiple categories simultaneously</li>
                                            </ul>
                                            
                                            <div class="alert alert-warning">
                                                <strong>Note:</strong> Despite its limitations, Flynn's Taxonomy provides a useful conceptual framework for understanding parallel systems and remains the standard terminology in computer architecture.
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Detailed Analysis of Flynn's Categories</div>
                                        <div class="card-body">
                                            <h5>SISD (Single Instruction, Single Data):</h5>
                                            <div class="alert alert-secondary">
                                                <p><strong>Definition:</strong> A sequential computer which executes one instruction stream on one data stream.</p>
                                                <ul>
                                                    <li><strong>Model:</strong> von Neumann architecture</li>
                                                    <li><strong>Examples:</strong> Early microprocessors (8086, 68000)</li>
                                                    <li><strong>Parallelism:</strong> Limited to pipelined execution</li>
                                                    <li><strong>Control Flow:</strong> Centralized, sequential</li>
                                                </ul>
                                                <div class="text-center mt-2">
                                                    <svg width="100%" height="100" viewBox="0 0 300 100">
                                                        <rect x="10" y="10" width="120" height="40" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <rect x="170" y="10" width="120" height="40" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <rect x="90" y="60" width="120" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <text x="70" y="35" text-anchor="middle" font-size="12">Instruction Stream</text>
                                                        <text x="230" y="35" text-anchor="middle" font-size="12">Data Stream</text>
                                                        <text x="150" y="80" text-anchor="middle" font-size="12">Processing Unit</text>
                                                        <line x1="70" y1="50" x2="150" y2="60" stroke="#000" stroke-width="2"/>
                                                        <line x1="230" y1="50" x2="150" y2="60" stroke="#000" stroke-width="2"/>
                                                    </svg>
                                                </div>
                                            </div>
                                            
                                            <h5>SIMD (Single Instruction, Multiple Data):</h5>
                                            <div class="alert alert-secondary">
                                                <p><strong>Definition:</strong> A computer that executes the same instruction on multiple data elements simultaneously.</p>
                                                <ul>
                                                    <li><strong>Model:</strong> Data parallel processing</li>
                                                    <li><strong>Examples:</strong> Vector processors, GPU architectures, SIMD extensions (SSE, AVX)</li>
                                                    <li><strong>Parallelism:</strong> Exploits data-level parallelism</li>
                                                    <li><strong>Control Flow:</strong> Centralized, synchronized</li>
                                                </ul>
                                                <div class="text-center mt-2">
                                                    <svg width="100%" height="150" viewBox="0 0 300 150">
                                                        <rect x="90" y="10" width="120" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <rect x="10" y="50" width="60" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <rect x="80" y="50" width="60" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <rect x="150" y="50" width="60" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <rect x="220" y="50" width="60" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <rect x="10" y="100" width="60" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <rect x="80" y="100" width="60" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <rect x="150" y="100" width="60" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <rect x="220" y="100" width="60" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <text x="150" y="30" text-anchor="middle" font-size="12">Instruction Stream</text>
                                                        <text x="40" y="70" text-anchor="middle" font-size="12">Data 1</text>
                                                        <text x="110" y="70" text-anchor="middle" font-size="12">Data 2</text>
                                                        <text x="180" y="70" text-anchor="middle" font-size="12">Data 3</text>
                                                        <text x="250" y="70" text-anchor="middle" font-size="12">Data 4</text>
                                                        <text x="40" y="120" text-anchor="middle" font-size="10">Processing</text>
                                                        <text x="110" y="120" text-anchor="middle" font-size="10">Processing</text>
                                                        <text x="180" y="120" text-anchor="middle" font-size="10">Processing</text>
                                                        <text x="250" y="120" text-anchor="middle" font-size="10">Processing</text>
                                                        <line x1="150" y1="40" x2="40" y2="50" stroke="#000" stroke-width="1"/>
                                                        <line x1="150" y1="40" x2="110" y2="50" stroke="#000" stroke-width="1"/>
                                                        <line x1="150" y1="40" x2="180" y2="50" stroke="#000" stroke-width="1"/>
                                                        <line x1="150" y1="40" x2="250" y2="50" stroke="#000" stroke-width="1"/>
                                                        <line x1="40" y1="80" x2="40" y2="100" stroke="#000" stroke-width="1"/>
                                                        <line x1="110" y1="80" x2="110" y2="100" stroke="#000" stroke-width="1"/>
                                                        <line x1="180" y1="80" x2="180" y2="100" stroke="#000" stroke-width="1"/>
                                                        <line x1="250" y1="80" x2="250" y2="100" stroke="#000" stroke-width="1"/>
                                                    </svg>
                                                </div>
                                            </div>
                                            
                                            <h5>MISD (Multiple Instruction, Single Data):</h5>
                                            <div class="alert alert-secondary">
                                                <p><strong>Definition:</strong> Multiple instructions operate on the same data stream simultaneously.</p>
                                                <ul>
                                                    <li><strong>Model:</strong> Pipeline or systolic array processing</li>
                                                    <li><strong>Examples:</strong> Rare in practice; some specialized fault-tolerant systems</li>
                                                    <li><strong>Parallelism:</strong> Instruction-level parallelism</li>
                                                    <li><strong>Control Flow:</strong> Distributed but synchronized</li>
                                                </ul>
                                                <div class="text-center mt-2">
                                                    <svg width="100%" height="120" viewBox="0 0 300 120">
                                                        <rect x="10" y="10" width="60" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <rect x="80" y="10" width="60" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <rect x="150" y="10" width="60" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <rect x="220" y="10" width="60" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <rect x="140" y="60" width="100" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <rect x="10" y="80" width="60" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <rect x="80" y="80" width="60" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <rect x="150" y="80" width="60" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <rect x="220" y="80" width="60" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <text x="40" y="30" text-anchor="middle" font-size="10">Instr 1</text>
                                                        <text x="110" y="30" text-anchor="middle" font-size="10">Instr 2</text>
                                                        <text x="180" y="30" text-anchor="middle" font-size="10">Instr 3</text>
                                                        <text x="250" y="30" text-anchor="middle" font-size="10">Instr 4</text>
                                                        <text x="190" y="80" text-anchor="middle" font-size="12">Data Stream</text>
                                                        <text x="40" y="100" text-anchor="middle" font-size="10">Processing</text>
                                                        <text x="110" y="100" text-anchor="middle" font-size="10">Processing</text>
                                                        <text x="180" y="100" text-anchor="middle" font-size="10">Processing</text>
                                                        <text x="250" y="100" text-anchor="middle" font-size="10">Processing</text>
                                                        <line x1="40" y1="40" x2="40" y2="80" stroke="#000" stroke-width="1"/>
                                                        <line x1="110" y1="40" x2="110" y2="80" stroke="#000" stroke-width="1"/>
                                                        <line x1="180" y1="40" x2="180" y2="80" stroke="#000" stroke-width="1"/>
                                                        <line x1="250" y1="40" x2="250" y2="80" stroke="#000" stroke-width="1"/>
                                                        <line x1="190" y1="90" x2="40" y2="80" stroke="#000" stroke-width="1"/>
                                                        <line x1="190" y1="90" x2="110" y2="80" stroke="#000" stroke-width="1"/>
                                                        <line x1="190" y1="90" x2="180" y2="80" stroke="#000" stroke-width="1"/>
                                                        <line x1="190" y1="90" x2="250" y2="80" stroke="#000" stroke-width="1"/>
                                                    </svg>
                                                </div>
                                            </div>
                                            
                                            <h5>MIMD (Multiple Instruction, Multiple Data):</h5>
                                            <div class="alert alert-secondary">
                                                <p><strong>Definition:</strong> Multiple autonomous processors executing different instructions on different data sets.</p>
                                                <ul>
                                                    <li><strong>Model:</strong> Independent computing elements</li>
                                                    <li><strong>Examples:</strong> Multiprocessor systems, clusters, distributed systems, multi-core CPUs</li>
                                                    <li><strong>Parallelism:</strong> Task-level and thread-level parallelism</li>
                                                    <li><strong>Control Flow:</strong> Distributed, potentially asynchronous</li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Flynn's Taxonomy in Modern Computing</div>
                                        <div class="card-body">
                                            <div class="row">
                                                <div class="col-md-7">
                                                    <h5>Contemporary Applications of Flynn's Categories:</h5>
                                                    <table class="table table-striped">
                                                        <thead>
                                                            <tr>
                                                                <th>Category</th>
                                                                <th>Traditional Examples</th>
                                                                <th>Modern Examples</th>
                                                                <th>Common Applications</th>
                                                            </tr>
                                                        </thead>
                                                        <tbody>
                                                            <tr>
                                                                <td><strong>SISD</strong></td>
                                                                <td>Early microprocessors (8086)</td>
                                                                <td>Single-core processors (though with ILP)</td>
                                                                <td>General-purpose computing, legacy systems</td>
                                                            </tr>
                                                            <tr>
                                                                <td><strong>SIMD</strong></td>
                                                                <td>Cray vector processors</td>
                                                                <td>GPUs, AVX/SSE instructions, TPUs</td>
                                                                <td>Graphics, machine learning, scientific computing</td>
                                                            </tr>
                                                            <tr>
                                                                <td><strong>MISD</strong></td>
                                                                <td>Systolic arrays</td>
                                                                <td>Some specialized fault-tolerant systems</td>
                                                                <td>Fault tolerance, space systems, real-time filtering</td>
                                                            </tr>
                                                            <tr>
                                                                <td><strong>MIMD</strong></td>
                                                                <td>Early multiprocessors</td>
                                                                <td>Multi-core CPUs, clusters, cloud computing</td>
                                                                <td>General-purpose parallel computing, servers, HPC</td>
                                                            </tr>
                                                        </tbody>
                                                    </table>
                                                    
                                                    <h5>Extensions to Flynn's Taxonomy:</h5>
                                                    <ul>
                                                        <li><strong>SPMD (Single Program, Multiple Data):</strong> Multiple autonomous processors executing the same program on different data</li>
                                                        <li><strong>MPMD (Multiple Program, Multiple Data):</strong> Multiple autonomous processors executing different programs on different data</li>
                                                        <li><strong>Vector-SIMD:</strong> Specialized for vector operations</li>
                                                        <li><strong>Processor Arrays:</strong> Specialized SIMD configurations</li>
                                                    </ul>
                                                </div>
                                                <div class="col-md-5">
                                                    <h5>MIMD Subcategories:</h5>
                                                    <div class="alert alert-secondary">
                                                        <h6>1. Based on Memory Organization:</h6>
                                                        <ul>
                                                            <li><strong>Shared Memory MIMD:</strong>
                                                                <ul>
                                                                    <li>UMA (Uniform Memory Access)</li>
                                                                    <li>NUMA (Non-Uniform Memory Access)</li>
                                                                    <li>COMA (Cache-Only Memory Architecture)</li>
                                                                </ul>
                                                            </li>
                                                            <li><strong>Distributed Memory MIMD:</strong>
                                                                <ul>
                                                                    <li>MPP (Massively Parallel Processors)</li>
                                                                    <li>Clusters</li>
                                                                    <li>Grid Computing</li>
                                                                </ul>
                                                            </li>
                                                        </ul>
                                                    </div>
                                                    
                                                    <h6>2. Modern Hybrid Approaches:</h6>
                                                    <div class="alert alert-info">
                                                        <p>Many current systems combine multiple Flynn categories:</p>
                                                        <ul>
                                                            <li><strong>Multi-core CPUs:</strong> MIMD at core level, SIMD within cores (vector units)</li>
                                                            <li><strong>GPU Computing:</strong> SIMD within compute units, MIMD across blocks</li>
                                                            <li><strong>Heterogeneous Computing:</strong> CPU (MIMD) + GPU (SIMD) + Specialized accelerators</li>
                                                            <li><strong>Clusters of Multicore Nodes:</strong> MIMD across nodes, MIMD within nodes, SIMD within cores</li>
                                                        </ul>
                                                    </div>
                                                    
                                                    <div class="text-center mt-2">
                                                        <svg width="100%" height="150" viewBox="0 0 300 150">
                                                            <rect x="20" y="10" width="100" height="60" fill="#e8f5e9" stroke="#2e7d32"/>
                                                            <rect x="30" y="20" width="35" height="20" fill="#a5d6a7" stroke="#2e7d32"/>
                                                            <rect x="75" y="20" width="35" height="20" fill="#a5d6a7" stroke="#2e7d32"/>
                                                            <rect x="30" y="45" width="35" height="20" fill="#a5d6a7" stroke="#2e7d32"/>
                                                            <rect x="75" y="45" width="35" height="20" fill="#a5d6a7" stroke="#2e7d32"/>
                                                            <text x="70" y="15" text-anchor="middle" font-size="8">Multi-core CPU (MIMD)</text>
                                                            <text x="47" y="32" text-anchor="middle" font-size="8">Core</text>
                                                            <text x="92" y="32" text-anchor="middle" font-size="8">Core</text>
                                                            <text x="47" y="57" text-anchor="middle" font-size="8">Core</text>
                                                            <text x="92" y="57" text-anchor="middle" font-size="8">Core</text>
                                                            
                                                            <rect x="180" y="10" width="100" height="60" fill="#f3e5f5" stroke="#4a148c"/>
                                                            <rect x="190" y="20" width="80" height="40" fill="#ce93d8" stroke="#4a148c"/>
                                                            <text x="230" y="15" text-anchor="middle" font-size="8">GPU (SIMD)</text>
                                                            <text x="230" y="40" text-anchor="middle" font-size="8">Many Parallel</text>
                                                            <text x="230" y="50" text-anchor="middle" font-size="8">Processing Units</text>
                                                            
                                                            <rect x="20" y="90" width="260" height="30" fill="#e3f2fd" stroke="#0d47a1"/>
                                                            <text x="150" y="110" text-anchor="middle" font-size="10">System Interconnect (Network, Bus, etc.)</text>
                                                            
                                                            <rect x="20" y="125" width="260" height="20" fill="#ffebee" stroke="#b71c1c"/>
                                                            <text x="150" y="140" text-anchor="middle" font-size="10">Memory System</text>
                                                            
                                                            <line x1="70" y1="70" x2="70" y2="90" stroke="#000" stroke-width="1"/>
                                                            <line x1="230" y1="70" x2="230" y2="90" stroke="#000" stroke-width="1"/>
                                                            <line x1="150" y1="120" x2="150" y2="125" stroke="#000" stroke-width="1"/>
                                                        </svg>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('6.1')">Previous</button>
                            <button class   ="btn btn-primary" onclick="navigateToSlide('6.3')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 6.3: Array Processors -->
                    <div class="slide" id="slide-6.3">
                        <h2 class="slide-title">Array Processors</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Array Processor Fundamentals</div>
                                        <div class="card-body">
                                            <h5>Definition and Core Concepts:</h5>
                                            <p>Array processors are specialized computing systems designed to perform the same operation simultaneously on multiple data elements arranged in arrays or matrices. They exploit data-level parallelism for efficient computation of regular data structures.</p>
                                            
                                            <div class="alert alert-info">
                                                <strong>Key Characteristics:</strong>
                                                <ul>
                                                    <li>SIMD architecture (Single Instruction, Multiple Data)</li>
                                                    <li>Multiple processing elements operating in lockstep</li>
                                                    <li>Regular interconnection topology</li>
                                                    <li>Synchronized execution model</li>
                                                    <li>Optimized for data-parallel computations</li>
                                                </ul>
                                            </div>
                                            
                                            <h5>Historical Evolution:</h5>
                                            <ul>
                                                <li><strong>1960s:</strong> SOLOMON design (first array processor concept)</li>
                                                <li><strong>1970s:</strong> ILLIAC IV (first operational array processor)</li>
                                                <li><strong>1980s:</strong> Connection Machine (massively parallel processor)</li>
                                                <li><strong>1990s:</strong> Vector supercomputers (Cray, NEC)</li>
                                                <li><strong>2000s:</strong> GPU computing emerges</li>
                                                <li><strong>2010s:</strong> Specialized AI accelerators</li>
                                                <li><strong>2020s:</strong> Domain-specific array processors</li>
                                            </ul>
                                            
                                            <h5>Computational Strengths:</h5>
                                            <p>Array processors excel at operations that exhibit:</p>
                                            <ul>
                                                <li><strong>Data Regularity:</strong> Same operation applied to all elements</li>
                                                <li><strong>Spatial Locality:</strong> Operations on neighboring data elements</li>
                                                <li><strong>High Computation-to-Communication Ratio:</strong> Minimal data movement</li>
                                                <li><strong>Massively Parallel Workloads:</strong> Many identical operations</li>
                                            </ul>
                                            
                                            <h5>Primary Applications:</h5>
                                            <ul>
                                                <li>Scientific computing (simulations, finite element analysis)</li>
                                                <li>Signal and image processing</li>
                                                <li>Neural network training and inference</li>
                                                <li>Weather modeling and climate simulations</li>
                                                <li>Computational fluid dynamics</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Array Processor Architectures</div>
                                        <div class="card-body">
                                            <h5>Major Types of Array Processors:</h5>
                                            
                                            <h6>1. Vector Processors:</h6>
                                            <div class="alert alert-secondary">
                                                <p><strong>Definition:</strong> Processors with specialized hardware for vector operations</p>
                                                <ul>
                                                    <li><strong>Operation:</strong> Apply single instruction to vectors of data</li>
                                                    <li><strong>Vector Registers:</strong> Hold multiple data elements</li>
                                                    <li><strong>Pipeline Implementation:</strong> Overlapped vector element processing</li>
                                                    <li><strong>Examples:</strong> Cray-1, NEC SX series, modern SIMD extensions</li>
                                                    <li><strong>ISA Features:</strong> Vector load/store, vector arithmetic, mask operations</li>
                                                </ul>
                                            </div>
                                            
                                            <h6>2. SIMD Processor Arrays:</h6>
                                            <div class="alert alert-secondary">
                                                <p><strong>Definition:</strong> Multiple processing elements controlled by a central unit</p>
                                                <ul>
                                                    <li><strong>Structure:</strong> Grid of processing elements (PEs)</li>
                                                    <li><strong>Control:</strong> Central controller broadcasts instructions</li>
                                                    <li><strong>Interconnection:</strong> Nearest-neighbor connections</li>
                                                    <li><strong>Memory:</strong> Local memory per PE plus global memory</li>
                                                    <li><strong>Examples:</strong> ILLIAC IV, Connection Machine CM-1</li>
                                                </ul>
                                                <div class="text-center mt-2">
                                                    <svg width="100%" height="140" viewBox="0 0 300 140">
                                                        <rect x="120" y="10" width="60" height="30" fill="#b3e5fc" stroke="#01579b"/>
                                                        <text x="150" y="30" text-anchor="middle" font-size="10">Control Unit</text>
                                                        
                                                        <rect x="50" y="60" width="40" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <rect x="100" y="60" width="40" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <rect x="150" y="60" width="40" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <rect x="200" y="60" width="40" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        
                                                        <rect x="50" y="100" width="40" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <rect x="100" y="100" width="40" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <rect x="150" y="100" width="40" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        <rect x="200" y="100" width="40" height="30" fill="#e1f5fe" stroke="#0288d1"/>
                                                        
                                                        <text x="70" y="80" text-anchor="middle" font-size="10">PE</text>
                                                        <text x="120" y="80" text-anchor="middle" font-size="10">PE</text>
                                                        <text x="170" y="80" text-anchor="middle" font-size="10">PE</text>
                                                        <text x="220" y="80" text-anchor="middle" font-size="10">PE</text>
                                                        
                                                        <text x="70" y="120" text-anchor="middle" font-size="10">PE</text>
                                                        <text x="120" y="120" text-anchor="middle" font-size="10">PE</text>
                                                        <text x="170" y="120" text-anchor="middle" font-size="10">PE</text>
                                                        <text x="220" y="120" text-anchor="middle" font-size="10">PE</text>
                                                        
                                                        <line x1="150" y1="40" x2="70" y2="60" stroke="#000" stroke-width="1"/>
                                                        <line x1="150" y1="40" x2="120" y2="60" stroke="#000" stroke-width="1"/>
                                                        <line x1="150" y1="40" x2="170" y2="60" stroke="#000" stroke-width="1"/>
                                                        <line x1="150" y1="40" x2="220" y2="60" stroke="#000" stroke-width="1"/>
                                                        
                                                        <line x1="70" y1="90" x2="70" y2="100" stroke="#000" stroke-width="1"/>
                                                        <line x1="120" y1="90" x2="120" y2="100" stroke="#000" stroke-width="1"/>
                                                        <line x1="170" y1="90" x2="170" y2="100" stroke="#000" stroke-width="1"/>
                                                        <line x1="220" y1="90" x2="220" y2="100" stroke="#000" stroke-width="1"/>
                                                        
                                                        <line x1="90" y1="75" x2="100" y2="75" stroke="#000" stroke-width="1"/>
                                                        <line x1="140" y1="75" x2="150" y2="75" stroke="#000" stroke-width="1"/>
                                                        <line x1="190" y1="75" x2="200" y2="75" stroke="#000" stroke-width="1"/>
                                                        
                                                        <line x1="90" y1="115" x2="100" y2="115" stroke="#000" stroke-width="1"/>
                                                        <line x1="140" y1="115" x2="150" y2="115" stroke="#000" stroke-width="1"/>
                                                        <line x1="190" y1="115" x2="200" y2="115" stroke="#000" stroke-width="1"/>
                                                    </svg>
                                                </div>
                                            </div>
                                            
                                            <h6>3. Systolic Arrays:</h6>
                                            <div class="alert alert-secondary">
                                                <p><strong>Definition:</strong> Array of processors that rhythmically process and pass data</p>
                                                <ul>
                                                    <li><strong>Structure:</strong> Regular array of simple processing cells</li>
                                                    <li><strong>Data Flow:</strong> Synchronized movement between adjacent cells</li>
                                                    <li><strong>Memory Access:</strong> Minimized by cascading results</li>
                                                    <li><strong>Advantages:</strong> High throughput, energy efficiency</li>
                                                    <li><strong>Examples:</strong> Google TPU, specialized matrix processors</li>
                                                </ul>
                                            </div>
                                            
                                            <h6>4. Modern GPUs (Graphics Processing Units):</h6>
                                            <div class="alert alert-secondary">
                                                <p><strong>Definition:</strong> Massively parallel processors with SIMD execution units</p>
                                                <ul>
                                                    <li><strong>Structure:</strong> Multiple streaming multiprocessors (SMs)</li>
                                                    <li><strong>Execution Model:</strong> SIMT (Single Instruction, Multiple Threads)</li>
                                                    <li><strong>Memory Hierarchy:</strong> Complex with multiple caches and shared memory</li>
                                                    <li><strong>Programmability:</strong> CUDA, OpenCL, DirectCompute</li>
                                                    <li><strong>Examples:</strong> NVIDIA RTX series, AMD Radeon, Intel Arc</li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>

                            <div class="row mt-3">
                                <div class="col-md-12">
                                    <div class="card">
                                        <div class="card-header bg-info text-white">Programming and Performance Considerations</div>
                                        <div class="card-body">
                                            <div class="row">
                                                <div class="col-md-6">
                                                    <h5>Programming Models for Array Processors:</h5>
                                                    
                                                    <h6>1. Vector Programming:</h6>
                                                    <div class="alert alert-secondary">
                                                        <p><strong>Approach:</strong> Express computations as operations on vectors</p>
                                                        <ul>
                                                            <li><strong>Language Features:</strong> Vector data types, vector operations</li>
                                                            <li><strong>Examples:</strong> Fortran 90 array syntax, NumPy, vectorized C++</li>
                                                            <li><strong>Code Example:</strong></li>
                                                        </ul>
                                                        <pre class="bg-light p-2">
// Scalar version (sequential)
for (int i = 0; i < N; i++) {
C[i] = A[i] + B[i];
}

// Vector version (parallel)
vec_add(C, A, B, N);  // Hardware vector operation</pre>
                                                    </div>
                                                    
                                                    <h6>2. Data-Parallel Programming:</h6>
                                                    <div class="alert alert-secondary">
                                                        <p><strong>Approach:</strong> Apply same operation to all elements of a collection</p>
                                                        <ul>
                                                            <li><strong>Paradigm:</strong> Map operations across data sets</li>
                                                            <li><strong>Examples:</strong> OpenCL, CUDA, OpenACC</li>
                                                            <li><strong>Code Example:</strong></li>
                                                        </ul>
                                                        <pre class="bg-light p-2">
// CUDA kernel for vector addition
__global__ void vecAdd(float *A, float *B, float *C, int N) {
int i = blockIdx.x * blockDim.x + threadIdx.x;
if (i < N) {
C[i] = A[i] + B[i];
}
}</pre>
                                                    </div>
                                                    
                                                    <h6>3. Systolic Array Programming:</h6>
                                                    <div class="alert alert-secondary">
                                                        <p><strong>Approach:</strong> Design algorithms for pipelined data flow</p>
                                                        <ul>
                                                            <li><strong>Focus:</strong> Data movement patterns and timing</li>
                                                            <li><strong>Challenges:</strong> Mapping algorithms to fixed hardware patterns</li>
                                                            <li><strong>Modern Example:</strong> TensorFlow operations on Google TPU</li>
                                                        </ul>
                                                    </div>
                                                </div>
                                                <div class="col-md-6">
                                                    <h5>Performance Optimization Techniques:</h5>
                                                    
                                                    <h6>1. Vectorization Strategies:</h6>
                                                    <ul>
                                                        <li><strong>Loop Vectorization:</strong> Transform loops to use vector instructions</li>
                                                        <li><strong>Memory Access Patterns:</strong> Align and coalesce memory accesses</li>
                                                        <li><strong>Strided Access Handling:</strong> Minimize gather/scatter operations</li>
                                                        <li><strong>Vector Length Optimization:</strong> Match hardware vector sizes</li>
                                                    </ul>
                                                    
                                                    <h6>2. Data Layout Optimization:</h6>
                                                    <ul>
                                                        <li><strong>Structure of Arrays (SoA):</strong> Better for SIMD operations</li>
                                                        <li><strong>Array of Structures (AoS):</strong> Better for object locality</li>
                                                        <li><strong>Padding:</strong> Ensure proper alignment for vector operations</li>
                                                        <li><strong>Tiling:</strong> Reorganize computations to improve cache use</li>
                                                    </ul>
                                                    
                                                    <h6>3. Workload Mapping:</h6>
                                                    <ul>
                                                        <li><strong>Balanced Distribution:</strong> Equal work across processing elements</li>
                                                        <li><strong>Locality Preservation:</strong> Keep related computations close</li>
                                                        <li><strong>Communication Minimization:</strong> Reduce data movement</li>
                                                        <li><strong>Conditional Execution:</strong> Handle divergent paths efficiently</li>
                                                    </ul>
                                                    
                                                    <h5>Performance Challenges:</h5>
                                                    <div class="alert alert-warning">
                                                        <ul>
                                                            <li><strong>Amdahl's Law Limitations:</strong> Sequential portions limit speedup</li>
                                                            <li><strong>Memory Bandwidth Bottlenecks:</strong> Data movement constraints</li>
                                                            <li><strong>Synchronization Overhead:</strong> Coordination costs</li>
                                                            <li><strong>Irregular Computations:</strong> Conditional branches reduce efficiency</li>
                                                            <li><strong>Load Imbalance:</strong> Uneven work distribution</li>
                                                        </ul>
                                                    </div>
                                                    
                                                    <h5>Modern Array Processor Applications:</h5>
                                                    <div class="table-responsive">
                                                        <table class="table table-sm">
                                                            <thead class="thead-light">
                                                                <tr>
                                                                    <th>Application Domain</th>
                                                                    <th>Array Processor Type</th>
                                                                    <th>Key Performance Factors</th>
                                                                </tr>
                                                            </thead>
                                                            <tbody>
                                                                <tr>
                                                                    <td>Machine Learning</td>
                                                                    <td>GPUs, TPUs, NPUs</td>
                                                                    <td>Matrix multiply throughput, memory bandwidth</td>
                                                                </tr>
                                                                <tr>
                                                                    <td>Scientific Simulation</td>
                                                                    <td>Vector processors, SIMD arrays</td>
                                                                    <td>Floating-point performance, memory hierarchy</td>
                                                                </tr>
                                                                <tr>
                                                                    <td>Signal Processing</td>
                                                                    <td>DSP arrays, FPGAs</td>
                                                                    <td>Specialized operations, real-time constraints</td>
                                                                </tr>
                                                                <tr>
                                                                    <td>Cryptography</td>
                                                                    <td>Custom accelerators</td>
                                                                    <td>Integer operations, security isolation</td>
                                                                </tr>
                                                            </tbody>
                                                        </table>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('6.2')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('6.4')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 6.4: Clusters and NUMA Computers -->
                    <div class="slide" id="slide-6.4">
                        <h2 class="slide-title">Clusters and NUMA Computers</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Cluster Computing Fundamentals</div>
                                        <div class="card-body">
                                            <h5>Definition and Core Concepts:</h5>
                                            <p>Cluster computing is a parallel computing architecture where a group of independent computers (nodes) are linked together to form a single unified computing resource. Each node operates as a complete computer with its own processor(s), memory, and storage.</p>
                                            
                                            <div class="alert alert-info">
                                                <strong>Key Characteristics:</strong>
                                                <ul>
                                                    <li>Collection of loosely or tightly coupled computers</li>
                                                    <li>Distributed memory architecture (typically)</li>
                                                    <li>Message-passing communication model</li>
                                                    <li>Scalable by adding more nodes</li>
                                                    <li>Shared file system or storage infrastructure</li>
                                                    <li>Unified job management and scheduling</li>
                                                </ul>
                                            </div>
                                            
                                            <h5>Cluster Components:</h5>
                                            <ul>
                                                <li><strong>Compute Nodes:</strong> Individual servers that perform computation</li>
                                                <li><strong>Head/Master Node:</strong> Controls job scheduling and management</li>
                                                <li><strong>Storage Nodes:</strong> Provide shared file systems and data access</li>
                                                <li><strong>Interconnection Network:</strong> High-speed links between nodes</li>
                                                <li><strong>Cluster Middleware:</strong> Software for resource management</li>
                                                <li><strong>Job Scheduler:</strong> Allocates resources to submitted jobs</li>
                                            </ul>
                                            
                                            <h5>Cluster Types and Classifications:</h5>
                                            <h6>1. By Purpose:</h6>
                                            <ul>
                                                <li><strong>High-Performance Computing (HPC):</strong> Scientific computing, simulations</li>
                                                <li><strong>High-Availability (HA):</strong> Fault tolerance and continuous operation</li>
                                                <li><strong>Load-Balancing:</strong> Distributed workload processing</li>
                                                <li><strong>Storage Clusters:</strong> Distributed file systems</li>
                                                <li><strong>Database Clusters:</strong> Parallel database operations</li>
                                            </ul>
                                            
                                            <h6>2. By Architecture:</h6>
                                            <ul>
                                                <li><strong>Beowulf Clusters:</strong> Commodity hardware with Linux</li>
                                                <li><strong>Blade Clusters:</strong> Compact, energy-efficient blade servers</li>
                                                <li><strong>Grid Clusters:</strong> Geographically distributed resources</li>
                                                <li><strong>Cloud Clusters:</strong> Virtualized cluster resources</li>
                                                <li><strong>GPU Clusters:</strong> GPU-accelerated compute nodes</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">NUMA Computer Architecture</div>
                                        <div class="card-body">
                                            <h5>NUMA: Definition and Principles</h5>
                                            <p>Non-Uniform Memory Access (NUMA) is a shared memory multiprocessing architecture where memory access time depends on the memory location relative to the processor. Memory that is local to a processor can be accessed faster than memory that is remote (attached to another processor).</p>
                                            
                                            <div class="alert alert-info">
                                                <strong>Key Characteristics:</strong>
                                                <ul>
                                                    <li>Shared memory with non-uniform access times</li>
                                                    <li>Multiple memory controllers (one per node)</li>
                                                    <li>Hierarchical memory structure</li>
                                                    <li>Memory divided into local and remote regions</li>
                                                    <li>Cache coherence maintained across nodes</li>
                                                    <li>Processor affinity important for performance</li>
                                                </ul>
                                            </div>
                                            
                                            <h5>NUMA Architecture Components:</h5>
                                            <ul>
                                                <li><strong>NUMA Node:</strong> Processor(s) with local memory and memory controller</li>
                                                <li><strong>Local Memory:</strong> Memory directly attached to the processor</li>
                                                <li><strong>Remote Memory:</strong> Memory attached to other processors</li>
                                                <li><strong>Interconnect:</strong> High-speed connections between NUMA nodes</li>
                                                <li><strong>Cache Coherence Protocol:</strong> Maintains memory consistency</li>
                                            </ul>
                                            
                                            <div class="text-center mt-3">
                                                <svg width="100%" height="150" viewBox="0 0 300 150">
                                                    <rect x="20" y="20" width="120" height="40" fill="#e1f5fe" stroke="#0288d1"/>
                                                    <rect x="160" y="20" width="120" height="40" fill="#e1f5fe" stroke="#0288d1"/>
                                                    <rect x="20" y="90" width="120" height="40" fill="#ffecb3" stroke="#ffa000"/>
                                                    <rect x="160" y="90" width="120" height="40" fill="#ffecb3" stroke="#ffa000"/>
                                                    <text x="80" y="45" text-anchor="middle" font-size="12">CPU Node 0</text>
                                                    <text x="220" y="45" text-anchor="middle" font-size="12">CPU Node 1</text>
                                                    <text x="80" y="115" text-anchor="middle" font-size="12">Local Memory 0</text>
                                                    <text x="220" y="115" text-anchor="middle" font-size="12">Local Memory 1</text>
                                                    
                                                    <line x1="80" y1="60" x2="80" y2="90" stroke="#000" stroke-width="2"/>
                                                    <line x1="220" y1="60" x2="220" y2="90" stroke="#000" stroke-width="2"/>
                                                    
                                                    <line x1="80" y1="60" x2="220" y2="90" stroke="#000" stroke-width="1" stroke-dasharray="5,5"/>
                                                    <line x1="220" y1="60" x2="80" y2="90" stroke="#000" stroke-width="1" stroke-dasharray="5,5"/>
                                                    
                                                    <text x="140" y="135" text-anchor="middle" font-size="8">Fast Local Access</text>
                                                    <text x="250" y="80" text-anchor="middle" font-size="8" transform="rotate(35,250,80)">Slower Remote Access</text>
                                                </svg>
                                            </div>
                                            
                                            <h5>NUMA Classification:</h5>
                                            <ul>
                                                <li><strong>ccNUMA:</strong> Cache-Coherent NUMA (most common)</li>
                                                <li><strong>COMA:</strong> Cache-Only Memory Architecture</li>
                                                <li><strong>NUMA-Q:</strong> NUMA with quad processors per node</li>
                                                <li><strong>sNUMA:</strong> Scalable NUMA</li>
                                                <li><strong>Multi-level NUMA:</strong> Hierarchical NUMA structures</li>
                                            </ul>
                                            
                                            <h5>Performance Considerations:</h5>
                                            <div class="alert alert-warning">
                                                <ul>
                                                    <li><strong>NUMA Ratio:</strong> Ratio of remote to local access times</li>
                                                    <li><strong>Memory Locality:</strong> Keeping data close to processing units</li>
                                                    <li><strong>NUMA-Aware Scheduling:</strong> OS allocation of processes to nodes</li>
                                                    <li><strong>Memory Allocation Policies:</strong> Local, interleaved, or preferred</li>
                                                    <li><strong>Cache Coherence Traffic:</strong> Can become a bottleneck</li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('6.3')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('6.5')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 6.5: Multiprocessor Systems -->
                    <div class="slide" id="slide-6.5">
                        <h2 class="slide-title">Multiprocessor Systems</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Multiprocessor Architectures</div>
                                        <div class="card-body">
                                            <h5>Fundamental Concepts</h5>
                                            <p>A multiprocessor system consists of two or more processing units (CPUs) working together within a single computer system, sharing resources such as memory, I/O devices, and buses to enhance performance, reliability, and computational capacity.</p>
                                            
                                            <div class="alert alert-info">
                                                <strong>Primary Objectives of Multiprocessor Systems:</strong>
                                                <ul>
                                                    <li>Increased processing throughput</li>
                                                    <li>Improved reliability through redundancy</li>
                                                    <li>Cost-effective scaling of computing power</li>
                                                    <li>Resource sharing and optimization</li>
                                                    <li>Execution of parallel algorithms</li>
                                                    <li>Balanced workload distribution</li>
                                                </ul>
                                            </div>
                                            
                                            <h5>Multiprocessor Classification:</h5>
                                            
                                            <h6>1. By Memory Architecture:</h6>
                                            <ul>
                                                <li><strong>Shared Memory Systems (SMP):</strong> All processors access a common global memory space with uniform access time</li>
                                                <li><strong>Distributed Memory Systems:</strong> Each processor has its private memory and communication occurs via message passing</li>
                                                <li><strong>Hybrid Systems:</strong> Combination of shared and distributed memory architectures</li>
                                                <li><strong>NUMA Systems:</strong> Shared memory with non-uniform access times (as discussed in Slide 6.4)</li>
                                            </ul>
                                            
                                            <h6>2. By Processor Symmetry:</h6>
                                            <ul>
                                                <li><strong>Symmetric Multiprocessing (SMP):</strong> Identical processors sharing a common memory and executing the same OS</li>
                                                <li><strong>Asymmetric Multiprocessing (ASMP):</strong> Different processors with specialized functions or capabilities</li>
                                                <li><strong>Master-Slave Configuration:</strong> One processor controls task assignment to others</li>
                                            </ul>

                                            <h6>3. By System Organization:</h6>
                                            <ul>
                                                <li><strong>Tightly-Coupled:</strong> Processors share common bus, clock, memory, and peripheral devices</li>
                                                <li><strong>Loosely-Coupled:</strong> Processors have their own local resources connected via a network</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Implementation and Design Considerations</div>
                                        <div class="card-body">
                                            <h5>SMP Architecture Deep Dive</h5>
                                            <p>Symmetric Multiprocessing (SMP) is the most widely used multiprocessor architecture in modern computing systems, where all processors are identical, share system resources, and run identical copies of the operating system.</p>
                                            
                                            <div class="diagram text-center">
                                                <svg width="100%" height="200" viewBox="0 0 400 200">
                                                    <!-- CPU Units -->
                                                    <rect x="20" y="20" width="80" height="40" fill="#c8e6c9" stroke="#4caf50" stroke-width="2"/>
                                                    <rect x="120" y="20" width="80" height="40" fill="#c8e6c9" stroke="#4caf50" stroke-width="2"/>
                                                    <rect x="220" y="20" width="80" height="40" fill="#c8e6c9" stroke="#4caf50" stroke-width="2"/>
                                                    <rect x="320" y="20" width="80" height="40" fill="#c8e6c9" stroke="#4caf50" stroke-width="2"/>
                                                    
                                                    <text x="60" y="45" text-anchor="middle" font-size="12">CPU 0</text>
                                                    <text x="160" y="45" text-anchor="middle" font-size="12">CPU 1</text>
                                                    <text x="260" y="45" text-anchor="middle" font-size="12">CPU 2</text>
                                                    <text x="360" y="45" text-anchor="middle" font-size="12">CPU 3</text>
                                                    
                                                    <!-- Cache Units -->
                                                    <rect x="20" y="70" width="80" height="30" fill="#bbdefb" stroke="#2196f3" stroke-width="2"/>
                                                    <rect x="120" y="70" width="80" height="30" fill="#bbdefb" stroke="#2196f3" stroke-width="2"/>
                                                    <rect x="220" y="70" width="80" height="30" fill="#bbdefb" stroke="#2196f3" stroke-width="2"/>
                                                    <rect x="320" y="70" width="80" height="30" fill="#bbdefb" stroke="#2196f3" stroke-width="2"/>
                                                    
                                                    <text x="60" y="90" text-anchor="middle" font-size="12">Cache</text>
                                                    <text x="160" y="90" text-anchor="middle" font-size="12">Cache</text>
                                                    <text x="260" y="90" text-anchor="middle" font-size="12">Cache</text>
                                                    <text x="360" y="90" text-anchor="middle" font-size="12">Cache</text>
                                                    
                                                    <!-- System Bus -->
                                                    <rect x="10" y="120" width="380" height="20" fill="#ffecb3" stroke="#ffc107" stroke-width="2"/>
                                                    <text x="200" y="134" text-anchor="middle" font-size="12">System Bus</text>
                                                    
                                                    <!-- Memory and I/O -->
                                                    <rect x="70" y="160" width="100" height="30" fill="#f8bbd0" stroke="#e91e63" stroke-width="2"/>
                                                    <rect x="230" y="160" width="100" height="30" fill="#d1c4e9" stroke="#673ab7" stroke-width="2"/>
                                                    
                                                    <text x="120" y="180" text-anchor="middle" font-size="12">Shared Memory</text>
                                                    <text x="280" y="180" text-anchor="middle" font-size="12">I/O Subsystem</text>
                                                    
                                                    <!-- Connections -->
                                                    <line x1="60" y1="60" x2="60" y2="70" stroke="#000" stroke-width="1"/>
                                                    <line x1="160" y1="60" x2="160" y2="70" stroke="#000" stroke-width="1"/>
                                                    <line x1="260" y1="60" x2="260" y2="70" stroke="#000" stroke-width="1"/>
                                                    <line x1="360" y1="60" x2="360" y2="70" stroke="#000" stroke-width="1"/>
                                                    
                                                    <line x1="60" y1="100" x2="60" y2="120" stroke="#000" stroke-width="1"/>
                                                    <line x1="160" y1="100" x2="160" y2="120" stroke="#000" stroke-width="1"/>
                                                    <line x1="260" y1="100" x2="260" y2="120" stroke="#000" stroke-width="1"/>
                                                    <line x1="360" y1="100" x2="360" y2="120" stroke="#000" stroke-width="1"/>
                                                    
                                                    <line x1="120" y1="140" x2="120" y2="160" stroke="#000" stroke-width="1"/>
                                                    <line x1="280" y1="140" x2="280" y2="160" stroke="#000" stroke-width="1"/>
                                                </svg>
                                                <p class="text-center"><small>Classic SMP Architecture</small></p>
                                            </div>
                                            
                                            <h5>Key Design Challenges:</h5>
                                            <ul>
                                                <li><strong>Cache Coherence:</strong> Ensuring multiple caches maintain consistent data views</li>
                                                <li><strong>Memory Consistency:</strong> Defining rules for the ordering of memory operations</li>
                                                <li><strong>Synchronization:</strong> Coordinating processor activities with locks, barriers, and semaphores</li>
                                                <li><strong>Scalability:</strong> Maintaining performance as processor count increases</li>
                                                <li><strong>Resource Contention:</strong> Managing competition for shared system resources</li>
                                            </ul>
                                            
                                            <h5>Real-World Examples:</h5>
                                            <ul>
                                                <li><strong>Intel Xeon Server Platforms:</strong> Enterprise-grade SMP systems with up to 8 processors</li>
                                                <li><strong>AMD EPYC Server Systems:</strong> High-performance SMP servers</li>
                                                <li><strong>IBM Power Systems:</strong> Advanced SMP implementation with sophisticated interconnects</li>
                                                <li><strong>Oracle SPARC Systems:</strong> High-reliability SMP systems for critical applications</li>
                                                <li><strong>HPE Superdome Flex:</strong> Modular SMP architecture scaling to hundreds of cores</li>
                                            </ul>
                                            
                                            <div class="alert alert-warning">
                                                <strong>Critical Insight:</strong> While adding more processors can theoretically increase performance, practical limitations arise from:
                                                <ul>
                                                    <li>Memory and bus contention</li>
                                                    <li>Cache coherence overhead</li>
                                                    <li>Synchronization costs</li>
                                                    <li>Diminishing returns in parallelizable workloads</li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('6.4')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('6.6')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 6.6: Interconnection Networks -->
                    <div class="slide" id="slide-6.6">
                        <h2 class="slide-title">Interconnection Networks</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Fundamentals of Interconnection Networks</div>
                                        <div class="card-body">
                                            <h5>Core Concepts and Importance</h5>
                                            <p>Interconnection networks form the critical communication infrastructure that enables processors, memory units, and I/O devices to exchange data within parallel and distributed computing systems. They determine the overall system performance, scalability, and reliability.</p>
                                            
                                            <div class="alert alert-info">
                                                <strong>Primary Functions:</strong>
                                                <ul>
                                                    <li>Data transport between system components</li>
                                                    <li>Address and control signal transmission</li>
                                                    <li>Synchronization mechanism implementation</li>
                                                    <li>System scalability enablement</li>
                                                    <li>Fault tolerance through redundant paths</li>
                                                    <li>Efficient resource sharing</li>
                                                </ul>
                                            </div>
                                            
                                            <h5>Key Network Characteristics:</h5>
                                            <ul>
                                                <li><strong>Topology:</strong> The physical or logical arrangement of nodes and links</li>
                                                <li><strong>Routing:</strong> Path determination for data movement between nodes</li>
                                                <li><strong>Flow Control:</strong> Regulating data transmission to prevent congestion</li>
                                                <li><strong>Switching:</strong> Technique for establishing communication paths</li>
                                                <li><strong>Bandwidth:</strong> Maximum data transfer capacity</li>
                                                <li><strong>Latency:</strong> Time delay for message delivery</li>
                                                <li><strong>Bisection Bandwidth:</strong> Minimum bandwidth between equal halves</li>
                                                <li><strong>Diameter:</strong> Maximum shortest path between any two nodes</li>
                                            </ul>
                                            
                                            <h5>Network Classification:</h5>
                                            <h6>1. By Scale:</h6>
                                            <ul>
                                                <li><strong>On-Chip Networks (NoC):</strong> For intra-processor communication</li>
                                                <li><strong>System-Level Interconnects:</strong> For components within a computer</li>
                                                <li><strong>Cluster Interconnects:</strong> For node-to-node communication</li>
                                                <li><strong>Wide-Area Networks:</strong> For geographically distributed systems</li>
                                            </ul>
                                            
                                            <h6>2. By Switching Technique:</h6>
                                            <ul>
                                                <li><strong>Circuit Switching:</strong> Dedicated path established for the entire communication duration</li>
                                                <li><strong>Packet Switching:</strong> Data divided into packets that can take different routes</li>
                                                <li><strong>Wormhole Switching:</strong> Packets divided into flits that move through the network in a pipelined fashion</li>
                                                <li><strong>Virtual Cut-Through:</strong> Combines features of packet and circuit switching</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Network Topologies and Implementations</div>
                                        <div class="card-body">
                                            <h5>Major Network Topologies</h5>
                                            
                                            <div class="row mb-3">
                                                <div class="col-md-6">
                                                    <div class="diagram text-center">
                                                        <svg width="100%" height="120" viewBox="0 0 180 120">
                                                            <!-- Bus Topology -->
                                                            <rect x="10" y="50" width="160" height="10" fill="#ffcc80" stroke="#ef6c00"/>
                                                            
                                                            <circle cx="30" cy="30" r="15" fill="#b39ddb" stroke="#512da8"/>
                                                            <circle cx="70" cy="30" r="15" fill="#b39ddb" stroke="#512da8"/>
                                                            <circle cx="110" cy="30" r="15" fill="#b39ddb" stroke="#512da8"/>
                                                            <circle cx="150" cy="30" r="15" fill="#b39ddb" stroke="#512da8"/>
                                                            
                                                            <line x1="30" y1="45" x2="30" y2="50" stroke="#000" stroke-width="2"/>
                                                            <line x1="70" y1="45" x2="70" y2="50" stroke="#000" stroke-width="2"/>
                                                            <line x1="110" y1="45" x2="110" y2="50" stroke="#000" stroke-width="2"/>
                                                            <line x1="150" y1="45" x2="150" y2="50" stroke="#000" stroke-width="2"/>
                                                            
                                                            <text x="90" y="100" text-anchor="middle" font-size="12">Bus Topology</text>
                                                        </svg>
                                                    </div>
                                                </div>
                                                <div class="col-md-6">
                                                    <div class="diagram text-center">
                                                        <svg width="100%" height="120" viewBox="0 0 180 120">
                                                            <!-- Ring Topology -->
                                                            <circle cx="90" cy="60" r="50" fill="none" stroke="#ffcc80" stroke-width="6"/>
                                                            
                                                            <circle cx="90" cy="10" r="10" fill="#b39ddb" stroke="#512da8"/>
                                                            <circle cx="140" cy="60" r="10" fill="#b39ddb" stroke="#512da8"/>
                                                            <circle cx="90" cy="110" r="10" fill="#b39ddb" stroke="#512da8"/>
                                                            <circle cx="40" cy="60" r="10" fill="#b39ddb" stroke="#512da8"/>
                                                            
                                                            <text x="90" y="100" text-anchor="middle" font-size="12">Ring Topology</text>
                                                        </svg>
                                                    </div>
                                                </div>
                                            </div>
                                            
                                            <div class="row mb-3">
                                                <div class="col-md-6">
                                                    <div class="diagram text-center">
                                                        <svg width="100%" height="120" viewBox="0 0 180 120">
                                                            <!-- Mesh Topology -->
                                                            <circle cx="30" cy="30" r="10" fill="#b39ddb" stroke="#512da8"/>
                                                            <circle cx="90" cy="30" r="10" fill="#b39ddb" stroke="#512da8"/>
                                                            <circle cx="150" cy="30" r="10" fill="#b39ddb" stroke="#512da8"/>
                                                            <circle cx="30" cy="90" r="10" fill="#b39ddb" stroke="#512da8"/>
                                                            <circle cx="90" cy="90" r="10" fill="#b39ddb" stroke="#512da8"/>
                                                            <circle cx="150" cy="90" r="10" fill="#b39ddb" stroke="#512da8"/>
                                                            
                                                            <line x1="30" y1="30" x2="90" y2="30" stroke="#ffcc80" stroke-width="3"/>
                                                            <line x1="90" y1="30" x2="150" y2="30" stroke="#ffcc80" stroke-width="3"/>
                                                            <line x1="30" y1="90" x2="90" y2="90" stroke="#ffcc80" stroke-width="3"/>
                                                            <line x1="90" y1="90" x2="150" y2="90" stroke="#ffcc80" stroke-width="3"/>
                                                            <line x1="30" y1="30" x2="30" y2="90" stroke="#ffcc80" stroke-width="3"/>
                                                            <line x1="90" y1="30" x2="90" y2="90" stroke="#ffcc80" stroke-width="3"/>
                                                            <line x1="150" y1="30" x2="150" y2="90" stroke="#ffcc80" stroke-width="3"/>
                                                            
                                                            <text x="90" y="110" text-anchor="middle" font-size="12">Mesh Topology</text>
                                                        </svg>
                                                    </div>
                                                </div>
                                                <div class="col-md-6">
                                                    <div class="diagram text-center">
                                                        <svg width="100%" height="120" viewBox="0 0 180 120">
                                                            <!-- Hypercube Topology (simplified 3D representation) -->
                                                            <rect x="30" y="30" width="50" height="50" fill="none" stroke="#ffcc80" stroke-width="3"/>
                                                            <rect x="60" y="10" width="50" height="50" fill="none" stroke="#ffcc80" stroke-width="3" opacity="0.7"/>
                                                            
                                                            <circle cx="30" cy="30" r="5" fill="#b39ddb" stroke="#512da8"/>
                                                            <circle cx="80" cy="30" r="5" fill="#b39ddb" stroke="#512da8"/>
                                                            <circle cx="30" cy="80" r="5" fill="#b39ddb" stroke="#512da8"/>
                                                            <circle cx="80" cy="80" r="5" fill="#b39ddb" stroke="#512da8"/>
                                                            <circle cx="60" cy="10" r="5" fill="#b39ddb" stroke="#512da8"/>
                                                            <circle cx="110" cy="10" r="5" fill="#b39ddb" stroke="#512da8"/>
                                                            <circle cx="60" cy="60" r="5" fill="#b39ddb" stroke="#512da8"/>
                                                            <circle cx="110" cy="60" r="5" fill="#b39ddb" stroke="#512da8"/>
                                                            
                                                            <line x1="30" y1="30" x2="60" y2="10" stroke="#ffcc80" stroke-width="1"/>
                                                            <line x1="80" y1="30" x2="110" y2="10" stroke="#ffcc80" stroke-width="1"/>
                                                            <line x1="30" y1="80" x2="60" y2="60" stroke="#ffcc80" stroke-width="1"/>
                                                            <line x1="80" y1="80" x2="110" y2="60" stroke="#ffcc80" stroke-width="1"/>
                                                            
                                                            <text x="90" y="110" text-anchor="middle" font-size="12">Hypercube</text>
                                                        </svg>
                                                    </div>
                                                </div>
                                            </div>
                                            
                                            <h5>Comparative Analysis of Network Topologies:</h5>
                                            <div class="table-responsive">
                                                <table class="table table-bordered table-sm">
                                                    <thead class="table-light">
                                                        <tr>
                                                            <th>Topology</th>
                                                            <th>Advantages</th>
                                                            <th>Disadvantages</th>
                                                            <th>Applications</th>
                                                        </tr>
                                                    </thead>
                                                    <tbody>
                                                        <tr>
                                                            <td><strong>Bus</strong></td>
                                                            <td>Simple, low cost</td>
                                                            <td>Limited bandwidth, poor scalability</td>
                                                            <td>Small systems, legacy architectures</td>
                                                        </tr>
                                                        <tr>
                                                            <td><strong>Ring</strong></td>
                                                            <td>Simple routing, fair access</td>
                                                            <td>High latency for distant nodes</td>
                                                            <td>Token Ring networks, optical networks</td>
                                                        </tr>
                                                        <tr>
                                                            <td><strong>Star</strong></td>
                                                            <td>Low latency, simple management</td>
                                                            <td>Central point of failure</td>
                                                            <td>Local networks, central control systems</td>
                                                        </tr>
                                                        <tr>
                                                            <td><strong>Mesh</strong></td>
                                                            <td>High redundancy, good scalability</td>
                                                            <td>Expensive, complex routing</td>
                                                            <td>HPC systems, fault-tolerant networks</td>
                                                        </tr>
                                                        <tr>
                                                            <td><strong>Hypercube</strong></td>
                                                            <td>Low diameter, high connectivity</td>
                                                            <td>Complex, high node degree</td>
                                                            <td>Supercomputers, large parallel systems</td>
                                                        </tr>
                                                        <tr>
                                                            <td><strong>Fat Tree</strong></td>
                                                            <td>Non-blocking, high bisection bandwidth</td>
                                                            <td>Complex wiring, expensive switches</td>
                                                            <td>Data centers, high-performance clusters</td>
                                                        </tr>
                                                    </tbody>
                                                </table>
                                            </div>
                                            
                                            <h5>Real-World Implementation Examples:</h5>
                                            <ul>
                                                <li><strong>InfiniBand:</strong> High-performance interconnect for clusters and data centers</li>
                                                <li><strong>NVLink:</strong> NVIDIA's high-bandwidth GPU-to-GPU interconnect</li>
                                                <li><strong>Intel Omni-Path:</strong> High-speed fabric for HPC environments</li>
                                                <li><strong>Cray Aries:</strong> Advanced dragonfly topology for supercomputers</li>
                                                <li><strong>PCIe:</strong> Standard interconnect for computer components</li>
                                                <li><strong>CXL (Compute Express Link):</strong> Open standard for high-speed CPU-to-device connection</li>
                                            </ul>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('6.5')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('6.7')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 6.7: Multi-Core Computers (Continuation) -->
                    <div class="slide" id="slide-6.7">
                        <h2 class="slide-title">Multi-Core Computers</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Multi-Core Architecture Fundamentals</div>
                                        <div class="card-body">
                                            <h5>Definition and Evolution</h5>
                                            <p>A multi-core processor integrates two or more independent processing units (cores) onto a single integrated circuit die or chip package. This architecture represents a paradigm shift from increasing clock frequencies to increasing core count for performance improvement.</p>
                                            
                                            <div class="alert alert-info">
                                                <strong>Historical Context:</strong>
                                                <ul>
                                                    <li><strong>Power Wall:</strong> Increasing clock speeds led to unsustainable power consumption and heat generation</li>
                                                    <li><strong>ILP Wall:</strong> Diminishing returns from instruction-level parallelism techniques</li>
                                                    <li><strong>Memory Wall:</strong> Growing gap between processor and memory speeds</li>
                                                    <li><strong>Solution:</strong> Multiple cores operating at moderate frequencies to increase throughput while managing power consumption</li>
                                                </ul>
                                            </div>
                                            
                                            <h5>Core Multi-Core Concepts:</h5>
                                            <ul>
                                                <li><strong>Core:</strong> A self-contained processing unit capable of fetching, decoding, and executing instructions</li>
                                                <li><strong>Thread:</strong> A sequence of instructions that can be scheduled and executed independently</li>
                                                <li><strong>Thread-Level Parallelism (TLP):</strong> Executing multiple threads simultaneously</li>
                                                <li><strong>Cache Hierarchy:</strong> Multiple levels of caches (private and shared) to reduce memory latency</li>
                                                <li><strong>On-Chip Interconnect:</strong> Network connecting cores, caches, and memory controllers</li>
                                                <li><strong>Memory Controller:</strong> Interface between the processor and main memory</li>
                                            </ul>
                                            
                                            <h5>Multi-Core Processor Classifications:</h5>
                                            <h6>1. By Core Homogeneity:</h6>
                                            <ul>
                                                <li><strong>Homogeneous Multi-Core:</strong> Identical cores with the same architecture and capabilities</li>
                                                <li><strong>Heterogeneous Multi-Core:</strong> Different types of cores optimized for different workloads (e.g., big.LITTLE architecture)</li>
                                            </ul>
                                            
                                            <h6>2. By Core Integration:</h6>
                                            <ul>
                                                <li><strong>Monolithic Design:</strong> All cores on a single die</li>
                                                <li><strong>Multi-Chip Module (MCM):</strong> Multiple dies in a single package</li>
                                                <li><strong>Chiplet Architecture:</strong> Modular approach with specialized dies for different functions</li>
                                            </ul>
                                            
                                            <h6>3. By Processing Paradigm:</h6>
                                            <ul>
                                                <li><strong>General-Purpose Processors:</strong> Cores designed for a wide range of applications</li>
                                                <li><strong>Domain-Specific Processors:</strong> Cores optimized for specific workloads</li>
                                                <li><strong>Hybrid Processors:</strong> Combination of general-purpose and specialized cores</li>
                                            </ul>
                                            
                                            <div class="diagram text-center">
                                                <svg width="100%" height="180" viewBox="0 0 350 180">
                                                    <!-- Quad-Core Processor Diagram -->
                                                    <rect x="10" y="10" width="330" height="160" rx="5" fill="#e8eaf6" stroke="#3949ab" stroke-width="2"/>
                                                    <text x="175" y="25" text-anchor="middle" font-size="12" font-weight="bold">Multi-Core Processor</text>
                                                    
                                                    <!-- CPU Cores -->
                                                    <rect x="30" y="40" width="90" height="60" rx="3" fill="#c5cae9" stroke="#3949ab"/>
                                                    <rect x="130" y="40" width="90" height="60" rx="3" fill="#c5cae9" stroke="#3949ab"/>
                                                    <rect x="30" y="110" width="90" height="60" rx="3" fill="#c5cae9" stroke="#3949ab"/>
                                                    <rect x="130" y="110" width="90" height="60" rx="3" fill="#c5cae9" stroke="#3949ab"/>
                                                    
                                                    <text x="75" y="60" text-anchor="middle" font-size="10">Core 0</text>
                                                    <text x="175" y="60" text-anchor="middle" font-size="10">Core 1</text>
                                                    <text x="75" y="130" text-anchor="middle" font-size="10">Core 2</text>
                                                    <text x="175" y="130" text-anchor="middle" font-size="10">Core 3</text>
                                                    
                                                    <rect x="40" y="70" width="30" height="20" fill="#bbdefb" stroke="#1976d2"/>
                                                    <rect x="80" y="70" width="30" height="20" fill="#bbdefb" stroke="#1976d2"/>
                                                    <rect x="140" y="70" width="30" height="20" fill="#bbdefb" stroke="#1976d2"/>
                                                    <rect x="180" y="70" width="30" height="20" fill="#bbdefb" stroke="#1976d2"/>
                                                    <rect x="40" y="140" width="30" height="20" fill="#bbdefb" stroke="#1976d2"/>
                                                    <rect x="80" y="140" width="30" height="20" fill="#bbdefb" stroke="#1976d2"/>
                                                    <rect x="140" y="140" width="30" height="20" fill="#bbdefb" stroke="#1976d2"/>
                                                    <rect x="180" y="140" width="30" height="20" fill="#bbdefb" stroke="#1976d2"/>
                                                    
                                                    <text x="55" y="85" text-anchor="middle" font-size="8">L1$</text>
                                                    <text x="95" y="85" text-anchor="middle" font-size="8">L1$</text>
                                                    <text x="155" y="85" text-anchor="middle" font-size="8">L1$</text>
                                                    <text x="195" y="85" text-anchor="middle" font-size="8">L1$</text>
                                                    <text x="55" y="155" text-anchor="middle" font-size="8">L1$</text>
                                                    <text x="95" y="155" text-anchor="middle" font-size="8">L1$</text>
                                                    <text x="155" y="155" text-anchor="middle" font-size="8">L1$</text>
                                                    <text x="195" y="155" text-anchor="middle" font-size="8">L1$</text>
                                                    
                                                    <!-- L2 Caches -->
                                                    <rect x="240" y="40" width="80" height="40" rx="3" fill="#b2dfdb" stroke="#00796b"/>
                                                    <rect x="240" y="90" width="80" height="40" rx="3" fill="#b2dfdb" stroke="#00796b"/>
                                                    <rect x="240" y="140" width="80" height="20" rx="3" fill="#ff8a65" stroke="#d84315"/>
                                                    
                                                    <text x="280" y="65" text-anchor="middle" font-size="10">L2 Cache</text>
                                                    <text x="280" y="110" text-anchor="middle" font-size="10">L3 Cache</text>
                                                    <text x="280" y="155" text-anchor="middle" font-size="10">Memory Controller</text>
                                                    
                                                    <!-- Connections -->
                                                    <line x1="120" y1="70" x2="240" y2="60" stroke="#000" stroke-width="1"/>
                                                    <line x1="220" y1="70" x2="240" y2="60" stroke="#000" stroke-width="1"/>
                                                    <line x1="120" y1="140" x2="240" y2="110" stroke="#000" stroke-width="1"/>
                                                    <line x1="220" y1="140" x2="240" y2="110" stroke="#000" stroke-width="1"/>
                                                    <line x1="280" y1="80" x2="280" y2="90" stroke="#000" stroke-width="1"/>
                                                    <line x1="280" y1="130" x2="280" y2="140" stroke="#000" stroke-width="1"/>
                                                </svg>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Advanced Multi-Core Design Considerations</div>
                                        <div class="card-body">
                                            <h5>Cache Coherence in Multi-Core Systems</h5>
                                            <p>When multiple cores have private caches, the same memory location may exist in multiple caches simultaneously. Cache coherence protocols ensure that all cores see a consistent view of memory.</p>
                                            
                                            <div class="alert alert-warning">
                                                <strong>Cache Coherence Protocols:</strong>
                                                <ul>
                                                    <li><strong>MESI Protocol:</strong> Modified, Exclusive, Shared, Invalid states for cache lines</li>
                                                    <li><strong>MOESI Protocol:</strong> Adds Owned state to MESI for reduced write-back traffic</li>
                                                    <li><strong>Directory-Based Protocols:</strong> Track sharers using a centralized directory</li>
                                                    <li><strong>Snooping Protocols:</strong> Broadcast-based approach where caches monitor shared bus</li>
                                                </ul>
                                            </div>
                                            
                                            <h5>Memory Consistency Models:</h5>
                                            <p>Define the rules for ordering of memory operations in multi-core systems:</p>
                                            <ul>
                                                <li><strong>Sequential Consistency (SC):</strong> All operations appear to execute in program order, most intuitive but restrictive</li>
                                                <li><strong>Total Store Order (TSO):</strong> Relaxes write-to-read ordering, used in x86</li>
                                                <li><strong>Partial Store Order (PSO):</strong> Further relaxes write-to-write ordering</li>
                                                <li><strong>Release Consistency (RC):</strong> Distinguishes between synchronization and data operations</li>
                                                <li><strong>Weak Ordering:</strong> Only enforces ordering around synchronization points</li>
                                            </ul>
                                            
                                            <h5>Real-World Multi-Core Architectures:</h5>
                                            <div class="table-responsive">
                                                <table class="table table-bordered table-sm">
                                                    <thead class="table-light">
                                                        <tr>
                                                            <th>Architecture</th>
                                                            <th>Key Features</th>
                                                            <th>Core Count</th>
                                                            <th>Application</th>
                                                        </tr>
                                                    </thead>
                                                    <tbody>
                                                        <tr>
                                                            <td><strong>Intel Core i7/i9</strong></td>
                                                            <td>Hyperthreading, Ring bus, Turbo Boost</td>
                                                            <td>4-18 cores</td>
                                                            <td>Desktop, Workstation</td>
                                                        </tr>
                                                        <tr>
                                                            <td><strong>AMD Ryzen/Threadripper</strong></td>
                                                            <td>Chiplet design, Infinity Fabric, SMT</td>
                                                            <td>6-64 cores</td>
                                                            <td>Desktop, HEDT</td>
                                                        </tr>
                                                        <tr>
                                                            <td><strong>ARM big.LITTLE</strong></td>
                                                            <td>Heterogeneous cores, power efficiency</td>
                                                            <td>4-8 (mix of big/little)</td>
                                                            <td>Mobile, Embedded</td>
                                                        </tr>
                                                        <tr>
                                                            <td><strong>IBM POWER9/10</strong></td>
                                                            <td>SMT-4, high bandwidth interconnect</td>
                                                            <td>12-24 cores</td>
                                                            <td>Servers, HPC</td>
                                                        </tr>
                                                        <tr>
                                                            <td><strong>Apple M1/M2</strong></td>
                                                            <td>Unified memory, heterogeneous cores</td>
                                                            <td>8-10 cores (mix)</td>
                                                            <td>Consumer, Professional</td>
                                                        </tr>
                                                    </tbody>
                                                </table>
                                            </div>
                                            
                                            <h5>Advanced Optimizations in Modern Multi-Core Systems:</h5>
                                            <ul>
                                                <li><strong>Thread-Level Speculation (TLS):</strong> Speculatively executes threads before dependencies are resolved</li>
                                                <li><strong>Transactional Memory:</strong> Simplified concurrency model through atomic memory operations</li>
                                                <li><strong>Heterogeneous Computing:</strong> Combining different core types (CPU, GPU, specialized accelerators)</li>
                                                <li><strong>Dynamic Voltage and Frequency Scaling (DVFS):</strong> Adjusts power based on workload demands</li>
                                                <li><strong>Hardware Scout Threading:</strong> Uses idle cores for prefetching</li>
                                                <li><strong>Core Fusion/Fission:</strong> Dynamically combining or splitting cores based on workload needs</li>
                                            </ul>
                                            
                                            <div class="alert alert-info">
                                                <strong>Emerging Trends in Multi-Core Architecture:</strong>
                                                <ul>
                                                    <li><strong>Chiplet-based Design:</strong> Smaller, specialized dies with high-speed interconnects</li>
                                                    <li><strong>3D Stacking:</strong> Vertical integration of cores and memory to reduce latency</li>
                                                    <li><strong>Silicon Photonics:</strong> Optical interconnects for higher bandwidth, lower power</li>
                                                    <li><strong>Near-Memory Processing:</strong> Moving computation closer to data</li>
                                                    <li><strong>Domain-Specific Cores:</strong> Specialized cores for AI, cryptography, signal processing</li>
                                                </ul>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('6.6')">Previous</button>
                            <button class="btn btn-primary" onclick="navigateToSlide('6.8')">Next</button>
                        </div>
                    </div>

                    <!-- Slide 6.8: Performance Considerations -->
                    <div class="slide" id="slide-6.8">
                        <h2 class="slide-title">Performance Considerations</h2>
                        <div class="slide-content">
                            <div class="row">
                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-primary text-white">Performance Metrics and Evaluation</div>
                                        <div class="card-body">
                                            <h5>Fundamental Performance Metrics</h5>
                                            <p>Accurately measuring and evaluating the performance of parallel and distributed computer systems requires specialized metrics that go beyond traditional sequential performance measures.</p>
                                            
                                            <div class="performance-metric">
                                                <h6>Execution Time and Throughput</h6>
                                                <p><strong>Execution Time (T):</strong> The total time required to complete a computation task</p>
                                                <p><strong>Throughput (X):</strong> The rate at which tasks are completed per unit time</p>
                                                <p><strong>Mathematical Relationship:</strong> X = Tasks / T</p>
                                            </div>
                                            
                                            <div class="performance-metric">
                                                <h6>Speedup</h6>
                                                <p>The ratio of sequential execution time to parallel execution time:</p>
                                                <p><strong>Speedup (S) = T<sub>sequential</sub> / T<sub>parallel</sub></strong></p>
                                                <p>Types of Speedup:</p>
                                                <ul>
                                                    <li><strong>Linear Speedup:</strong> S = p (where p is the number of processors)</li>
                                                    <li><strong>Superlinear Speedup:</strong> S > p (due to caching effects)</li>
                                                    <li><strong>Sublinear Speedup:</strong> S < p (due to overhead, most common)</li>
                                                </ul>
                                            </div>
                                            
                                            <div class="performance-metric">
                                                <h6>Efficiency</h6>
                                                <p>The ratio of speedup to the number of processing elements:</p>
                                                <p><strong>Efficiency (E) = S / p = T<sub>sequential</sub> / (p × T<sub>parallel</sub>)</strong></p>
                                                <p>Ideally, E = 1 (or 100%); practically, E < 1 due to various overheads</p>
                                            </div>
                                            
                                            <div class="performance-metric">
                                                <h6>Scalability</h6>
                                                <p>How system performance changes as resources or problem size increases:</p>
                                                <ul>
                                                    <li><strong>Strong Scaling:</strong> Fixed problem size, increasing processors</li>
                                                    <li><strong>Weak Scaling:</strong> Fixed problem size per processor, increasing both</li>
                                                    <li><strong>Isoefficiency:</strong> How problem size must grow to maintain efficiency</li>
                                                </ul>
                                            </div>
                                            
                                            <h5>Advanced Performance Metrics:</h5>
                                            <ul>
                                                <li><strong>Million Instructions Per Second (MIPS):</strong> Measure of processor speed</li>
                                                <li><strong>Floating-Point Operations Per Second (FLOPS):</strong> Computational performance</li>
                                                <li><strong>Instructions Per Cycle (IPC):</strong> Processor resource utilization</li>
                                                <li><strong>Cache Hit Ratio:</strong> Effectiveness of cache hierarchy</li>
                                                <li><strong>Memory Bandwidth:</strong> Rate of data transfer between memory and processor</li>
                                                <li><strong>Latency:</strong> Time delay between initiation and completion of operations</li>
                                                <li><strong>Power Efficiency:</strong> Performance per watt of power consumed</li>
                                            </ul>
                                            
                                            <div class="diagram text-center">
                                                <svg width="100%" height="200" viewBox="0 0 350 200">
                                                    <!-- Amdahl's Law Visualization -->
                                                    <rect x="10" y="10" width="330" height="180" fill="#f5f5f5" stroke="#9e9e9e" stroke-width="1"/>
                                                    <text x="175" y="30" text-anchor="middle" font-size="14" font-weight="bold">Amdahl's Law</text>
                                                    
                                                    <!-- Axes -->
                                                    <line x1="50" y1="150" x2="300" y2="150" stroke="#000" stroke-width="2"/>
                                                    <line x1="50" y1="150" x2="50" y2="30" stroke="#000" stroke-width="2"/>
                                                    
                                                    <!-- Axis Labels -->
                                                    <text x="175" y="170" text-anchor="middle" font-size="10">Number of Processors (p)</text>
                                                    <text x="25" y="90" text-anchor="middle" font-size="10" transform="rotate(-90, 25, 90)">Speedup (S)</text>
                                                    
                                                    <!-- Tick Marks -->
                                                    <line x1="100" y1="150" x2="100" y2="155" stroke="#000" stroke-width="1"/>
                                                    <line x1="150" y1="150" x2="150" y2="155" stroke="#000" stroke-width="1"/>
                                                    <line x1="200" y1="150" x2="200" y2="155" stroke="#000" stroke-width="1"/>
                                                    <line x1="250" y1="150" x2="250" y2="155" stroke="#000" stroke-width="1"/>
                                                    
                                                    <text x="100" y="165" text-anchor="middle" font-size="8">4</text>
                                                    <text x="150" y="165" text-anchor="middle" font-size="8">8</text>
                                                    <text x="200" y="165" text-anchor="middle" font-size="8">16</text>
                                                    <text x="250" y="165" text-anchor="middle" font-size="8">32</text>
                                                    
                                                    <line x1="45" y1="130" x2="50" y2="130" stroke="#000" stroke-width="1"/>
                                                    <line x1="45" y1="110" x2="50" y2="110" stroke="#000" stroke-width="1"/>
                                                    <line x1="45" y1="90" x2="50" y2="90" stroke="#000" stroke-width="1"/>
                                                    <line x1="45" y1="70" x2="50" y2="70" stroke="#000" stroke-width="1"/>
                                                    <line x1="45" y1="50" x2="50" y2="50" stroke="#000" stroke-width="1"/>
                                                    
                                                    <text x="40" y="130" text-anchor="end" font-size="8">2</text>
                                                    <text x="40" y="110" text-anchor="end" font-size="8">4</text>
                                                    <text x="40" y="90" text-anchor="end" font-size="8">8</text>
                                                    <text x="40" y="70" text-anchor="end" font-size="8">16</text>
                                                    <text x="40" y="50" text-anchor="end" font-size="8">32</text>
                                                    
                                                    <!-- Curves -->
                                                    <path d="M50,150 Q75,90 100,80 Q125,70 150,65 Q175,62 200,60 Q225,58 250,57 Q275,56 300,55" fill="none" stroke="#3f51b5" stroke-width="2"/>
                                                    <path d="M50,150 Q75,120 100,110 Q125,105 150,102 Q175,100 200,99 Q225,98 250,98 Q275,97 300,97" fill="none" stroke="#e91e63" stroke-width="2"/>
                                                    <path d="M50,150 Q75,100 100,75 Q125,60 150,50 Q175,45 200,40 Q225,35 250,32 Q275,30 300,29" fill="none" stroke="#4caf50" stroke-width="2"/>
                                                    
                                                    <!-- Legend -->
                                                    <rect x="60" y="40" width="10" height="10" fill="#3f51b5"/>
                                                    <rect x="60" y="55" width="10" height="10" fill="#e91e63"/>
                                                    <rect x="60" y="70" width="10" height="10" fill="#4caf50"/>
                                                    
                                                    <text x="75" y="48" font-size="8" text-anchor="start">f=0.1 (10% Serial)</text>
                                                    <text x="75" y="63" font-size="8" text-anchor="start">f=0.5 (50% Serial)</text>
                                                    <text x="75" y="78" font-size="8" text-anchor="start">f=0.01 (1% Serial)</text>
                                                </svg>
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <div class="col-md-6">
                                    <div class="card h-100">
                                        <div class="card-header bg-success text-white">Performance Bottlenecks and Optimization</div>
                                        <div class="card-body">
                                            <h5>Fundamental Laws and Limits</h5>
                                            
                                            <div class="alert alert-info">
                                                <strong>Amdahl's Law:</strong>
                                                <p>Limits the theoretical speedup of a parallel program based on its sequential portion:</p>
                                                <p><strong>Speedup ≤ 1 / (f + (1-f)/p)</strong></p>
                                                <p>Where <em>f</em> is the fraction of sequential execution and <em>p</em> is the number of processors.</p>
                                                <p><strong>Key Insight:</strong> Even with infinite processors, speedup is limited by 1/f.</p>
                                            </div>
                                            
                                            <div class="alert alert-info">
                                                <strong>Gustafson's Law:</strong>
                                                <p>Reframes Amdahl's Law to account for scaled problem sizes:</p>
                                                <p><strong>Scaled Speedup = p - α(p-1)</strong></p>
                                                <p>Where <em>α</em> is the sequential fraction of the parallel execution time.</p>
                                                <p><strong>Key Insight:</strong> As problem size grows, sequential portion becomes relatively less significant.</p>
                                            </div>
                                            
                                            <h5>Major Performance Bottlenecks:</h5>
                                            <ul>
                                                <li><strong>Sequential Portions:</strong> Parts of code that cannot be parallelized</li>
                                                <li><strong>Communication Overhead:</strong> Time spent exchanging data between processors</li>
                                                <li><strong>Synchronization Delays:</strong> Idle time waiting at barriers or locks</li>
                                                <li><strong>Load Imbalance:</strong> Uneven work distribution among processors</li>
                                                <li><strong>Memory Contention:</strong> Multiple cores competing for memory access</li>
                                                <li><strong>Cache Coherence Traffic:</strong> Overhead of maintaining consistent view of memory</li>
                                                <li><strong>False Sharing:</strong> Thrashing due to multiple cores modifying different data on same cache line</li>
                                                <li><strong>I/O Bottlenecks:</strong> Limitations in storage or network throughput</li>
                                            </ul>
                                            
                                            <h5>Optimization Strategies:</h5>
                                            <h6>1. Software Optimizations:</h6>
                                            <ul>
                                                <li><strong>Algorithmic Improvements:</strong> Selecting algorithms with better parallel scaling</li>
                                                <li><strong>Workload Partitioning:</strong> Dividing work to minimize communication</li>
                                                <li><strong>Data Locality:</strong> Organizing data to maximize cache reuse</li>
                                                <li><strong>Thread Affinity:</strong> Binding threads to specific cores</li>
                                                <li><strong>Memory Alignment:</strong> Ensuring data is aligned to cache line boundaries</li>
                                                <li><strong>Synchronization Reduction:</strong> Using lock-free algorithms where possible</li>
                                                <li><strong>Compiler Optimizations:</strong> Vectorization, loop unrolling, function inlining</li>
                                            </ul>
                                            
                                            <h6>2. Hardware Optimizations:</h6>
                                            <ul>
                                                <li><strong>Prefetching:</strong> Anticipating data needs to hide memory latency</li>
                                                <li><strong>Branch Prediction:</strong> Speculative execution to avoid pipeline stalls</li>
                                                <li><strong>Out-of-Order Execution:</strong> Maximizing instruction-level parallelism</li>
                                                <li><strong>Simultaneous Multi-Threading (SMT):</strong> Sharing core resources among threads</li>
                                                <li><strong>Cache Hierarchy Tuning:</strong> Optimizing size and organization of caches</li>
                                                <li><strong>Heterogeneous Computing:</strong> Using specialized accelerators (GPUs, FPGAs)</li>
                                                <li><strong>NUMA Optimizations:</strong> Memory placement to minimize remote access</li>
                                            </ul>
                                            
                                            <h5>Case Study: Performance Analysis Framework</h5>
                                            <div class="table-responsive">
                                                <table class="table table-bordered table-sm">
                                                    <thead class="table-light">
                                                        <tr>
                                                            <th>Analysis Stage</th>
                                                            <th>Tools</th>
                                                            <th>Key Metrics</th>
                                                        </tr>
                                                    </thead>
                                                    <tbody>
                                                        <tr>
                                                            <td><strong>Profiling</strong></td>
                                                            <td>gprof, Intel VTune, gperftools</td>
                                                            <td>Function call counts, execution time, CPU usage</td>
                                                        </tr>
                                                        <tr>
                                                            <td><strong>Tracing</strong></td>
                                                            <td>Valgrind, LTTng, DTrace</td>
                                                            <td>Memory access patterns, cache hits/misses, synchronization events</td>
                                                        </tr>
                                                        <tr>
                                                            <td><strong>Simulation</strong></td>
                                                            <td>gem5, Simics, QEMU</td>
                                                            <td>Cycle counts, memory latency, cache performance</td>
                                                        </tr>
                                                        <tr>
                                                            <td><strong>Benchmarking</strong></td>
                                                            <td>SPEC, LINPACK, STREAM</td>
                                                            <td>Performance metrics for specific workloads</td>
                                                        </tr>
                                                        <tr>
                                                            <td><strong>Load Testing</strong></td>
                                                            <td>Apache JMeter, Locust, Gatling</td>
                                                            <td>Throughput, response time, resource utilization</td>

                                                        </tr>
                                                        <tr>
                                                            <td><strong>Stress Testing</strong></td>
                                                            <td>Stress-ng, SysBench, Tsung</td>
                                                            <td>System stability under extreme conditions</td>
                                                        </tr>
                                                        <tr>
                                                            <td><strong>Profiling Tools</strong></td>
                                                            <td>Perf, OProfile, Intel Advisor</td>
                                                            <td>CPU cycles, cache misses, branch mispredictions</td>
                                                        </tr>
                                                        <tr>
                                                            <td><strong>Visualization</strong></td>
                                                            <td>Flame graphs, heat maps, Gantt charts</td>
                                                            <td>Resource usage over time, bottleneck identification</td>
                                                        </tr>
                                                    </tbody>
                                                </table>
                                            </div>
                                            <p>Using a combination of these tools and techniques, developers can gain insights into the performance characteristics of their parallel applications and identify areas for optimization.</p>
                                            <div class="alert alert-info">
                                                <strong>Example Performance Analysis Workflow:</strong>
                                                <ol>
                                                    <li>Profile the application to identify hotspots</li>
                                                    <li>Trace memory access patterns to detect contention</li>
                                                    <li>Simulate different configurations to evaluate performance</li>
                                                    <li>Benchmark against known workloads for comparison</li>
                                                    <li>Load test under realistic conditions to assess scalability</li>
                                                    <li>Stress test to ensure robustness under extreme conditions</li>
                                                    <li>Visualize results to identify bottlenecks and opportunities for optimization</li>
                                                </ol>
                                            </div>
                                            <h5>Conclusion</h5>
                                            <p>Performance considerations in parallel and distributed systems are complex and multifaceted. By understanding the fundamental laws, identifying bottlenecks, and applying optimization strategies, developers can significantly improve the performance of their applications.</p>
                                            <p>In the next section, we will explore advanced topics in multi-core architecture and their implications for performance.</p>
                                        </div>
                                    </div>


                                </div>
                            </div>
                        </div>
                        <div class="navigation">
                            <button class="btn btn-secondary" onclick="navigateToSlide('6.7')">Previous</button>
                        </div>

                    </div>
                </div>

            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script>
        // Global variables
        let currentSlide = '1.1';
        let visitedSlides = new Set();
        let sequentialState = { q: 0, d: 0, clk: 0 }; // For slide 1.7

        // Initialize the application
        document.addEventListener('DOMContentLoaded', function() {
            // Show the first slide
            const firstSlide = document.getElementById('slide-1.1');
            if (firstSlide) {
                firstSlide.classList.add('active');
                const firstSlideItem = document.querySelector(`.slide-item[data-slide="1.1"]`);
                if (firstSlideItem) firstSlideItem.classList.add('active');
                const firstUnitTitle = document.querySelector(`.unit-title[data-unit="1"]`);
                if (firstUnitTitle) firstUnitTitle.classList.add('active');
                const firstUnitSlides = document.getElementById('unit1-slides');
                if (firstUnitSlides) firstUnitSlides.classList.add('show');
                visitedSlides.add('1.1');
            } else {
                console.error("Initial slide 'slide-1.1' not found.");
                // Fallback: Show the first available slide if 1.1 doesn't exist
                const firstAvailableSlide = document.querySelector('.slide');
                if (firstAvailableSlide) {
                    firstAvailableSlide.classList.add('active');
                    const slideId = firstAvailableSlide.id.replace('slide-', '');
                    const slideItem = document.querySelector(`.slide-item[data-slide="${slideId}"]`);
                    if (slideItem) slideItem.classList.add('active');
                    const unitId = slideId.split('.')[0];
                    const unitTitle = document.querySelector(`.unit-title[data-unit="${unitId}"]`);
                    if (unitTitle) unitTitle.classList.add('active');
                    const unitSlides = document.getElementById(`unit${unitId}-slides`);
                    if (unitSlides) unitSlides.classList.add('show');
                    visitedSlides.add(slideId);
                    currentSlide = slideId;
                }
            }


            // Add event listeners to unit titles
            document.querySelectorAll('.unit-title').forEach(unitTitle => {
                unitTitle.addEventListener('click', function() {
                    const unitNumber = this.getAttribute('data-unit');
                    toggleUnitSlides(unitNumber);
                });
            });

            // Add event listeners to slide items
            document.querySelectorAll('.slide-item').forEach(slideItem => {
                slideItem.addEventListener('click', function() {
                    const slideId = this.getAttribute('data-slide');
                    navigateToSlide(slideId);
                });
            });

            // --- Event Listeners for Specific Slides ---

            // Slide 1.4 K-Map variable selection change
            const kmapVarsSelect = document.getElementById('kmapVars');
            if (kmapVarsSelect) {
                kmapVarsSelect.addEventListener('change', generateKmapGrid);
                generateKmapGrid(); // Initial generation
            }

            // Slide 1.5 Circuit Designer selection change
            const circuitTypeSelect = document.getElementById('circuitType');
            if (circuitTypeSelect) {
                circuitTypeSelect.addEventListener('change', setupCircuitParams);
                setupCircuitParams(); // Initial setup
            }

            // Slide 1.7 Sequential Circuit Simulator Buttons
            const sequentialSlide = document.getElementById('slide-1.7');
            if (sequentialSlide) {
                const clockButtons = sequentialSlide.querySelectorAll('.form-group:nth-of-type(1) .btn-group button');
                const inputButtons = sequentialSlide.querySelectorAll('.form-group:nth-of-type(2) .btn-group button');

                clockButtons.forEach(btn => {
                    btn.addEventListener('click', function() {
                        clockButtons.forEach(b => b.classList.remove('active', 'btn-success'));
                        clockButtons.forEach(b => b.classList.add('btn-outline-primary'));
                        if (this.textContent === 'Pulse') {
                            this.classList.add('btn-success');
                            this.classList.remove('btn-outline-primary');
                            // Simulate pulse effect (momentary high)
                            sequentialState.clk = 1;
                            updateSequentialDisplay();
                            setTimeout(() => {
                                sequentialState.clk = 0;
                                updateSequentialDisplay();
                                this.classList.remove('btn-success');
                                this.classList.add('btn-outline-primary');
                                // Activate the 'Low (0)' button after pulse
                                clockButtons[0].classList.add('active');
                                clockButtons[0].classList.remove('btn-outline-primary');
                            }, 150); // Short delay for pulse visualization
                        } else {
                            this.classList.add('active');
                            this.classList.remove('btn-outline-primary');
                            sequentialState.clk = (this.textContent === 'High (1)') ? 1 : 0;
                            updateSequentialDisplay();
                        }
                    });
                });

                inputButtons.forEach(btn => {
                    btn.addEventListener('click', function() {
                        inputButtons.forEach(b => b.classList.remove('active'));
                        this.classList.add('active');
                        sequentialState.d = (this.textContent === 'D=1') ? 1 : 0;
                        updateSequentialDisplay();
                    });
                });
                // Initialize display
                updateSequentialDisplay();
            }

        });

        // Toggle unit slides visibility
        function toggleUnitSlides(unitNumber) {
            // Hide all slide lists
            document.querySelectorAll('.slide-list').forEach(slideList => {
                slideList.classList.remove('show');
            });

            // Remove active class from all unit titles
            document.querySelectorAll('.unit-title').forEach(unitTitle => {
                unitTitle.classList.remove('active');
            });

            // Show selected unit slides and add active class to unit title
            const unitSlides = document.getElementById(`unit${unitNumber}-slides`);
            const unitTitle = document.querySelector(`.unit-title[data-unit="${unitNumber}"]`);
            if (unitSlides) unitSlides.classList.add('show');
            if (unitTitle) unitTitle.classList.add('active');
        }

        // Navigate to a specific slide
        function navigateToSlide(slideId) {
            // Hide all slides
            document.querySelectorAll('.slide').forEach(slide => {
                slide.classList.remove('active');
            });

            // Remove active class from all slide items
            document.querySelectorAll('.slide-item').forEach(slideItem => {
                slideItem.classList.remove('active');
            });

            // Show selected slide and add active class to slide item
            const targetSlide = document.getElementById(`slide-${slideId}`);
            const targetSlideItem = document.querySelector(`.slide-item[data-slide="${slideId}"]`);

            if (targetSlide) {
                targetSlide.classList.add('active');
            } else {
                console.error(`Slide with ID 'slide-${slideId}' not found.`);
                return; // Stop if slide doesn't exist
            }

            if (targetSlideItem) {
                targetSlideItem.classList.add('active');
            }

            // Get unit number from slide ID
            const unitNumber = slideId.split('.')[0];

            // Ensure unit slides are visible and unit title is active
            toggleUnitSlides(unitNumber);

            // Update current slide
            currentSlide = slideId;

            // Mark slide as visited
            visitedSlides.add(slideId);
        }

        // --- Functions for Slide 1.1 ---
        function checkBooleanSolution() {
            const userInput = document.getElementById('booleanExpression')?.value.trim().toUpperCase().replace(/\s+/g, '');
            const correctAnswer = "B+A*C"; // Or B+AC
            const correctAnswerAlt = "AC+B";
            const feedbackDiv = document.getElementById('booleanFeedback');
            if (!feedbackDiv) return;

            feedbackDiv.style.display = 'block';
            feedbackDiv.classList.remove('alert-success', 'alert-danger', 'alert-warning');

            if (!userInput) {
                feedbackDiv.classList.add('alert-warning');
                feedbackDiv.textContent = 'Please enter your simplified expression.';
            } else if (userInput === correctAnswer || userInput === correctAnswerAlt) {
                feedbackDiv.classList.add('alert-success');
                feedbackDiv.textContent = 'Correct! The simplified expression is B + A·C.';
            } else {
                feedbackDiv.classList.add('alert-danger');
                feedbackDiv.textContent = 'Incorrect. Try following the steps in the solution.';
            }
        }

        function showBooleanSolution() {
            const solutionDiv = document.getElementById('booleanSolution');
            if (solutionDiv) {
                solutionDiv.style.display = solutionDiv.style.display === 'none' ? 'block' : 'none';
            }
        }

        // --- Functions for Slide 1.2 ---
        function simulateGate() {
            const gateType = document.getElementById('gateType')?.value;
            const inputA = document.getElementById('inputA')?.value;
            const inputB = document.getElementById('inputB')?.value;
            const svg = document.getElementById('gateSimulation');
            const resultEl = document.getElementById('gateResult');
            const explanationEl = document.getElementById('gateExplanation');

            if (!gateType || !inputA || !inputB || !svg || !resultEl || !explanationEl) return;


            // Clear previous drawing
            svg.innerHTML = '';

            // Draw the gate symbol (simplified)
            const rect = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            rect.setAttribute("x", "30"); rect.setAttribute("y", "30");
            rect.setAttribute("width", "90"); rect.setAttribute("height", "40");
            rect.setAttribute("rx", "5"); rect.setAttribute("fill", "#e9ecef");
            rect.setAttribute("stroke", "#000");
            svg.appendChild(rect);

            const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
            text.setAttribute("x", "75"); text.setAttribute("y", "50");
            text.setAttribute("text-anchor", "middle"); text.setAttribute("dominant-baseline", "middle");
            text.setAttribute("font-weight", "bold"); text.textContent = gateType;
            svg.appendChild(text);

            // Draw inputs
            const lineA = document.createElementNS("http://www.w3.org/2000/svg", "line");
            lineA.setAttribute("x1", "10"); lineA.setAttribute("y1", "40");
            lineA.setAttribute("x2", "30"); lineA.setAttribute("y2", "40");
            lineA.setAttribute("stroke", inputA === '1' ? "#0f0" : "#f00");
            lineA.setAttribute("stroke-width", "2");
            svg.appendChild(lineA);
            const textA = document.createElementNS("http://www.w3.org/2000/svg", "text");
            textA.setAttribute("x", "5"); textA.setAttribute("y", "43"); textA.textContent = "A";
            svg.appendChild(textA);


            const lineB = document.createElementNS("http://www.w3.org/2000/svg", "line");
            lineB.setAttribute("x1", "10"); lineB.setAttribute("y1", "60");
            lineB.setAttribute("x2", "30"); lineB.setAttribute("y2", "60");
            lineB.setAttribute("stroke", inputB === '1' ? "#0f0" : "#f00");
            lineB.setAttribute("stroke-width", "2");
            svg.appendChild(lineB);
            const textB = document.createElementNS("http://www.w3.org/2000/svg", "text");
            textB.setAttribute("x", "5"); textB.setAttribute("y", "63"); textB.textContent = "B";
            svg.appendChild(textB);


            // Calculate output
            let output;
            const a = parseInt(inputA);
            const b = parseInt(inputB);

            switch(gateType) {
                case 'AND': output = a & b; break; // Use bitwise AND
                case 'OR':  output = a | b; break; // Use bitwise OR
                case 'NAND':output = 1 - (a & b); break; // NAND is NOT AND
                case 'NOR': output = 1 - (a | b); break; // NOR is NOT OR
                case 'XOR': output = a ^ b; break; // Use bitwise XOR
                case 'XNOR':output = 1 - (a ^ b); break; // XNOR is NOT XOR
                default: output = 0;
            }
            output = output ? 1 : 0; // Ensure 0 or 1

            // Draw output
            const lineOut = document.createElementNS("http://www.w3.org/2000/svg", "line");
            lineOut.setAttribute("x1", "120"); lineOut.setAttribute("y1", "50");
            lineOut.setAttribute("x2", "140"); lineOut.setAttribute("y2", "50");
            lineOut.setAttribute("stroke", output ? "#0f0" : "#f00");
            lineOut.setAttribute("stroke-width", "2");
            svg.appendChild(lineOut);
            const textOut = document.createElementNS("http://www.w3.org/2000/svg", "text");
            textOut.setAttribute("x", "145"); textOut.setAttribute("y", "53"); textOut.textContent = "Out";
            svg.appendChild(textOut);


            // For NOT, NAND, NOR, XNOR - add circle
            if (['NAND', 'NOR', 'XNOR'].includes(gateType)) {
                const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                circle.setAttribute("cx", "115"); circle.setAttribute("cy", "50");
                circle.setAttribute("r", "5"); circle.setAttribute("fill", "none");
                circle.setAttribute("stroke", "#000"); circle.setAttribute("stroke-width", "1");
                svg.appendChild(circle);
            }

            // Show result
            resultEl.textContent = `Output: ${output} (${output ? 'True' : 'False'})`;

            // Add explanation
            let explanation = '';
            switch(gateType) {
                case 'AND': explanation = `Output is 1 only if both A and B are 1. (${a} AND ${b} = ${output})`; break;
                case 'OR':  explanation = `Output is 1 if either A or B (or both) is 1. (${a} OR ${b} = ${output})`; break;
                case 'NAND':explanation = `Output is 0 only if both A and B are 1. (NOT (${a} AND ${b}) = ${output})`; break;
                case 'NOR': explanation = `Output is 1 only if both A and B are 0. (NOT (${a} OR ${b}) = ${output})`; break;
                case 'XOR': explanation = `Output is 1 if A and B are different. (${a} XOR ${b} = ${output})`; break;
                case 'XNOR':explanation = `Output is 1 if A and B are the same. (NOT (${a} XOR ${b}) = ${output})`; break;
            }
            explanationEl.textContent = explanation;
        }

        // --- Functions for Slide 1.3 ---
        function showAnswer(num) {
            const answerDiv = document.getElementById(`answer${num}`);
            if (answerDiv) {
                answerDiv.style.display = answerDiv.style.display === 'none' ? 'block' : 'none';
            }
        }

        // --- Functions for Slide 1.4 ---
        function generateKmapGrid() {
            const numVars = parseInt(document.getElementById('kmapVars')?.value || '2');
            const gridDiv = document.getElementById('kmapGrid');
            if (!gridDiv) return;

            let tableHTML = '<table class="karnaugh-map">';
            if (numVars === 2) {
                tableHTML += `
                    <tr><th>A\\B</th><th>0</th><th>1</th></tr>
                    <tr><th>0</th><td><input type="text" size="1" maxlength="1" data-row="0" data-col="0"></td><td><input type="text" size="1" maxlength="1" data-row="0" data-col="1"></td></tr>
                    <tr><th>1</th><td><input type="text" size="1" maxlength="1" data-row="1" data-col="0"></td><td><input type="text" size="1" maxlength="1" data-row="1" data-col="1"></td></tr>
                `;
            } else if (numVars === 3) {
                tableHTML += `
                    <tr><th>AB\\C</th><th>0</th><th>1</th></tr>
                    <tr><th>00</th><td><input type="text" size="1" maxlength="1" data-row="0" data-col="0"></td><td><input type="text" size="1" maxlength="1" data-row="0" data-col="1"></td></tr>
                    <tr><th>01</th><td><input type="text" size="1" maxlength="1" data-row="1" data-col="0"></td><td><input type="text" size="1" maxlength="1" data-row="1" data-col="1"></td></tr>
                    <tr><th>11</th><td><input type="text" size="1" maxlength="1" data-row="2" data-col="0"></td><td><input type="text" size="1" maxlength="1" data-row="2" data-col="1"></td></tr>
                    <tr><th>10</th><td><input type="text" size="1" maxlength="1" data-row="3" data-col="0"></td><td><input type="text" size="1" maxlength="1" data-row="3" data-col="1"></td></tr>
                `;
            } else { // numVars === 4
                tableHTML += `
                    <tr><th>AB\\CD</th><th>00</th><th>01</th><th>11</th><th>10</th></tr>
                    <tr><th>00</th><td><input type="text" size="1" maxlength="1" data-row="0" data-col="0"></td><td><input type="text" size="1" maxlength="1" data-row="0" data-col="1"></td><td><input type="text" size="1" maxlength="1" data-row="0" data-col="2"></td><td><input type="text" size="1" maxlength="1" data-row="0" data-col="3"></td></tr>
                    <tr><th>01</th><td><input type="text" size="1" maxlength="1" data-row="1" data-col="0"></td><td><input type="text" size="1" maxlength="1" data-row="1" data-col="1"></td><td><input type="text" size="1" maxlength="1" data-row="1" data-col="2"></td><td><input type="text" size="1" maxlength="1" data-row="1" data-col="3"></td></tr>
                    <tr><th>11</th><td><input type="text" size="1" maxlength="1" data-row="2" data-col="0"></td><td><input type="text" size="1" maxlength="1" data-row="2" data-col="1"></td><td><input type="text" size="1" maxlength="1" data-row="2" data-col="2"></td><td><input type="text" size="1" maxlength="1" data-row="2" data-col="3"></td></tr>
                    <tr><th>10</th><td><input type="text" size="1" maxlength="1" data-row="3" data-col="0"></td><td><input type="text" size="1" maxlength="1" data-row="3" data-col="1"></td><td><input type="text" size="1" maxlength="1" data-row="3" data-col="2"></td><td><input type="text" size="1" maxlength="1" data-row="3" data-col="3"></td></tr>
                `;
            }
            tableHTML += '</table><small>Enter 1 for true, 0 for false, X for don\'t care</small>';
            gridDiv.innerHTML = tableHTML;

            // Add input validation
            gridDiv.querySelectorAll('input').forEach(input => {
                input.addEventListener('input', function() {
                    this.value = this.value.toUpperCase().replace(/[^01X]/g, '');
                });
            });
        }

        function solveKmap() {
            // --- K-Map Solver Logic ---
            // This is a complex algorithm involving finding prime implicants,
            // essential prime implicants, and covering the minterms.
            // Implementing a full K-map solver here is beyond the scope of a simple fix.
            // We'll provide placeholder output.
            // A real implementation would parse the grid inputs, find groups,
            // and generate the simplified Sum-of-Products expression.

            const groupsDiv = document.getElementById('kmapGroups');
            const solutionDiv = document.getElementById('kmapSolution');
            if (!groupsDiv || !solutionDiv) return;

            groupsDiv.innerHTML = '<p><em>(Grouping visualization not implemented)</em></p>';
            solutionDiv.textContent = 'Placeholder: K-Map simplification logic not fully implemented.';
            solutionDiv.classList.remove('alert-success');
            solutionDiv.classList.add('alert-info');

            // Example of what the logic *might* look like (pseudo-code):
            // 1. Read values from the input grid.
            // 2. Identify all minterms (cells with '1').
            // 3. Identify all don't cares (cells with 'X').
            // 4. Find all possible valid groups (prime implicants) covering 1s and Xs.
            // 5. Identify essential prime implicants (groups covering a '1' no other group covers).
            // 6. Select a minimal set of prime implicants (including essential ones) to cover all '1's.
            // 7. Convert the selected groups into Boolean terms.
            // 8. Combine terms into a Sum-of-Products expression.
            // 9. Display the groups and the final expression.
        }

        // --- Functions for Slide 1.5 ---
        function setupCircuitParams() {
            const circuitType = document.getElementById('circuitType')?.value;
            const paramsDiv = document.getElementById('circuitParams');
            if (!paramsDiv) return;

            let paramsHTML = '';
            switch (circuitType) {
                case 'adder':
                    paramsHTML = `
                        <label class="form-label">Adder Type:</label>
                        <select class="form-select" id="adderType">
                            <option value="half">Half Adder</option>
                            <option value="full">Full Adder</option>
                            <option value="4bit">4-bit Ripple Carry</option>
                        </select>`;
                    break;
                case 'mux':
                    paramsHTML = `
                        <label class="form-label">Multiplexer Size:</label>
                        <select class="form-select" id="muxSize">
                            <option value="2to1">2-to-1 MUX</option>
                            <option value="4to1">4-to-1 MUX</option>
                            <option value="8to1">8-to-1 MUX</option>
                        </select>`;
                    break;
                case 'decoder':
                     paramsHTML = `
                        <label class="form-label">Decoder Size:</label>
                        <select class="form-select" id="decoderSize">
                            <option value="2to4">2-to-4 Decoder</option>
                            <option value="3to8">3-to-8 Decoder</option>
                        </select>`;
                    break;
                 case 'encoder':
                     paramsHTML = `
                        <label class="form-label">Encoder Size:</label>
                        <select class="form-select" id="encoderSize">
                            <option value="4to2">4-to-2 Encoder</option>
                            <option value="8to3">8-to-3 Encoder</option>
                        </select>`;
                    break;
            }
            paramsDiv.innerHTML = paramsHTML;
        }

        function designCircuit() {
            const circuitType = document.getElementById('circuitType')?.value;
            const diagramDiv = document.getElementById('circuitDiagram');
            if (!diagramDiv) return;

            // Placeholder logic - show text description or simple SVG
            let diagramContent = `<p class="text-muted">Diagram for ${circuitType}:</p>`;
            // In a real implementation, you'd generate SVG or use images
            diagramContent += `<svg width="200" height="100"><rect x="10" y="10" width="180" height="80" fill="#eee" stroke="#ccc"/><text x="100" y="55" text-anchor="middle">Placeholder Diagram</text></svg>`;

            diagramDiv.innerHTML = diagramContent;
        }

        // --- Functions for Slide 1.7 ---
        function updateSequentialDisplay() {
            const currentStateEl = document.getElementById('currentState');
            const nextStateEl = document.getElementById('nextState');
            const svg = document.getElementById('sequentialOutput')?.querySelector('svg');

            if (!currentStateEl || !nextStateEl || !svg) return;

            currentStateEl.textContent = `Q=${sequentialState.q}`;
            nextStateEl.textContent = `D=${sequentialState.d}, CLK=${sequentialState.clk}`;

            // Update SVG colors (simplified)
            const dCircle = svg.querySelector('circle:nth-of-type(1)');
            const qCircle = svg.querySelector('circle:nth-of-type(2)');
            const clkLine = svg.querySelector('line:nth-of-type(4)'); // Assuming it's the 4th line

            if (dCircle) dCircle.setAttribute('fill', sequentialState.d ? '#a5d6a7' : '#ffcdd2'); // Green/Red
            if (qCircle) qCircle.setAttribute('fill', sequentialState.q ? '#a5d6a7' : '#ffcdd2'); // Green/Red
            if (clkLine) clkLine.setAttribute('stroke', sequentialState.clk ? '#0f0' : '#f00'); // Green/Red
        }

        function simulateSequential() {
            // Simulate D flip-flop behavior on rising clock edge
            if (sequentialState.clk === 1) { // Assuming pulse or high state triggers
                 // Check previous state if needed, but for simple D-FF:
                 sequentialState.q = sequentialState.d;
            }
            // If it was a pulse, clk might already be 0 here, state holds
            updateSequentialDisplay();
        }

        function resetSequential() {
            sequentialState = { q: 0, d: 0, clk: 0 };
            // Reset button states visually
            const sequentialSlide = document.getElementById('slide-1.7');
             if (sequentialSlide) {
                const clockButtons = sequentialSlide.querySelectorAll('.form-group:nth-of-type(1) .btn-group button');
                const inputButtons = sequentialSlide.querySelectorAll('.form-group:nth-of-type(2) .btn-group button');
                clockButtons.forEach(b => b.classList.remove('active', 'btn-success'));
                clockButtons.forEach(b => b.classList.add('btn-outline-primary'));
                clockButtons[0].classList.add('active'); // Set clock to Low
                clockButtons[0].classList.remove('btn-outline-primary');

                inputButtons.forEach(b => b.classList.remove('active'));
                inputButtons[0].classList.add('active'); // Set D to 0
            }
            updateSequentialDisplay();
        }

    </script>
</body>
</html>